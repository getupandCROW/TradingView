/*
THIS IS A GENERATED/BUNDLED FILE BY ROLLUP
if you want to view the source visit the plugins github repository
*/

'use strict';

var obsidian = require('obsidian');

/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */

function __awaiter(thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
}

/*
 * Filename: multi-column-markdown/src/regionSettings.ts
 * Created Date: Tuesday, February 1st 2022, 12:23:53 pm
 * Author: Cameron Robinson
 *
 * Copyright (c) 2022 Cameron Robinson
 */
var BorderOption;
(function (BorderOption) {
    BorderOption[BorderOption["enabled"] = 0] = "enabled";
    BorderOption[BorderOption["on"] = 1] = "on";
    BorderOption[BorderOption["true"] = 2] = "true";
    BorderOption[BorderOption["disabled"] = 3] = "disabled";
    BorderOption[BorderOption["off"] = 4] = "off";
    BorderOption[BorderOption["false"] = 5] = "false";
})(BorderOption || (BorderOption = {}));
var ShadowOption;
(function (ShadowOption) {
    ShadowOption[ShadowOption["enabled"] = 0] = "enabled";
    ShadowOption[ShadowOption["on"] = 1] = "on";
    ShadowOption[ShadowOption["true"] = 2] = "true";
    ShadowOption[ShadowOption["disabled"] = 3] = "disabled";
    ShadowOption[ShadowOption["off"] = 4] = "off";
    ShadowOption[ShadowOption["false"] = 5] = "false";
})(ShadowOption || (ShadowOption = {}));
var ColumnLayout;
(function (ColumnLayout) {
    ColumnLayout[ColumnLayout["standard"] = 0] = "standard";
    ColumnLayout[ColumnLayout["left"] = 1] = "left";
    ColumnLayout[ColumnLayout["first"] = 2] = "first";
    ColumnLayout[ColumnLayout["center"] = 3] = "center";
    ColumnLayout[ColumnLayout["middle"] = 4] = "middle";
    ColumnLayout[ColumnLayout["second"] = 5] = "second";
    ColumnLayout[ColumnLayout["right"] = 6] = "right";
    ColumnLayout[ColumnLayout["third"] = 7] = "third";
    ColumnLayout[ColumnLayout["last"] = 8] = "last";
})(ColumnLayout || (ColumnLayout = {}));

/*
 * File: multi-column-markdown/src/MultiColumnParser.ts
 * Created Date: Saturday, January 22nd 2022, 6:02:46 pm
 * Author: Cameron Robinson
 *
 * Copyright (c) 2022 Cameron Robinson
 */
const START_REGEX_STRS = ["=== *start-multi-column(:?[a-zA-Z0-9-_\\s]*)?",
    "=== *multi-column-start(:?[a-zA-Z0-9-_\\s]*)?",
    "```multi-column-start",
    "```start-multi-column"];
const START_REGEX_ARR = [];
for (let i = 0; i < START_REGEX_STRS.length; i++) {
    START_REGEX_ARR.push(new RegExp(START_REGEX_STRS[i]));
}
const START_REGEX_STRS_WHOLE_LINE = ["^=== *start-multi-column(:?[a-zA-Z0-9-_\\s]*)?$",
    "^=== *multi-column-start(:?[a-zA-Z0-9-_\\s]*)?$",
    "^```multi-column-start$",
    "^```start-multi-column$"];
const START_REGEX_ARR_WHOLE_LINE = [];
for (let i = 0; i < START_REGEX_STRS_WHOLE_LINE.length; i++) {
    START_REGEX_ARR_WHOLE_LINE.push(new RegExp(START_REGEX_STRS_WHOLE_LINE[i]));
}
function findStartTag(text) {
    let found = false;
    let startPosition = -1;
    for (let i = 0; i < START_REGEX_ARR.length; i++) {
        if (START_REGEX_ARR[i].test(text)) {
            // We found a match but is it an actual match or a false positive.
            startPosition = text.search(START_REGEX_STRS[i]);
            // Take the text and get the line we found.
            let line = "";
            if (startPosition > 0) {
                // If we arent at the very begining of the file we step back
                // one character to see if we find a newline before this line.
                let lines = text.slice(startPosition - 1).split("\n");
                // if the last char before our match is a newline then we will
                // end up with an empty string in index 0.
                if (lines[0] === "" && lines.length > 1) {
                    line = lines[1];
                }
            }
            else {
                line = text.slice(startPosition).split("\n")[0];
            }
            // now we recheck the regex to make sure the found line is 
            // a true start tag.
            if (START_REGEX_ARR_WHOLE_LINE[i].test(line)) {
                found = true;
                break;
            }
        }
    }
    return { found, startPosition };
}
function containsStartTag(text) {
    return findStartTag(text).found;
}
function isStartTagWithID(text) {
    let startTagData = findStartTag(text);
    if (startTagData.found === true) {
        let key = getStartTagKey(text);
        if (key === null || key === "") {
            return { isStartTag: true, hasKey: false };
        }
        return { isStartTag: true, hasKey: true };
    }
    return { isStartTag: false, hasKey: false };
}
const END_REGEX_STRS = ["=== *end-multi-column",
    "=== *multi-column-end"];
const END_REGEX_ARR = [];
for (let i = 0; i < END_REGEX_STRS.length; i++) {
    END_REGEX_ARR.push(new RegExp(END_REGEX_STRS[i]));
}
function findEndTag(text) {
    let found = false;
    let startPosition = -1;
    for (let i = 0; i < END_REGEX_ARR.length; i++) {
        if (END_REGEX_ARR[i].test(text)) {
            found = true;
            startPosition = text.search(END_REGEX_STRS[i]);
            break;
        }
    }
    return { found, startPosition };
}
function containsEndTag(text) {
    return findEndTag(text).found;
}
const COL_REGEX_STRS = ["=== *column-end *===",
    "=== *end-column *===",
    "=== *column-break *===",
    "=== *break-column *==="];
const COL_REGEX_ARR = [];
for (let i = 0; i < COL_REGEX_STRS.length; i++) {
    COL_REGEX_ARR.push(new RegExp(COL_REGEX_STRS[i]));
}
function containsColEndTag(text) {
    let found = false;
    for (let i = 0; i < COL_REGEX_ARR.length; i++) {
        if (COL_REGEX_ARR[i].test(text)) {
            found = true;
            break;
        }
    }
    return found;
}
const COL_SETTINGS_REGEX_STRS = ["```settings",
    "```column-settings",
    "```multi-column-settings"];
const COL_SETTINGS_REGEX_ARR = [];
for (let i = 0; i < COL_SETTINGS_REGEX_STRS.length; i++) {
    COL_SETTINGS_REGEX_ARR.push(new RegExp(COL_SETTINGS_REGEX_STRS[i]));
}
function containsColSettingsTag(text) {
    let found = false;
    for (let i = 0; i < COL_SETTINGS_REGEX_ARR.length; i++) {
        if (COL_SETTINGS_REGEX_ARR[i].test(text)) {
            found = true;
            break;
        }
    }
    return found;
}
function parseColumnSettings(settingsStr) {
    // Set the minimum number of columnds to 2.
    let numberOfColumns = 2;
    let columnLayout = ColumnLayout.standard;
    let borderDrawn = true;
    let shadowDrawn = true;
    let settingsLines = settingsStr.split("\n");
    for (let i = 0; i < settingsLines.length; i++) {
        if (settingsLines[i].toLowerCase().replace(/\s/g, "").contains("numberofcolumns:")) {
            let userDefNumberOfCols = parseInt(settingsLines[i].split(":")[1]);
            if (Number.isNaN(userDefNumberOfCols) === false) {
                if (userDefNumberOfCols === 3) {
                    numberOfColumns = 3;
                }
                else if (userDefNumberOfCols === 2) {
                    numberOfColumns = 2;
                }
            }
            break;
        }
    }
    for (let i = 0; i < settingsLines.length; i++) {
        if (settingsLines[i].toLowerCase().replace(/\s/g, "").contains("largestcolumn:")) {
            let setting = settingsLines[i].split(":")[1].trimStart().trimEnd().toLowerCase();
            let userDefLayout = ColumnLayout[setting];
            if (userDefLayout !== undefined) {
                columnLayout = userDefLayout;
            }
        }
    }
    for (let i = 0; i < settingsLines.length; i++) {
        if (settingsLines[i].toLowerCase().replace(/\s/g, "").contains("border:")) {
            let setting = settingsLines[i].split(":")[1].trimStart().trimEnd().toLowerCase();
            let isBorderDrawn = BorderOption[setting];
            if (isBorderDrawn !== undefined) {
                switch (isBorderDrawn) {
                    case (BorderOption.disabled):
                    case (BorderOption.off):
                    case (BorderOption.false):
                        borderDrawn = false;
                        break;
                }
            }
        }
    }
    for (let i = 0; i < settingsLines.length; i++) {
        if (settingsLines[i].toLowerCase().replace(/\s/g, "").contains("shadow:")) {
            let setting = settingsLines[i].split(":")[1].trimStart().trimEnd().toLowerCase();
            let isShadowDrawn = ShadowOption[setting];
            if (isShadowDrawn !== undefined) {
                switch (isShadowDrawn) {
                    case (ShadowOption.disabled):
                    case (ShadowOption.off):
                    case (ShadowOption.false):
                        shadowDrawn = false;
                        break;
                }
            }
        }
    }
    let settings = { numberOfColumns, columnLayout, drawBorder: borderDrawn, drawShadow: shadowDrawn };
    return settings;
}
function countStartTags(text) {
    let keys = [];
    let startTagData = findStartTag(text);
    while (startTagData.found) {
        // Slice off everything before the tag
        text = text.slice(startTagData.startPosition);
        /**
         * Get just the start tag line and then set text to everything just
         * after the start tag.
         */
        let tag = text.split("\n")[0];
        text = text.slice(1); // This moves the text 1 character so we dont match the same tag.
        // Parse out the key and append to the list.
        let key = getStartTagKey(tag);
        if (key === null) {
            key = "";
        }
        keys.push(key);
        // Search again for another tag before looping.
        startTagData = findStartTag(text);
    }
    return { numberOfTags: keys.length, keys };
}
/**
 * This function will filter a set of strings, returning all items starting
 * from the closest open start tag through the last item in the set.
 *
 * The function filters out all end tags to make sure that the start tag we
 * find is the proper start tag for the list sent.
 * @param linesAboveArray
 * @returns
 */
function getStartBlockAboveLine(linesAboveArray) {
    // Reduce the array down into a single string so that we can
    // easily RegEx over the string and find the indicies we're looking for.
    let linesAboveStr = linesAboveArray.reduce((prev, current) => {
        return prev + "\n" + current;
    }, "");
    /*
        * First thing we need to do is check if there are any end tags in the
        * set of strings (which logically would close start tags and therefore
        * the start tag it closes is not what we want). If there are we want to
        * slowly narrow down our set of strings until the last end tag is
        * removed. This makes it easier to find the closest open start tag
        * in the data.
        */
    let endTagSerachData = findEndTag(linesAboveStr);
    while (endTagSerachData.found === true) {
        // Get the index of where the first regex match in the
        // string is. then we slice from 0 to index off of the string
        // split it by newline, cut off the first line (which actually
        // contains the regex) then reduce back down to a single string.
        //
        // TODO: This could be simplified if we just slice the text after
        // the end tag instead of the begining.
        let indexOfRegex = endTagSerachData.startPosition;
        linesAboveArray = linesAboveStr.slice(indexOfRegex).split("\n").splice(1);
        linesAboveStr = linesAboveArray.reduce((prev, current) => {
            return prev + "\n" + current;
        }, "");
        endTagSerachData = findEndTag(linesAboveStr);
    }
    /**
     * Now we have the set of lines after all other end tags. We now
     * need to check if there is still a start tag left in the data. If
     * there is no start tag then we want to return an empty array and empty
     * key.
     */
    let startBlockKey = "";
    let startTagSearchData = findStartTag(linesAboveStr);
    if (startTagSearchData.found === false) {
        return null;
    }
    else {
        /**
         * Now we know there is at least 1 start key left, however there
         * may be multiple start keys if the user is not closing their
         * blocks. We currently dont allow recusive splitting so we
         * want to get the last key in our remaining set. Same idea as
         * above.
         */
        while (startTagSearchData.found === true) {
            // Get the index of where the first regex match in the
            // string is. then we slice from 0 to index off of the string
            // split it by newline, cut off the first line (which actually
            // contains the regex) then reduce back down to a single string.
            //
            // TODO: This could be simplified if we just slice the text after
            // the end tag instead of the begining.
            let startIndex = startTagSearchData.startPosition;
            linesAboveArray = linesAboveStr.slice(startIndex).split("\n");
            let startTag = linesAboveArray[0];
            let key = getStartTagKey(startTag);
            if (key !== null) {
                startBlockKey = key;
            }
            linesAboveArray = linesAboveArray.splice(1);
            linesAboveStr = linesAboveArray.reduce((prev, current) => {
                return prev + "\n" + current;
            }, "");
            startTagSearchData = findStartTag(linesAboveStr);
        }
    }
    if (startBlockKey === "") {
        let codeBlockData = parseCodeBlockStart(linesAboveArray);
        if (codeBlockData !== null) {
            startBlockKey = codeBlockData.id;
            if (codeBlockData.index > 0) {
                linesAboveArray = linesAboveArray.slice(codeBlockData.index + 1);
            }
        }
    }
    return { startBlockKey, linesAboveArray };
}
function getEndBlockBelow(linesBelow) {
    // Reduce the array down into a single string so that we can
    // easily RegEx over the string and find the indicies we're looking for.
    let linesBelowStr = linesBelow.reduce((prev, current) => {
        return prev + "\n" + current;
    }, "");
    let endTagSerachData = findEndTag(linesBelowStr);
    let startTagSearchData = findStartTag(linesBelowStr);
    let sliceEndIndex = -1; // If neither start or end found we return the entire array.
    if (endTagSerachData.found === true && startTagSearchData.found === false) {
        sliceEndIndex = endTagSerachData.startPosition;
    }
    else if (endTagSerachData.found === false && startTagSearchData.found === true) {
        sliceEndIndex = startTagSearchData.startPosition;
    }
    else if (endTagSerachData.found === true && startTagSearchData.found === true) {
        sliceEndIndex = endTagSerachData.startPosition;
        if (startTagSearchData.startPosition < endTagSerachData.startPosition) {
            /**
             * If we found a start tag before an end tag we want to use the start tag
             * our current block is not properly ended and we use the next start tag
             * as our limit
             */
            sliceEndIndex = startTagSearchData.startPosition;
        }
    }
    return linesBelow.slice(0, sliceEndIndex);
}
function getStartTagKey(startTag) {
    let keySplit = startTag.split(":");
    if (keySplit.length > 1) {
        return keySplit[1].replace(" ", "");
    }
    return null;
}
const TAB_HEADER_END_REGEX_STR = "^```$";
const TAB_HEADER_END_REGEX = new RegExp(TAB_HEADER_END_REGEX_STR);
function parseCodeBlockStart(codeBlockLines) {
    let id = null;
    for (let i = 0; i < codeBlockLines.length; i++) {
        let line = codeBlockLines[i];
        if (id === null) {
            let key = line.split(":")[0];
            if (key.toLowerCase() === "region id") {
                id = line.split(":")[1].trim();
            }
        }
        else {
            if (TAB_HEADER_END_REGEX.test(line)) {
                return { id: id, index: i };
            }
        }
    }
    if (id === null) {
        return null;
    }
    else {
        return { id: id, index: -1 };
    }
}

/*
 * File: multi-column-markdown/src/utilities/cssDefinitions.ts
 * Created Date: Wednesday, February 16th 2022, 11:09:06 am
 * Author: Cameron Robinson
 *
 * Copyright (c) 2022 Cameron Robinson
 */
var MultiColumnLayoutCSS;
(function (MultiColumnLayoutCSS) {
    MultiColumnLayoutCSS["RegionRootContainerDiv"] = "multiColumnContainer";
    MultiColumnLayoutCSS["RegionErrorContainerDiv"] = "multiColumnErrorContainer";
    MultiColumnLayoutCSS["RegionContentContainerDiv"] = "RenderColRegion";
    MultiColumnLayoutCSS["RegionColumnContainerDiv"] = "multiColumnParent";
    MultiColumnLayoutCSS["RegionColumnContent"] = "columnContent";
    MultiColumnLayoutCSS["ColumnDualElementContainer"] = "MultiColumn_ElementContainer";
    MultiColumnLayoutCSS["OriginalElementType"] = "MultiColumn_OriginalElement";
    MultiColumnLayoutCSS["ClonedElementType"] = "MultiColumn_ClonedElement";
})(MultiColumnLayoutCSS || (MultiColumnLayoutCSS = {}));
var MultiColumnStyleCSS;
(function (MultiColumnStyleCSS) {
    MultiColumnStyleCSS["RegionErrorMessage"] = "multiColumnErrorMessage";
    MultiColumnStyleCSS["RegionSettings"] = "multiColumnSettings";
    MultiColumnStyleCSS["RegionContent"] = "multiColumnContent";
    MultiColumnStyleCSS["RegionEndTag"] = "multiColumnRegionEndTag";
    MultiColumnStyleCSS["ColumnEndTag"] = "multiColumnBreak";
    MultiColumnStyleCSS["RegionShadow"] = "multiColumnParentShadow";
    MultiColumnStyleCSS["ColumnShadow"] = "columnShadow";
    MultiColumnStyleCSS["ColumnBorder"] = "columnBorder";
})(MultiColumnStyleCSS || (MultiColumnStyleCSS = {}));

/*
 * File: multi-column-markdown/src/domManager.ts
 * Created Date: Saturday, January 30th 2022, 3:16:32 pm
 * Author: Cameron Robinson
 *
 * Copyright (c) 2022 Cameron Robinson
 */
class GlobalDOMManager {
    constructor() {
        this.managers = new Map();
    }
    removeFileManagerCallback(key) {
        if (this.managers.has(key) === true) {
            this.managers.delete(key);
        }
    }
    getFileManager(key) {
        let fileManager = null;
        if (this.managers.has(key) === true) {
            fileManager = this.managers.get(key);
        }
        else {
            fileManager = createFileDOMManager(this, key);
            this.managers.set(key, fileManager);
        }
        return fileManager;
    }
    getAllFileManagers() {
        return Array.from(this.managers.values());
    }
}
function createFileDOMManager(parentManager, fileKey) {
    let regionMap = new Map();
    let hasStartTag = false;
    function removeRegion(regionKey) {
        let regionManager = regionMap.get(regionKey);
        if (regionManager) {
            regionManager.displayOriginalElements();
        }
        regionMap.delete(regionKey);
        if (regionMap.size === 0) {
            parentManager.removeFileManagerCallback(fileKey);
        }
    }
    function createRegionalManager(regionKey, rootElement, errorElement, renderRegionElement) {
        //TODO: Use the error element whenever there is an error.
        let regonalManager = createRegionalDomManager(this, regionKey, rootElement, renderRegionElement);
        regionMap.set(regionKey, regonalManager);
        return regonalManager;
    }
    function getRegionalManager(regionKey) {
        let regonalManager = null;
        if (regionMap.has(regionKey) === true) {
            regonalManager = regionMap.get(regionKey);
        }
        return regonalManager;
    }
    function getAllRegionalManagers() {
        return Array.from(regionMap.values());
    }
    function setHasStartTag() {
        hasStartTag = true;
    }
    function getHasStartTag() {
        return hasStartTag;
    }
    function getNumberOfRegions() {
        return regionMap.size;
    }
    function checkKeyExists(checkKey) {
        return regionMap.has(checkKey);
    }
    return { regionMap: regionMap,
        hasStartTag: hasStartTag,
        createRegionalManager: createRegionalManager,
        getRegionalManager: getRegionalManager,
        getAllRegionalManagers: getAllRegionalManagers,
        removeRegion: removeRegion,
        setHasStartTag: setHasStartTag,
        getHasStartTag: getHasStartTag,
        getNumberOfRegions: getNumberOfRegions,
        checkKeyExists: checkKeyExists
    };
}
class RegionDOMManager {
    constructor(fileManager, regionKey, rootElement, regionParent) {
        this.domList = [];
        this.domObjectMap = new Map();
        this.regionalSettings = { numberOfColumns: 2, columnLayout: ColumnLayout.standard, drawBorder: true, drawShadow: true };
        this.regionParent = regionParent;
        this.regionKey = regionKey;
        this.rootElement = rootElement;
        this.fileManager = fileManager;
    }
    addObject(siblingsAbove, siblingsBelow, obj) {
        let prevObj = siblingsAbove.children[siblingsAbove.children.length - 1];
        let nextObj = siblingsBelow.children[0];
        let addAtIndex = siblingsAbove.children.length;
        if (prevObj !== undefined) {
            for (let i = this.domList.length - 1; i >= 0; i--) {
                if (this.domList[i].nodeKey === prevObj.innerText) {
                    addAtIndex = i + 1;
                    break;
                }
            }
        }
        let nextElIndex = addAtIndex;
        if (nextObj !== undefined) {
            for (let i = addAtIndex; i < this.domList.length; i++) {
                if (this.domList[i].nodeKey === nextObj.innerText.trim()) {
                    nextElIndex = i;
                    break;
                }
            }
        }
        // console.log(" Prev: ", siblingsAbove.children[siblingsAbove.children.length - 1], "Adding: ", obj.element, " Next: ", siblingsBelow.children[0], "Overwriting:", this.domList.slice(addAtIndex, nextElIndex));
        this.domList.splice(addAtIndex, nextElIndex - addAtIndex, obj);
        this.domObjectMap.set(obj.UID, obj);
        // /**
        //  * Make a copy of the list to log, only because
        //  * console log updates its references with updates in memory.
        //  */
        // let x = this.domList.slice(0);
        // console.log(x);
        return addAtIndex;
    }
    removeObject(objectUID) {
        // /**
        //  * Make a copy of the list to log
        //  */
        // let x = domList.slice(0);
        // console.log(x);
        // Get the object by key, remove it from the map and then
        // from the list.
        let obj = this.domObjectMap.get(objectUID);
        this.domObjectMap.delete(objectUID);
        if (obj === undefined) {
            return;
        }
        if (this.domList.contains(obj)) {
            this.domList.remove(obj);
        }
        if (this.domList.length === 0) {
            this.fileManager.removeRegion(this.regionKey);
        }
        // x = domList.slice(0);
        // console.log(x);
    }
    updateElementTag(objectUID, newTag) {
        let obj = this.domObjectMap.get(objectUID);
        let index = this.domList.indexOf(obj);
        if (index !== -1) {
            this.domList[index].tag = newTag;
        }
    }
    setRegionalSettings(settingsText) {
        this.regionalSettings = parseColumnSettings(settingsText);
    }
    /**
     * Creates an object containing all necessary information for the region
     * to be rendered to the preview pane.
     *
     * @returns a MultiColumnRenderData object with the root DOM element, settings object, and
     * all child objects in the order they should be rendered.
     */
    getRegionRenderData() {
        return {
            parentRenderElement: this.regionParent,
            parentRenderSettings: this.regionalSettings,
            domObjects: this.domList
        };
    }
    /**
     * This fuction is called when a start tag is removed from view meaning
     * our parent element storing the multi-column region is removed. It
     * removes the CSS class from all of the elements so they will be
     * re-rendered in the preview window.
     */
    displayOriginalElements() {
        for (let i = 0; i < this.domList.length; i++) {
            if (this.domList[i].originalElement) {
                this.domList[i].originalElement.removeClasses([MultiColumnStyleCSS.RegionEndTag,
                    MultiColumnStyleCSS.ColumnEndTag,
                    MultiColumnStyleCSS.RegionSettings,
                    MultiColumnStyleCSS.RegionContent]);
                if (this.domList[i].originalElement.parentElement) {
                    this.domList[i].originalElement.parentElement.removeChild(this.domList[i].originalElement);
                }
            }
        }
    }
    getRootRegionElement() {
        return this.rootElement;
    }
    getID() {
        return this.regionKey;
    }
}
function createRegionalDomManager(fileManager, regionKey, rootElement, renderRegionElement) {
    return new RegionDOMManager(fileManager, regionKey, rootElement, renderRegionElement);
}

/*
 * Filename: multi-column-markdown/src/utilities/utils.ts
 * Created Date: Tuesday, January 30th 2022, 4:02:19 pm
 * Author: Cameron Robinson
 *
 * Copyright (c) 2022 Cameron Robinson
 */
function getUID(length = 10) {
    if (length > 10) {
        length = 10;
    }
    let UID = Math.random().toString(36).substring(2);
    UID = UID.slice(0, length);
    return UID;
}

var ElementRenderType;
(function (ElementRenderType) {
    ElementRenderType[ElementRenderType["undefined"] = 0] = "undefined";
    ElementRenderType[ElementRenderType["normalRender"] = 1] = "normalRender";
    ElementRenderType[ElementRenderType["specialRender"] = 2] = "specialRender";
})(ElementRenderType || (ElementRenderType = {}));
function getElementRenderType(element) {
    /**
     * Look for specific kinds of elements by their CSS class names here. These
     * are going to be brittle links as they rely on other plugin definitions but
     * as this is only adding in extra compatability to the plugins defined here
     * it should be ok.
     *
     * These may be classes on one of the simple elements (such as a paragraph)
     * that we search for below so need to look for these first.
     */
    if (hasDiceRoller(element) === true ||
        hasCopyButton(element) === true) {
        return ElementRenderType.specialRender;
    }
    if (hasAdmonition(element) === true ||
        isIFrame(element) === true) {
        return ElementRenderType.normalRender;
    }
    /**
     * If we didnt find a special element we want to check for simple elements
     * such as paragraphs or lists. In the current implementation we only set up
     * the special case for "specialRender" elements so this *should* be saving
     * some rendering time by setting these tags properly.
     */
    if (hasParagraph(element) ||
        hasHeader(element) ||
        hasList(element)) {
        return ElementRenderType.normalRender;
    }
    // If still nothing found we return other as the default response if nothing else found.
    return ElementRenderType.specialRender;
}
function hasParagraph(element) {
    return element.innerHTML.startsWith("<p");
}
function hasHeader(element) {
    if (element.innerHTML.startsWith("<h1") ||
        element.innerHTML.startsWith("<h2") ||
        element.innerHTML.startsWith("<h3") ||
        element.innerHTML.startsWith("<h4") ||
        element.innerHTML.startsWith("<h5") ||
        element.innerHTML.startsWith("<h6")) {
        return true;
    }
    return false;
}
function hasList(element) {
    if (element.innerHTML.startsWith("<ul") ||
        element.innerHTML.startsWith("<ol")) {
        return true;
    }
    return false;
}
function hasCopyButton(element) {
    if (element.getElementsByClassName("copy-code-button").length !== 0) {
        return true;
    }
    return false;
}
function hasDiceRoller(element) {
    return element.getElementsByClassName("dice-roller").length !== 0;
}
function hasAdmonition(element) {
    return element.getElementsByClassName("admonition").length !== 0;
}
function isIFrame(element) {
    if (element.children.length > 0) {
        return element.firstChild.nodeName.toLowerCase() === "iframe";
    }
    return false;
}

/*
 * Filename: multi-column-markdown/src/domObject.ts
 * Created Date: Tuesday, February 1st 2022, 12:04:00 pm
 * Author: Cameron Robinson
 *
 * Copyright (c) 2022 Cameron Robinson
 */
var DOMObjectTag;
(function (DOMObjectTag) {
    DOMObjectTag[DOMObjectTag["none"] = 0] = "none";
    DOMObjectTag[DOMObjectTag["startRegion"] = 1] = "startRegion";
    DOMObjectTag[DOMObjectTag["regionSettings"] = 2] = "regionSettings";
    DOMObjectTag[DOMObjectTag["columnBreak"] = 3] = "columnBreak";
    DOMObjectTag[DOMObjectTag["endRegion"] = 4] = "endRegion";
})(DOMObjectTag || (DOMObjectTag = {}));
class DOMObject {
    constructor(element, randomID = getUID(), tag = DOMObjectTag.none) {
        this.elementType = ElementRenderType.undefined;
        this.elementContainer = null;
        this.nodeKey = element.innerText.trim();
        this.originalElement = element;
        this.UID = randomID;
        this.tag = tag;
        this.usingOriginalElement = false;
    }
    setMainDOMElement(domElement) {
        this.originalElement = domElement;
        this.usingOriginalElement = true;
    }
}
class TaskListDOMObject extends DOMObject {
    constructor(baseDOMObject) {
        super(baseDOMObject.originalElement, baseDOMObject.UID, DOMObjectTag.startRegion);
        this.originalCheckboxes = [];
    }
    checkboxClicked(index) {
        if (index < this.originalCheckboxes.length) {
            let originalInput = this.originalCheckboxes[index].firstChild;
            originalInput.click();
        }
    }
}

/*
 * File: multi-column-markdown/src/main.ts
 * Created Date: Tuesday, October 5th 2021, 1:09 pm
 * Author: Cameron Robinson
 *
 * Copyright (c) 2022 Cameron Robinson
 */
class MultiColumnMarkdown extends obsidian.Plugin {
    constructor() {
        // settings: SplitColumnMarkdownSettings;
        super(...arguments);
        this.globalManager = new GlobalDOMManager();
    }
    onload() {
        return __awaiter(this, void 0, void 0, function* () {
            console.log("Loading multi-column markdown");
            this.setupMarkdownPostProcessor();
            //TODO: Set up this as a modal to set settings automatically
            this.addCommand({
                id: `insert-multi-column-region`,
                name: `Insert Multi-Column Region`,
                editorCallback: (editor, view) => {
                    try {
                        editor.getDoc().replaceSelection(`
=== multi-column-start: ID_${getUID(4)}
\`\`\`column-settings
Number of Columns: 2
Largest Column: standard
\`\`\`

=== end-column ===

=== multi-column-end

${editor.getDoc().getSelection()}`);
                    }
                    catch (e) {
                        new obsidian.Notice("Encountered an error inserting a multi-column region. Please try again later.");
                    }
                }
            });
            this.addCommand({
                id: `add-IDs-To-multi-column-region`,
                name: `Fix Missing IDs for Multi-Column Regions`,
                editorCallback: (editor, view) => {
                    try {
                        /**
                         * Not sure if there is an easier way to do this.
                         *
                         * Get all of the lines of the document split by newlines.
                         */
                        let lines = editor.getRange({ line: 0, ch: 0 }, { line: editor.getDoc().lineCount(), ch: 0 }).split("\n");
                        /**
                         * Loop through all of the lines checking if the line is a
                         * start tag and if so is it missing an ID.
                         */
                        let linesWithoutIDs = [];
                        let textWithoutIDs = [];
                        for (let i = 0; i < lines.length; i++) {
                            let data = isStartTagWithID(lines[i]);
                            if (data.isStartTag === true && data.hasKey === false) {
                                linesWithoutIDs.push(i);
                                textWithoutIDs.push(lines[i]);
                            }
                        }
                        if (linesWithoutIDs.length === 0) {
                            new obsidian.Notice("Found 0 missing IDs in the current document.");
                            return;
                        }
                        /**
                         * Now loop through each line that is missing an ID and
                         * generate a random ID and replace the original text.
                         */
                        for (let i = 0; i < linesWithoutIDs.length; i++) {
                            let originalText = textWithoutIDs[i];
                            let text = originalText;
                            text = text.trimEnd();
                            if (text.charAt(text.length - 1) === ":") {
                                text = text.slice(0, text.length - 1);
                            }
                            text = `${text}: ID_${getUID(4)}`;
                            editor.replaceRange(text, { line: linesWithoutIDs[i], ch: 0 }, { line: linesWithoutIDs[i], ch: originalText.length });
                        }
                        new obsidian.Notice(`Replaced ${linesWithoutIDs.length} missing ID(s) in the current document.`);
                    }
                    catch (e) {
                        new obsidian.Notice("Encountered an error addign IDs to multi-column regions. Please try again later.");
                    }
                }
            });
            this.registerInterval(window.setInterval(() => {
                this.UpdateOpenFilePreviews();
            }, 500));
        });
    }
    UpdateOpenFilePreviews() {
        let fileManagers = this.globalManager.getAllFileManagers();
        fileManagers.forEach(element => {
            let regionalManagers = element.getAllRegionalManagers();
            regionalManagers.forEach(regionManager => {
                let parentElementData = regionManager.getRegionRenderData();
                this.updateRenderedMarkdown(parentElementData.domObjects);
            });
        });
    }
    setupMarkdownPostProcessor() {
        this.registerMarkdownPostProcessor((el, ctx) => __awaiter(this, void 0, void 0, function* () {
            const sourcePath = ctx.sourcePath;
            let fileDOMManager = this.globalManager.getFileManager(sourcePath);
            if (fileDOMManager === null) {
                console.log("Found null DOM manager. Could not process multi-column markdown.");
                return;
            }
            /**
             * This block of code runs when the export tag is in the frontmatter so
             * we assume that the user is attempting to export the document.
             *
             * We loop over the elements passed and look for children that would be
             * within a multi-column region. If we find them we remove them from
             * the parent so they are not exported to the PDF.
             */
            if (this.checkExporting(el)) {
                let docChildren = Array.from(el.childNodes);
                let childrenToRemove = [];
                let inBlock = false;
                for (let i = 0; i < docChildren.length; i++) {
                    let child = docChildren[i];
                    if (child instanceof HTMLElement) {
                        if (inBlock === false) {
                            let blockData = isStartTagWithID(child.textContent);
                            if (blockData.isStartTag === true) {
                                inBlock = true;
                                let regionKey = "";
                                if (blockData.hasKey === true) {
                                    let foundKey = getStartTagKey(child.textContent);
                                    if (foundKey !== null) {
                                        regionKey = foundKey;
                                    }
                                }
                                for (let i = child.children.length - 1; i >= 0; i--) {
                                    child.children[i].detach();
                                }
                                child.innerText = "";
                                child.classList.add(MultiColumnLayoutCSS.RegionRootContainerDiv);
                                let renderErrorRegion = child.createDiv({
                                    cls: `${MultiColumnLayoutCSS.RegionErrorContainerDiv}, ${MultiColumnStyleCSS.RegionErrorMessage}`,
                                });
                                let renderColumnRegion = child.createDiv({
                                    cls: MultiColumnLayoutCSS.RegionContentContainerDiv
                                });
                                console.log("getting region from key", regionKey);
                                let regionalManager = fileDOMManager.getRegionalManager(regionKey);
                                if (regionalManager === null) {
                                    renderErrorRegion.innerText = "Error rendering multi-column region.\nPlease close and reopen the file, then make sure you are in reading mode before exporting.";
                                }
                                else {
                                    console.log("Rendering region?");
                                    let parentElementData = regionalManager.getRegionRenderData();
                                    // Default set shadow to off for exporting PDFs
                                    let renderSettings = parentElementData.parentRenderSettings;
                                    renderSettings.drawShadow = false;
                                    this.renderColumnMarkdown(parentElementData.parentRenderElement, parentElementData.domObjects, renderSettings);
                                    this.renderColumnMarkdown(renderColumnRegion, parentElementData.domObjects.slice(), parentElementData.parentRenderSettings);
                                }
                            }
                        }
                        else {
                            if (containsEndTag(child.textContent) === true) {
                                inBlock = false;
                            }
                            childrenToRemove.push(child);
                        }
                    }
                }
                childrenToRemove.forEach(child => {
                    el.removeChild(child);
                });
            }
            // Get the info for our current context and then check
            // if the entire text contains a start tag. If there is
            // no start tag in the document we can just return and
            // ignore the rest of the parsing.
            let info = ctx.getSectionInfo(el);
            /**
             * We need the context info to properly parse so returning here
             * info is null. TODO: Set error in view if this occurs.
             */
            if (!info) {
                return;
            }
            /**
             * If we encounter a start tag on the document we set the flag to start
             * parsing the rest of the document.
             */
            if (containsStartTag(el.textContent)) {
                fileDOMManager.setHasStartTag();
            }
            /**
             * If the document does not contain any start tags we ignore the
             * rest of the parsing. This is only set to true once the first
             * start tag element is parsed above.
             */
            if (fileDOMManager.getHasStartTag() === false) {
                return;
            }
            /**
             * Take the info provided and generate the required variables from
             * the line start and end values.
             */
            let docLines = info.text.split("\n");
            let linesAboveArray = docLines.slice(0, info.lineStart);
            let linesOfElement = docLines.slice(info.lineStart, info.lineEnd + 1);
            let linesBelowArray = docLines.slice(info.lineEnd + 1);
            /**
             * If the current line is a start tag we want to set up the
             * region manager. The regional manager takes care
             * of all items between it's start and end tags while the
             * file manager we got above above takes care of all regional
             * managers in each file.
             */
            let elementTextSpaced = linesOfElement.reduce((prev, curr) => {
                return prev + "\n" + curr;
            });
            if (containsStartTag(el.textContent)) {
                /**
                 * Set up the current element to act as the parent for the
                 * multi-column region.
                 */
                el.children[0].detach();
                el.classList.add(MultiColumnLayoutCSS.RegionRootContainerDiv);
                let renderErrorRegion = el.createDiv({
                    cls: `${MultiColumnLayoutCSS.RegionErrorContainerDiv}, ${MultiColumnStyleCSS.RegionErrorMessage}`,
                });
                let renderColumnRegion = el.createDiv({
                    cls: MultiColumnLayoutCSS.RegionContentContainerDiv
                });
                let startBlockData = getStartBlockAboveLine(linesOfElement);
                if (startBlockData === null) {
                    return;
                }
                let regionKey = startBlockData.startBlockKey;
                if (fileDOMManager.checkKeyExists(regionKey) === true) {
                    let { numberOfTags, keys } = countStartTags(info.text);
                    let numMatches = 0;
                    for (let i = 0; i < numberOfTags; i++) {
                        // Because we checked if key exists one of these has to match.
                        if (keys[i] === regionKey) {
                            numMatches++;
                        }
                    }
                    // We only want to display an error if there are more than 2 of the same id across
                    // the whole document. This prevents erros when obsidian reloads the whole document
                    // and there are two of the same key in the map.
                    if (numMatches >= 2) {
                        if (regionKey === "") {
                            renderErrorRegion.innerText = "Found multiple regions with empty IDs. Please set a unique ID after each start tag.\nEG: '=== multi-column-start: randomID'\nOr use 'Fix Missing IDs' in the command palette and reload the document.";
                        }
                        else {
                            renderErrorRegion.innerText = "Region ID already exists in document, please set a unique ID.\nEG: '=== multi-column-start: randomID'";
                        }
                        return;
                    }
                }
                el.id = `MultiColumnID:${regionKey}`;
                let elementMarkdownRenderer = new obsidian.MarkdownRenderChild(el);
                fileDOMManager.createRegionalManager(regionKey, el, renderErrorRegion, renderColumnRegion);
                elementMarkdownRenderer.onunload = () => {
                    if (fileDOMManager) {
                        fileDOMManager.removeRegion(startBlockData.startBlockKey);
                    }
                };
                ctx.addChild(elementMarkdownRenderer);
                /**
                 * Now we have created our regional manager and defined what elements
                 * need to be rendered into. So we can return without any more processing.
                 */
                return;
            }
            /**
             * Check if any of the lines above us contain a start block, and if
             * so get the lines from our current element to the start block.
             */
            let startBockAbove = getStartBlockAboveLine(linesAboveArray);
            if (startBockAbove === null) {
                return;
            }
            /**
             * We now know we're within a multi-column region, so we update our
             * list of lines above to just be the items within this region.
             */
            linesAboveArray = startBockAbove.linesAboveArray;
            /**
             * We use the start block's key to get our regional manager. If this
             * lookup fails we can not continue processing this element.
             */
            let regionalManager = fileDOMManager.getRegionalManager(startBockAbove.startBlockKey);
            if (regionalManager === null) {
                return;
            }
            /**
             * To make sure we're placing the item in the right location (and
             * overwrite elements that are now gone) we now want all of the
             * lines after this element up to the end tag.
             */
            linesBelowArray = getEndBlockBelow(linesBelowArray);
            /**
             * Now we take the lines above our current element up until the
             * start region tag and render that into an HTML element. We will
             * use these elements to determine where to place our current element.
             */
            let siblingsAbove = renderMarkdownFromLines(linesAboveArray, sourcePath);
            let siblingsBelow = renderMarkdownFromLines(linesBelowArray, sourcePath);
            /**
             * Set up our dom object to be added to the manager.
             */
            let currentObject = new DOMObject(el);
            el.id = currentObject.UID;
            currentObject = this.checkSpecialElement(currentObject);
            /**
             * Now we add the object to the manager and then setup the
             * callback for when the object is removed from view that will remove
             * the item from the manager.
             */
            regionalManager.addObject(siblingsAbove, siblingsBelow, currentObject);
            let elementMarkdownRenderer = new obsidian.MarkdownRenderChild(el);
            elementMarkdownRenderer.onunload = () => {
                if (regionalManager) {
                    // We can attempt to update the view here after the item is removed
                    // but need to get the item's parent element before removing object from manager.
                    let regionRenderData = regionalManager.getRegionRenderData();
                    regionalManager.removeObject(currentObject.UID);
                    /**
                     * Need to check here if element is null as this closure will be called
                     * repeatedly on file change.
                     */
                    if (regionRenderData.parentRenderElement === null) {
                        return;
                    }
                    this.renderColumnMarkdown(regionRenderData.parentRenderElement, regionRenderData.domObjects, regionRenderData.parentRenderSettings);
                }
            };
            ctx.addChild(elementMarkdownRenderer);
            /**
             * Now we check if our current element is a special flag so we can
             * properly set the element tag within the regional manager.
             */
            if (containsEndTag(el.textContent) === true) {
                el.addClass(MultiColumnStyleCSS.RegionEndTag);
                regionalManager.updateElementTag(currentObject.UID, DOMObjectTag.endRegion);
            }
            else if (containsColEndTag(elementTextSpaced) === true) {
                el.addClass(MultiColumnStyleCSS.ColumnEndTag);
                regionalManager.updateElementTag(currentObject.UID, DOMObjectTag.columnBreak);
            }
            else if (containsColSettingsTag(elementTextSpaced) === true) {
                el.addClass(MultiColumnStyleCSS.RegionSettings);
                regionalManager.setRegionalSettings(elementTextSpaced);
            }
            else {
                el.addClass(MultiColumnStyleCSS.RegionContent);
            }
            /**
             * Use our regional manager to get everything needed to render the region.
             */
            let parentElementData = regionalManager.getRegionRenderData();
            this.renderColumnMarkdown(parentElementData.parentRenderElement, parentElementData.domObjects, parentElementData.parentRenderSettings);
            return;
        }));
    }
    /**
     * This function takes in the data for the multi-column region and sets up the
     * user defined number of children with the proper css classes to be rendered properly.
     *
     * @param parentElement The element that the multi-column region will be rendered under.
     * @param regionElements The list of DOM objects that will be coppied under the parent object
     * @param settings The settings the user has defined for the region.
     */
    renderColumnMarkdown(parentElement, regionElements, settings) {
        let multiColumnParent = createDiv({
            cls: MultiColumnLayoutCSS.RegionColumnContainerDiv,
        });
        if (settings.drawShadow === true) {
            multiColumnParent.addClass(MultiColumnStyleCSS.RegionShadow);
        }
        /**
         * Pass our parent div and settings to parser to create the required
         * column divs as children of the parent.
         */
        let columnContentDivs = getColumnContentDivs(settings, multiColumnParent);
        for (let i = 0; i < columnContentDivs.length; i++) {
            if (settings.drawBorder === true) {
                columnContentDivs[i].addClass(MultiColumnStyleCSS.ColumnBorder);
            }
            if (settings.drawShadow === true) {
                columnContentDivs[i].addClass(MultiColumnStyleCSS.ColumnShadow);
            }
        }
        // Create markdown renderer to parse the passed markdown
        // between the tags.
        let markdownRenderChild = new obsidian.MarkdownRenderChild(multiColumnParent);
        // Remove every other child from the parent so 
        // we dont end up with multiple sets of data. This should
        // really only need to loop once for i = 0 but loop just
        // in case.
        for (let i = parentElement.children.length - 1; i >= 0; i--) {
            parentElement.children[i].detach();
        }
        parentElement.appendChild(markdownRenderChild.containerEl);
        let columnIndex = 0;
        for (let i = 0; i < regionElements.length; i++) {
            if (regionElements[i].tag !== DOMObjectTag.startRegion ||
                regionElements[i].tag !== DOMObjectTag.regionSettings ||
                regionElements[i].tag !== DOMObjectTag.endRegion ||
                regionElements[i].tag !== DOMObjectTag.columnBreak) {
                // We store the elements in a wrapper container until we determine
                let element = createDiv({
                    cls: MultiColumnLayoutCSS.ColumnDualElementContainer,
                });
                regionElements[i].elementContainer = element;
                // Otherwise we just make a copy of the original element to display.
                let clonedElement = regionElements[i].originalElement.cloneNode(true);
                regionElements[i].clonedElement = clonedElement;
                element.appendChild(clonedElement);
                if (regionElements[i] instanceof TaskListDOMObject) {
                    this.fixClonedCheckListButtons(regionElements[i], true);
                }
                if (element !== null) {
                    columnContentDivs[columnIndex].appendChild(element);
                }
                /**
                 * If the tag is a column break we update the column index after
                 * appending the item to the column div. This keeps the main DOM
                 * cleaner by removing other items and placing them all within
                 * a region container.
                 */
                if (regionElements[i].tag === DOMObjectTag.columnBreak &&
                    (columnIndex + 1) < settings.numberOfColumns) {
                    columnIndex++;
                }
            }
        }
    }
    /**
     * This function takes in the original element and its clone and checks if
     * the element contains a task-list-item class. If so it loops through all
     * items in the list and fixes their checkboxes to properly fire an event.
     * The new checkbox calls the click function on the original checkbox so
     * compatability with other plugins *should* remain.
     * @param domElement
     * @param initalizeCheckboxes
     */
    fixClonedCheckListButtons(domElement, initalizeCheckboxes = false) {
        let element = domElement.originalElement;
        let clonedElement = domElement.clonedElement;
        let clonedListCheckboxes = Array.from(clonedElement.getElementsByClassName("task-list-item"));
        let originalListCheckboxes = Array.from(element.getElementsByClassName("task-list-item"));
        if (initalizeCheckboxes === true) {
            // When we initalize we remove the old input checkbox that contains
            // the weird callback situation causing the bug. Then we create a new
            // checkbox to replace it and set it up to fire the click event on
            // the original checkbox so functionality is restored.
            for (let i = 0; i < originalListCheckboxes.length; i++) {
                const checkbox = createEl('input');
                let originalInput = originalListCheckboxes[i].firstChild;
                checkbox.checked = originalInput.checked;
                clonedListCheckboxes[i].replaceChild(checkbox, clonedListCheckboxes[i].children[0]);
                checkbox.addClass('task-list-item-checkbox');
                checkbox.type = 'checkbox';
                checkbox.onClickEvent(() => {
                    domElement.checkboxClicked(i);
                });
            }
        }
        else {
            // Whenever we reach this point we update our list of original checkboxes
            // that may be different from our cache. This is due to how obsidian
            // changes the DOM underneath us so we need to constantly update our cache.
            domElement.originalCheckboxes = originalListCheckboxes;
        }
        // When the Tasks plugin is installed the cloned copy of the original element contains
        // an extra element for some reason. If this occurs for other reasons here we adjust
        // that to keep the clone the same as the original.
        if (clonedListCheckboxes.length > originalListCheckboxes.length) {
            for (let i = originalListCheckboxes.length; i < clonedListCheckboxes.length; i++) {
                domElement.clonedElement.removeChild(clonedListCheckboxes[i]);
            }
        }
    }
    checkSpecialElement(domElement) {
        if (domElement.originalElement.getElementsByClassName("task-list-item").length > 0) {
            return new TaskListDOMObject(domElement);
        }
        return domElement;
    }
    setUpDualRender(domElement) {
        /**
         * If our element is of "specialRender" type it *may* need to be rendered
         * using the original element rather than a copy. For example, an element
         * may have an onClick event that would not get coppied to the clone.
         *
         * If we just moved these elements into the region it would get
         * moved back out into the original location in the DOM by obsidian
         * when scrolling or when the file is updated. On the next refresh it
         * would be moved back but that can lead to a region jumping
         * around as the item is moved in and out.
         *
         * Here we set up the div to contain the element and create
         * a visual only clone of it. The clone will only be visible
         * when the original is not in the multi-column region so it
         * saves us from the visual noise of the region jumping around.
         */
        // Remove the old elements before we set up the dual rendered elements.
        let containerElement = domElement.elementContainer;
        let renderElement = domElement.originalElement;
        for (let i = containerElement.children.length - 1; i >= 0; i--) {
            containerElement.children[i].detach();
        }
        containerElement.appendChild(renderElement);
        renderElement.addClass(MultiColumnLayoutCSS.OriginalElementType);
        let clonedNode = renderElement.cloneNode(true);
        clonedNode.addClass(MultiColumnLayoutCSS.ClonedElementType);
        clonedNode.removeClasses([MultiColumnStyleCSS.RegionContent, MultiColumnLayoutCSS.OriginalElementType]);
        containerElement.appendChild(clonedNode);
    }
    updateRenderedMarkdown(regionElements) {
        /**
         * This function acts as the update loop for the multi-column regions.
         * Here we loop through all of the elements within the rendered region and
         * potentially update how things are rendered. We need to do this for
         * compatability with other plugins.
         *
         * If the multi-column region is rendered before other plugins that effect
         * content within the region our rendered data may not properly display
         * the content from the other plugin. Here we loop through the elements
         * after all plugins have had a chance to run and can make changes to the
         * DOM at this point.
         */
        for (let i = 0; i < regionElements.length; i++) {
            /**
             * Here we check for special cases
             */
            if (regionElements[i] instanceof TaskListDOMObject) {
                this.fixClonedCheckListButtons(regionElements[i]);
            }
            let elementType = regionElements[i].elementType;
            /**
             * If the element is not currently a special render element we check again
             * as the original element may have been updated.
             *
             * TODO: find a way to "Officially" mark normal elements rather than
             * continuously search for special render types.
             */
            if (elementType !== ElementRenderType.specialRender) {
                // If the new result returns as a special renderer we update so
                // this wont run again for this item.
                elementType = getElementRenderType(regionElements[i].originalElement);
            }
            if (elementType === ElementRenderType.specialRender) {
                regionElements[i].elementType = elementType;
                this.setUpDualRender(regionElements[i]);
            }
        }
    }
    checkExporting(element) {
        if (element === null) {
            return false;
        }
        if (element.classList.contains("print")) {
            return true;
        }
        if (element.parentNode !== null) {
            return this.checkExporting(element.parentElement);
        }
        return false;
    }
}
/**
 * Sets up the CSS classes and the number of columns based on the passed settings.
 * @param settings The user defined settings that determine what CSS is set here.
 * @param multiColumnParent The parent object that the column divs will be created under.
 * @returns The list of column divs created under the passed parent element.
 */
function getColumnContentDivs(settings, multiColumnParent) {
    let columnContentDivs = [];
    if (settings.numberOfColumns === 2) {
        switch (settings.columnLayout) {
            case (ColumnLayout.standard):
            case (ColumnLayout.middle):
            case (ColumnLayout.center):
            case (ColumnLayout.third):
                columnContentDivs.push(multiColumnParent.createDiv({
                    cls: `columnContent twoEqualColumns_Left`
                }));
                columnContentDivs.push(multiColumnParent.createDiv({
                    cls: `columnContent twoEqualColumns_Right`
                }));
                break;
            case (ColumnLayout.left):
            case (ColumnLayout.first):
                columnContentDivs.push(multiColumnParent.createDiv({
                    cls: `columnContent twoColumnsHeavyLeft_Left`
                }));
                columnContentDivs.push(multiColumnParent.createDiv({
                    cls: `columnContent twoColumnsHeavyLeft_Right`
                }));
                break;
            case (ColumnLayout.right):
            case (ColumnLayout.second):
            case (ColumnLayout.last):
                columnContentDivs.push(multiColumnParent.createDiv({
                    cls: `columnContent twoColumnsHeavyRight_Left`
                }));
                columnContentDivs.push(multiColumnParent.createDiv({
                    cls: `columnContent twoColumnsHeavyRight_Right`
                }));
                break;
        }
    }
    else if (settings.numberOfColumns === 3) {
        switch (settings.columnLayout) {
            case (ColumnLayout.standard):
                columnContentDivs.push(multiColumnParent.createDiv({
                    cls: `columnContent threeEqualColumns_Left`
                }));
                columnContentDivs.push(multiColumnParent.createDiv({
                    cls: `columnContent threeEqualColumns_Middle`
                }));
                columnContentDivs.push(multiColumnParent.createDiv({
                    cls: `columnContent threeEqualColumns_Right`
                }));
                break;
            case (ColumnLayout.left):
            case (ColumnLayout.first):
                columnContentDivs.push(multiColumnParent.createDiv({
                    cls: `columnContent threColumnsHeavyLeft_Left`
                }));
                columnContentDivs.push(multiColumnParent.createDiv({
                    cls: `columnContent threColumnsHeavyLeft_Middle`
                }));
                columnContentDivs.push(multiColumnParent.createDiv({
                    cls: `columnContent threColumnsHeavyLeft_Right`
                }));
                break;
            case (ColumnLayout.middle):
            case (ColumnLayout.center):
            case (ColumnLayout.second):
                columnContentDivs.push(multiColumnParent.createDiv({
                    cls: `columnContent threColumnsHeavyMiddle_Left`
                }));
                columnContentDivs.push(multiColumnParent.createDiv({
                    cls: `columnContent threColumnsHeavyMiddle_Middle`
                }));
                columnContentDivs.push(multiColumnParent.createDiv({
                    cls: `columnContent threColumnsHeavyMiddle_Right`
                }));
                break;
            case (ColumnLayout.right):
            case (ColumnLayout.third):
            case (ColumnLayout.last):
                columnContentDivs.push(multiColumnParent.createDiv({
                    cls: `columnContent threColumnsHeavyRight_Left`
                }));
                columnContentDivs.push(multiColumnParent.createDiv({
                    cls: `columnContent threColumnsHeavyRight_Middle`
                }));
                columnContentDivs.push(multiColumnParent.createDiv({
                    cls: `columnContent threColumnsHeavyRight_Right`
                }));
                break;
        }
    }
    return columnContentDivs;
}
function renderMarkdownFromLines(mdLines, sourcePath) {
    /**
     * We re-render all of the items above our element, until the start tag,
     * so we can determine where to place the new item in the manager.
     *
     * TODO: Can reduce the amount needing to be rendered by only rendering to
     * the start tag or a column-break whichever is closer.
     */
    let siblings = createDiv();
    let markdownRenderChild = new obsidian.MarkdownRenderChild(siblings);
    obsidian.MarkdownRenderer.renderMarkdown(mdLines.reduce((prev, current) => {
        return prev + "\n" + current;
    }, ""), siblings, sourcePath, markdownRenderChild);
    return siblings;
}

module.exports = MultiColumnMarkdown;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibWFpbi5qcyIsInNvdXJjZXMiOlsibm9kZV9tb2R1bGVzL3RzbGliL3RzbGliLmVzNi5qcyIsInNyYy9yZWdpb25TZXR0aW5ncy50cyIsInNyYy91dGlsaXRpZXMvdGV4dFBhcnNlci50cyIsInNyYy91dGlsaXRpZXMvY3NzRGVmaW5pdGlvbnMudHMiLCJzcmMvZG9tX21hbmFnZXIvZG9tTWFuYWdlci50cyIsInNyYy91dGlsaXRpZXMvdXRpbHMudHMiLCJzcmMvdXRpbGl0aWVzL2VsZW1lbnRSZW5kZXJUeXBlUGFyc2VyLnRzIiwic3JjL2RvbV9tYW5hZ2VyL2RvbU9iamVjdC50cyIsInNyYy9tYWluLnRzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qISAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxyXG5Db3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi5cclxuXHJcblBlcm1pc3Npb24gdG8gdXNlLCBjb3B5LCBtb2RpZnksIGFuZC9vciBkaXN0cmlidXRlIHRoaXMgc29mdHdhcmUgZm9yIGFueVxyXG5wdXJwb3NlIHdpdGggb3Igd2l0aG91dCBmZWUgaXMgaGVyZWJ5IGdyYW50ZWQuXHJcblxyXG5USEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiIEFORCBUSEUgQVVUSE9SIERJU0NMQUlNUyBBTEwgV0FSUkFOVElFUyBXSVRIXHJcblJFR0FSRCBUTyBUSElTIFNPRlRXQVJFIElOQ0xVRElORyBBTEwgSU1QTElFRCBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWVxyXG5BTkQgRklUTkVTUy4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUiBCRSBMSUFCTEUgRk9SIEFOWSBTUEVDSUFMLCBESVJFQ1QsXHJcbklORElSRUNULCBPUiBDT05TRVFVRU5USUFMIERBTUFHRVMgT1IgQU5ZIERBTUFHRVMgV0hBVFNPRVZFUiBSRVNVTFRJTkcgRlJPTVxyXG5MT1NTIE9GIFVTRSwgREFUQSBPUiBQUk9GSVRTLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgTkVHTElHRU5DRSBPUlxyXG5PVEhFUiBUT1JUSU9VUyBBQ1RJT04sIEFSSVNJTkcgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgVVNFIE9SXHJcblBFUkZPUk1BTkNFIE9GIFRISVMgU09GVFdBUkUuXHJcbioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqICovXHJcbi8qIGdsb2JhbCBSZWZsZWN0LCBQcm9taXNlICovXHJcblxyXG52YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uKGQsIGIpIHtcclxuICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcclxuICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XHJcbiAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGIsIHApKSBkW3BdID0gYltwXTsgfTtcclxuICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xyXG59O1xyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fZXh0ZW5kcyhkLCBiKSB7XHJcbiAgICBpZiAodHlwZW9mIGIgIT09IFwiZnVuY3Rpb25cIiAmJiBiICE9PSBudWxsKVxyXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDbGFzcyBleHRlbmRzIHZhbHVlIFwiICsgU3RyaW5nKGIpICsgXCIgaXMgbm90IGEgY29uc3RydWN0b3Igb3IgbnVsbFwiKTtcclxuICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XHJcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cclxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcclxufVxyXG5cclxuZXhwb3J0IHZhciBfX2Fzc2lnbiA9IGZ1bmN0aW9uKCkge1xyXG4gICAgX19hc3NpZ24gPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uIF9fYXNzaWduKHQpIHtcclxuICAgICAgICBmb3IgKHZhciBzLCBpID0gMSwgbiA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBuOyBpKyspIHtcclxuICAgICAgICAgICAgcyA9IGFyZ3VtZW50c1tpXTtcclxuICAgICAgICAgICAgZm9yICh2YXIgcCBpbiBzKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHMsIHApKSB0W3BdID0gc1twXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHQ7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gX19hc3NpZ24uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fcmVzdChzLCBlKSB7XHJcbiAgICB2YXIgdCA9IHt9O1xyXG4gICAgZm9yICh2YXIgcCBpbiBzKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHMsIHApICYmIGUuaW5kZXhPZihwKSA8IDApXHJcbiAgICAgICAgdFtwXSA9IHNbcF07XHJcbiAgICBpZiAocyAhPSBudWxsICYmIHR5cGVvZiBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzID09PSBcImZ1bmN0aW9uXCIpXHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIHAgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHMpOyBpIDwgcC5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBpZiAoZS5pbmRleE9mKHBbaV0pIDwgMCAmJiBPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwocywgcFtpXSkpXHJcbiAgICAgICAgICAgICAgICB0W3BbaV1dID0gc1twW2ldXTtcclxuICAgICAgICB9XHJcbiAgICByZXR1cm4gdDtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcclxuICAgIHZhciBjID0gYXJndW1lbnRzLmxlbmd0aCwgciA9IGMgPCAzID8gdGFyZ2V0IDogZGVzYyA9PT0gbnVsbCA/IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSA6IGRlc2MsIGQ7XHJcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xyXG4gICAgZWxzZSBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKSByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcclxuICAgIHJldHVybiBjID4gMyAmJiByICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgciksIHI7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX3BhcmFtKHBhcmFtSW5kZXgsIGRlY29yYXRvcikge1xyXG4gICAgcmV0dXJuIGZ1bmN0aW9uICh0YXJnZXQsIGtleSkgeyBkZWNvcmF0b3IodGFyZ2V0LCBrZXksIHBhcmFtSW5kZXgpOyB9XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX21ldGFkYXRhKG1ldGFkYXRhS2V5LCBtZXRhZGF0YVZhbHVlKSB7XHJcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QubWV0YWRhdGEgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIFJlZmxlY3QubWV0YWRhdGEobWV0YWRhdGFLZXksIG1ldGFkYXRhVmFsdWUpO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19hd2FpdGVyKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xyXG4gICAgZnVuY3Rpb24gYWRvcHQodmFsdWUpIHsgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgUCA/IHZhbHVlIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZSh2YWx1ZSk7IH0pOyB9XHJcbiAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcclxuICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XHJcbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XHJcbiAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBhZG9wdChyZXN1bHQudmFsdWUpLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cclxuICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XHJcbiAgICB9KTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fZ2VuZXJhdG9yKHRoaXNBcmcsIGJvZHkpIHtcclxuICAgIHZhciBfID0geyBsYWJlbDogMCwgc2VudDogZnVuY3Rpb24oKSB7IGlmICh0WzBdICYgMSkgdGhyb3cgdFsxXTsgcmV0dXJuIHRbMV07IH0sIHRyeXM6IFtdLCBvcHM6IFtdIH0sIGYsIHksIHQsIGc7XHJcbiAgICByZXR1cm4gZyA9IHsgbmV4dDogdmVyYigwKSwgXCJ0aHJvd1wiOiB2ZXJiKDEpLCBcInJldHVyblwiOiB2ZXJiKDIpIH0sIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiAoZ1tTeW1ib2wuaXRlcmF0b3JdID0gZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzOyB9KSwgZztcclxuICAgIGZ1bmN0aW9uIHZlcmIobikgeyByZXR1cm4gZnVuY3Rpb24gKHYpIHsgcmV0dXJuIHN0ZXAoW24sIHZdKTsgfTsgfVxyXG4gICAgZnVuY3Rpb24gc3RlcChvcCkge1xyXG4gICAgICAgIGlmIChmKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiR2VuZXJhdG9yIGlzIGFscmVhZHkgZXhlY3V0aW5nLlwiKTtcclxuICAgICAgICB3aGlsZSAoXykgdHJ5IHtcclxuICAgICAgICAgICAgaWYgKGYgPSAxLCB5ICYmICh0ID0gb3BbMF0gJiAyID8geVtcInJldHVyblwiXSA6IG9wWzBdID8geVtcInRocm93XCJdIHx8ICgodCA9IHlbXCJyZXR1cm5cIl0pICYmIHQuY2FsbCh5KSwgMCkgOiB5Lm5leHQpICYmICEodCA9IHQuY2FsbCh5LCBvcFsxXSkpLmRvbmUpIHJldHVybiB0O1xyXG4gICAgICAgICAgICBpZiAoeSA9IDAsIHQpIG9wID0gW29wWzBdICYgMiwgdC52YWx1ZV07XHJcbiAgICAgICAgICAgIHN3aXRjaCAob3BbMF0pIHtcclxuICAgICAgICAgICAgICAgIGNhc2UgMDogY2FzZSAxOiB0ID0gb3A7IGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSA0OiBfLmxhYmVsKys7IHJldHVybiB7IHZhbHVlOiBvcFsxXSwgZG9uZTogZmFsc2UgfTtcclxuICAgICAgICAgICAgICAgIGNhc2UgNTogXy5sYWJlbCsrOyB5ID0gb3BbMV07IG9wID0gWzBdOyBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgIGNhc2UgNzogb3AgPSBfLm9wcy5wb3AoKTsgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEodCA9IF8udHJ5cywgdCA9IHQubGVuZ3RoID4gMCAmJiB0W3QubGVuZ3RoIC0gMV0pICYmIChvcFswXSA9PT0gNiB8fCBvcFswXSA9PT0gMikpIHsgXyA9IDA7IGNvbnRpbnVlOyB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSAzICYmICghdCB8fCAob3BbMV0gPiB0WzBdICYmIG9wWzFdIDwgdFszXSkpKSB7IF8ubGFiZWwgPSBvcFsxXTsgYnJlYWs7IH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDYgJiYgXy5sYWJlbCA8IHRbMV0pIHsgXy5sYWJlbCA9IHRbMV07IHQgPSBvcDsgYnJlYWs7IH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAodCAmJiBfLmxhYmVsIDwgdFsyXSkgeyBfLmxhYmVsID0gdFsyXTsgXy5vcHMucHVzaChvcCk7IGJyZWFrOyB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRbMl0pIF8ub3BzLnBvcCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIF8udHJ5cy5wb3AoKTsgY29udGludWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgb3AgPSBib2R5LmNhbGwodGhpc0FyZywgXyk7XHJcbiAgICAgICAgfSBjYXRjaCAoZSkgeyBvcCA9IFs2LCBlXTsgeSA9IDA7IH0gZmluYWxseSB7IGYgPSB0ID0gMDsgfVxyXG4gICAgICAgIGlmIChvcFswXSAmIDUpIHRocm93IG9wWzFdOyByZXR1cm4geyB2YWx1ZTogb3BbMF0gPyBvcFsxXSA6IHZvaWQgMCwgZG9uZTogdHJ1ZSB9O1xyXG4gICAgfVxyXG59XHJcblxyXG5leHBvcnQgdmFyIF9fY3JlYXRlQmluZGluZyA9IE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcclxuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfSk7XHJcbn0pIDogKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XHJcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xyXG4gICAgb1trMl0gPSBtW2tdO1xyXG59KTtcclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2V4cG9ydFN0YXIobSwgbykge1xyXG4gICAgZm9yICh2YXIgcCBpbiBtKSBpZiAocCAhPT0gXCJkZWZhdWx0XCIgJiYgIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvLCBwKSkgX19jcmVhdGVCaW5kaW5nKG8sIG0sIHApO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX192YWx1ZXMobykge1xyXG4gICAgdmFyIHMgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgU3ltYm9sLml0ZXJhdG9yLCBtID0gcyAmJiBvW3NdLCBpID0gMDtcclxuICAgIGlmIChtKSByZXR1cm4gbS5jYWxsKG8pO1xyXG4gICAgaWYgKG8gJiYgdHlwZW9mIG8ubGVuZ3RoID09PSBcIm51bWJlclwiKSByZXR1cm4ge1xyXG4gICAgICAgIG5leHQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgaWYgKG8gJiYgaSA+PSBvLmxlbmd0aCkgbyA9IHZvaWQgMDtcclxuICAgICAgICAgICAgcmV0dXJuIHsgdmFsdWU6IG8gJiYgb1tpKytdLCBkb25lOiAhbyB9O1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKHMgPyBcIk9iamVjdCBpcyBub3QgaXRlcmFibGUuXCIgOiBcIlN5bWJvbC5pdGVyYXRvciBpcyBub3QgZGVmaW5lZC5cIik7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX3JlYWQobywgbikge1xyXG4gICAgdmFyIG0gPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb1tTeW1ib2wuaXRlcmF0b3JdO1xyXG4gICAgaWYgKCFtKSByZXR1cm4gbztcclxuICAgIHZhciBpID0gbS5jYWxsKG8pLCByLCBhciA9IFtdLCBlO1xyXG4gICAgdHJ5IHtcclxuICAgICAgICB3aGlsZSAoKG4gPT09IHZvaWQgMCB8fCBuLS0gPiAwKSAmJiAhKHIgPSBpLm5leHQoKSkuZG9uZSkgYXIucHVzaChyLnZhbHVlKTtcclxuICAgIH1cclxuICAgIGNhdGNoIChlcnJvcikgeyBlID0geyBlcnJvcjogZXJyb3IgfTsgfVxyXG4gICAgZmluYWxseSB7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgaWYgKHIgJiYgIXIuZG9uZSAmJiAobSA9IGlbXCJyZXR1cm5cIl0pKSBtLmNhbGwoaSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZpbmFsbHkgeyBpZiAoZSkgdGhyb3cgZS5lcnJvcjsgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIGFyO1xyXG59XHJcblxyXG4vKiogQGRlcHJlY2F0ZWQgKi9cclxuZXhwb3J0IGZ1bmN0aW9uIF9fc3ByZWFkKCkge1xyXG4gICAgZm9yICh2YXIgYXIgPSBbXSwgaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspXHJcbiAgICAgICAgYXIgPSBhci5jb25jYXQoX19yZWFkKGFyZ3VtZW50c1tpXSkpO1xyXG4gICAgcmV0dXJuIGFyO1xyXG59XHJcblxyXG4vKiogQGRlcHJlY2F0ZWQgKi9cclxuZXhwb3J0IGZ1bmN0aW9uIF9fc3ByZWFkQXJyYXlzKCkge1xyXG4gICAgZm9yICh2YXIgcyA9IDAsIGkgPSAwLCBpbCA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBpbDsgaSsrKSBzICs9IGFyZ3VtZW50c1tpXS5sZW5ndGg7XHJcbiAgICBmb3IgKHZhciByID0gQXJyYXkocyksIGsgPSAwLCBpID0gMDsgaSA8IGlsOyBpKyspXHJcbiAgICAgICAgZm9yICh2YXIgYSA9IGFyZ3VtZW50c1tpXSwgaiA9IDAsIGpsID0gYS5sZW5ndGg7IGogPCBqbDsgaisrLCBrKyspXHJcbiAgICAgICAgICAgIHJba10gPSBhW2pdO1xyXG4gICAgcmV0dXJuIHI7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX3NwcmVhZEFycmF5KHRvLCBmcm9tLCBwYWNrKSB7XHJcbiAgICBpZiAocGFjayB8fCBhcmd1bWVudHMubGVuZ3RoID09PSAyKSBmb3IgKHZhciBpID0gMCwgbCA9IGZyb20ubGVuZ3RoLCBhcjsgaSA8IGw7IGkrKykge1xyXG4gICAgICAgIGlmIChhciB8fCAhKGkgaW4gZnJvbSkpIHtcclxuICAgICAgICAgICAgaWYgKCFhcikgYXIgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChmcm9tLCAwLCBpKTtcclxuICAgICAgICAgICAgYXJbaV0gPSBmcm9tW2ldO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiB0by5jb25jYXQoYXIgfHwgQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoZnJvbSkpO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19hd2FpdCh2KSB7XHJcbiAgICByZXR1cm4gdGhpcyBpbnN0YW5jZW9mIF9fYXdhaXQgPyAodGhpcy52ID0gdiwgdGhpcykgOiBuZXcgX19hd2FpdCh2KTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fYXN5bmNHZW5lcmF0b3IodGhpc0FyZywgX2FyZ3VtZW50cywgZ2VuZXJhdG9yKSB7XHJcbiAgICBpZiAoIVN5bWJvbC5hc3luY0l0ZXJhdG9yKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3ltYm9sLmFzeW5jSXRlcmF0b3IgaXMgbm90IGRlZmluZWQuXCIpO1xyXG4gICAgdmFyIGcgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSksIGksIHEgPSBbXTtcclxuICAgIHJldHVybiBpID0ge30sIHZlcmIoXCJuZXh0XCIpLCB2ZXJiKFwidGhyb3dcIiksIHZlcmIoXCJyZXR1cm5cIiksIGlbU3ltYm9sLmFzeW5jSXRlcmF0b3JdID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfSwgaTtcclxuICAgIGZ1bmN0aW9uIHZlcmIobikgeyBpZiAoZ1tuXSkgaVtuXSA9IGZ1bmN0aW9uICh2KSB7IHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAoYSwgYikgeyBxLnB1c2goW24sIHYsIGEsIGJdKSA+IDEgfHwgcmVzdW1lKG4sIHYpOyB9KTsgfTsgfVxyXG4gICAgZnVuY3Rpb24gcmVzdW1lKG4sIHYpIHsgdHJ5IHsgc3RlcChnW25dKHYpKTsgfSBjYXRjaCAoZSkgeyBzZXR0bGUocVswXVszXSwgZSk7IH0gfVxyXG4gICAgZnVuY3Rpb24gc3RlcChyKSB7IHIudmFsdWUgaW5zdGFuY2VvZiBfX2F3YWl0ID8gUHJvbWlzZS5yZXNvbHZlKHIudmFsdWUudikudGhlbihmdWxmaWxsLCByZWplY3QpIDogc2V0dGxlKHFbMF1bMl0sIHIpOyB9XHJcbiAgICBmdW5jdGlvbiBmdWxmaWxsKHZhbHVlKSB7IHJlc3VtZShcIm5leHRcIiwgdmFsdWUpOyB9XHJcbiAgICBmdW5jdGlvbiByZWplY3QodmFsdWUpIHsgcmVzdW1lKFwidGhyb3dcIiwgdmFsdWUpOyB9XHJcbiAgICBmdW5jdGlvbiBzZXR0bGUoZiwgdikgeyBpZiAoZih2KSwgcS5zaGlmdCgpLCBxLmxlbmd0aCkgcmVzdW1lKHFbMF1bMF0sIHFbMF1bMV0pOyB9XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2FzeW5jRGVsZWdhdG9yKG8pIHtcclxuICAgIHZhciBpLCBwO1xyXG4gICAgcmV0dXJuIGkgPSB7fSwgdmVyYihcIm5leHRcIiksIHZlcmIoXCJ0aHJvd1wiLCBmdW5jdGlvbiAoZSkgeyB0aHJvdyBlOyB9KSwgdmVyYihcInJldHVyblwiKSwgaVtTeW1ib2wuaXRlcmF0b3JdID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfSwgaTtcclxuICAgIGZ1bmN0aW9uIHZlcmIobiwgZikgeyBpW25dID0gb1tuXSA/IGZ1bmN0aW9uICh2KSB7IHJldHVybiAocCA9ICFwKSA/IHsgdmFsdWU6IF9fYXdhaXQob1tuXSh2KSksIGRvbmU6IG4gPT09IFwicmV0dXJuXCIgfSA6IGYgPyBmKHYpIDogdjsgfSA6IGY7IH1cclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fYXN5bmNWYWx1ZXMobykge1xyXG4gICAgaWYgKCFTeW1ib2wuYXN5bmNJdGVyYXRvcikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN5bWJvbC5hc3luY0l0ZXJhdG9yIGlzIG5vdCBkZWZpbmVkLlwiKTtcclxuICAgIHZhciBtID0gb1tTeW1ib2wuYXN5bmNJdGVyYXRvcl0sIGk7XHJcbiAgICByZXR1cm4gbSA/IG0uY2FsbChvKSA6IChvID0gdHlwZW9mIF9fdmFsdWVzID09PSBcImZ1bmN0aW9uXCIgPyBfX3ZhbHVlcyhvKSA6IG9bU3ltYm9sLml0ZXJhdG9yXSgpLCBpID0ge30sIHZlcmIoXCJuZXh0XCIpLCB2ZXJiKFwidGhyb3dcIiksIHZlcmIoXCJyZXR1cm5cIiksIGlbU3ltYm9sLmFzeW5jSXRlcmF0b3JdID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfSwgaSk7XHJcbiAgICBmdW5jdGlvbiB2ZXJiKG4pIHsgaVtuXSA9IG9bbl0gJiYgZnVuY3Rpb24gKHYpIHsgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHsgdiA9IG9bbl0odiksIHNldHRsZShyZXNvbHZlLCByZWplY3QsIHYuZG9uZSwgdi52YWx1ZSk7IH0pOyB9OyB9XHJcbiAgICBmdW5jdGlvbiBzZXR0bGUocmVzb2x2ZSwgcmVqZWN0LCBkLCB2KSB7IFByb21pc2UucmVzb2x2ZSh2KS50aGVuKGZ1bmN0aW9uKHYpIHsgcmVzb2x2ZSh7IHZhbHVlOiB2LCBkb25lOiBkIH0pOyB9LCByZWplY3QpOyB9XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX21ha2VUZW1wbGF0ZU9iamVjdChjb29rZWQsIHJhdykge1xyXG4gICAgaWYgKE9iamVjdC5kZWZpbmVQcm9wZXJ0eSkgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkoY29va2VkLCBcInJhd1wiLCB7IHZhbHVlOiByYXcgfSk7IH0gZWxzZSB7IGNvb2tlZC5yYXcgPSByYXc7IH1cclxuICAgIHJldHVybiBjb29rZWQ7XHJcbn07XHJcblxyXG52YXIgX19zZXRNb2R1bGVEZWZhdWx0ID0gT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCB2KSB7XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgXCJkZWZhdWx0XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgdmFsdWU6IHYgfSk7XHJcbn0pIDogZnVuY3Rpb24obywgdikge1xyXG4gICAgb1tcImRlZmF1bHRcIl0gPSB2O1xyXG59O1xyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9faW1wb3J0U3Rhcihtb2QpIHtcclxuICAgIGlmIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpIHJldHVybiBtb2Q7XHJcbiAgICB2YXIgcmVzdWx0ID0ge307XHJcbiAgICBpZiAobW9kICE9IG51bGwpIGZvciAodmFyIGsgaW4gbW9kKSBpZiAoayAhPT0gXCJkZWZhdWx0XCIgJiYgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1vZCwgaykpIF9fY3JlYXRlQmluZGluZyhyZXN1bHQsIG1vZCwgayk7XHJcbiAgICBfX3NldE1vZHVsZURlZmF1bHQocmVzdWx0LCBtb2QpO1xyXG4gICAgcmV0dXJuIHJlc3VsdDtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9faW1wb3J0RGVmYXVsdChtb2QpIHtcclxuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgZGVmYXVsdDogbW9kIH07XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHJlY2VpdmVyLCBzdGF0ZSwga2luZCwgZikge1xyXG4gICAgaWYgKGtpbmQgPT09IFwiYVwiICYmICFmKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiUHJpdmF0ZSBhY2Nlc3NvciB3YXMgZGVmaW5lZCB3aXRob3V0IGEgZ2V0dGVyXCIpO1xyXG4gICAgaWYgKHR5cGVvZiBzdGF0ZSA9PT0gXCJmdW5jdGlvblwiID8gcmVjZWl2ZXIgIT09IHN0YXRlIHx8ICFmIDogIXN0YXRlLmhhcyhyZWNlaXZlcikpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgcmVhZCBwcml2YXRlIG1lbWJlciBmcm9tIGFuIG9iamVjdCB3aG9zZSBjbGFzcyBkaWQgbm90IGRlY2xhcmUgaXRcIik7XHJcbiAgICByZXR1cm4ga2luZCA9PT0gXCJtXCIgPyBmIDoga2luZCA9PT0gXCJhXCIgPyBmLmNhbGwocmVjZWl2ZXIpIDogZiA/IGYudmFsdWUgOiBzdGF0ZS5nZXQocmVjZWl2ZXIpO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19jbGFzc1ByaXZhdGVGaWVsZFNldChyZWNlaXZlciwgc3RhdGUsIHZhbHVlLCBraW5kLCBmKSB7XHJcbiAgICBpZiAoa2luZCA9PT0gXCJtXCIpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJQcml2YXRlIG1ldGhvZCBpcyBub3Qgd3JpdGFibGVcIik7XHJcbiAgICBpZiAoa2luZCA9PT0gXCJhXCIgJiYgIWYpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJQcml2YXRlIGFjY2Vzc29yIHdhcyBkZWZpbmVkIHdpdGhvdXQgYSBzZXR0ZXJcIik7XHJcbiAgICBpZiAodHlwZW9mIHN0YXRlID09PSBcImZ1bmN0aW9uXCIgPyByZWNlaXZlciAhPT0gc3RhdGUgfHwgIWYgOiAhc3RhdGUuaGFzKHJlY2VpdmVyKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCB3cml0ZSBwcml2YXRlIG1lbWJlciB0byBhbiBvYmplY3Qgd2hvc2UgY2xhc3MgZGlkIG5vdCBkZWNsYXJlIGl0XCIpO1xyXG4gICAgcmV0dXJuIChraW5kID09PSBcImFcIiA/IGYuY2FsbChyZWNlaXZlciwgdmFsdWUpIDogZiA/IGYudmFsdWUgPSB2YWx1ZSA6IHN0YXRlLnNldChyZWNlaXZlciwgdmFsdWUpKSwgdmFsdWU7XHJcbn1cclxuIiwiLypcbiAqIEZpbGVuYW1lOiBtdWx0aS1jb2x1bW4tbWFya2Rvd24vc3JjL3JlZ2lvblNldHRpbmdzLnRzXG4gKiBDcmVhdGVkIERhdGU6IFR1ZXNkYXksIEZlYnJ1YXJ5IDFzdCAyMDIyLCAxMjoyMzo1MyBwbVxuICogQXV0aG9yOiBDYW1lcm9uIFJvYmluc29uXG4gKiBcbiAqIENvcHlyaWdodCAoYykgMjAyMiBDYW1lcm9uIFJvYmluc29uXG4gKi9cblxuZXhwb3J0IGVudW0gQm9yZGVyT3B0aW9uIHtcbiAgICBlbmFibGVkLFxuICAgIG9uLFxuICAgIHRydWUsXG4gICAgZGlzYWJsZWQsXG4gICAgb2ZmLFxuICAgIGZhbHNlXG59XG5cbmV4cG9ydCBlbnVtIFNoYWRvd09wdGlvbiB7XG4gICAgZW5hYmxlZCxcbiAgICBvbixcbiAgICB0cnVlLFxuICAgIGRpc2FibGVkLFxuICAgIG9mZixcbiAgICBmYWxzZVxufVxuXG5leHBvcnQgZW51bSBDb2x1bW5MYXlvdXQgeyBcbiAgICBzdGFuZGFyZCxcbiAgICBsZWZ0LFxuICAgIGZpcnN0LFxuICAgIGNlbnRlcixcbiAgICBtaWRkbGUsXG4gICAgc2Vjb25kLFxuICAgIHJpZ2h0LFxuICAgIHRoaXJkLFxuICAgIGxhc3Rcbn07XG5cbmV4cG9ydCB0eXBlIE11bHRpQ29sdW1uU2V0dGluZ3MgPSB7XG4gICAgbnVtYmVyT2ZDb2x1bW5zOiBudW1iZXIsXG4gICAgY29sdW1uTGF5b3V0OiBDb2x1bW5MYXlvdXQsXG4gICAgZHJhd0JvcmRlcjogYm9vbGVhbixcbiAgICBkcmF3U2hhZG93OiBib29sZWFuXG59IiwiLypcbiAqIEZpbGU6IG11bHRpLWNvbHVtbi1tYXJrZG93bi9zcmMvTXVsdGlDb2x1bW5QYXJzZXIudHNcbiAqIENyZWF0ZWQgRGF0ZTogU2F0dXJkYXksIEphbnVhcnkgMjJuZCAyMDIyLCA2OjAyOjQ2IHBtXG4gKiBBdXRob3I6IENhbWVyb24gUm9iaW5zb25cbiAqIFxuICogQ29weXJpZ2h0IChjKSAyMDIyIENhbWVyb24gUm9iaW5zb25cbiAqL1xuXG5pbXBvcnQgeyBNdWx0aUNvbHVtblNldHRpbmdzLCBDb2x1bW5MYXlvdXQsIEJvcmRlck9wdGlvbiwgU2hhZG93T3B0aW9uIH0gZnJvbSBcIi4uL3JlZ2lvblNldHRpbmdzXCI7XG5cbmNvbnN0IFNUQVJUX1JFR0VYX1NUUlMgPSBbXCI9PT0gKnN0YXJ0LW11bHRpLWNvbHVtbig6P1thLXpBLVowLTktX1xcXFxzXSopP1wiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBcIj09PSAqbXVsdGktY29sdW1uLXN0YXJ0KDo/W2EtekEtWjAtOS1fXFxcXHNdKik/XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIFwiYGBgbXVsdGktY29sdW1uLXN0YXJ0XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIFwiYGBgc3RhcnQtbXVsdGktY29sdW1uXCJdXG5jb25zdCBTVEFSVF9SRUdFWF9BUlI6IFJlZ0V4cFtdID0gW107XG5mb3IobGV0IGkgPSAwOyBpIDwgU1RBUlRfUkVHRVhfU1RSUy5sZW5ndGg7IGkrKykge1xuICAgIFNUQVJUX1JFR0VYX0FSUi5wdXNoKG5ldyBSZWdFeHAoU1RBUlRfUkVHRVhfU1RSU1tpXSkpO1xufVxuXG5jb25zdCBTVEFSVF9SRUdFWF9TVFJTX1dIT0xFX0xJTkUgPSBbXCJePT09ICpzdGFydC1tdWx0aS1jb2x1bW4oOj9bYS16QS1aMC05LV9cXFxcc10qKT8kXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJePT09ICptdWx0aS1jb2x1bW4tc3RhcnQoOj9bYS16QS1aMC05LV9cXFxcc10qKT8kXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJeYGBgbXVsdGktY29sdW1uLXN0YXJ0JFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiXmBgYHN0YXJ0LW11bHRpLWNvbHVtbiRcIl1cbmNvbnN0IFNUQVJUX1JFR0VYX0FSUl9XSE9MRV9MSU5FOiBSZWdFeHBbXSA9IFtdO1xuZm9yKGxldCBpID0gMDsgaSA8IFNUQVJUX1JFR0VYX1NUUlNfV0hPTEVfTElORS5sZW5ndGg7IGkrKykge1xuICAgIFNUQVJUX1JFR0VYX0FSUl9XSE9MRV9MSU5FLnB1c2gobmV3IFJlZ0V4cChTVEFSVF9SRUdFWF9TVFJTX1dIT0xFX0xJTkVbaV0pKTtcbn1cblxuXG5mdW5jdGlvbiBmaW5kU3RhcnRUYWcodGV4dDogc3RyaW5nKTogeyBmb3VuZDogYm9vbGVhbiwgc3RhcnRQb3NpdGlvbjogbnVtYmVyIH0ge1xuXG4gICAgbGV0IGZvdW5kID0gZmFsc2U7XG4gICAgbGV0IHN0YXJ0UG9zaXRpb24gPSAtMTtcbiAgICBmb3IobGV0IGkgPSAwOyBpPCBTVEFSVF9SRUdFWF9BUlIubGVuZ3RoOyBpKyspIHtcblxuICAgICAgICBpZihTVEFSVF9SRUdFWF9BUlJbaV0udGVzdCh0ZXh0KSkge1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAvLyBXZSBmb3VuZCBhIG1hdGNoIGJ1dCBpcyBpdCBhbiBhY3R1YWwgbWF0Y2ggb3IgYSBmYWxzZSBwb3NpdGl2ZS5cbiAgICAgICAgICAgIHN0YXJ0UG9zaXRpb24gPSB0ZXh0LnNlYXJjaChTVEFSVF9SRUdFWF9TVFJTW2ldKVxuXG4gICAgICAgICAgICAvLyBUYWtlIHRoZSB0ZXh0IGFuZCBnZXQgdGhlIGxpbmUgd2UgZm91bmQuXG4gICAgICAgICAgICBsZXQgbGluZSA9IFwiXCJcbiAgICAgICAgICAgIGlmKHN0YXJ0UG9zaXRpb24gPiAwKSB7XG5cbiAgICAgICAgICAgICAgICAvLyBJZiB3ZSBhcmVudCBhdCB0aGUgdmVyeSBiZWdpbmluZyBvZiB0aGUgZmlsZSB3ZSBzdGVwIGJhY2tcbiAgICAgICAgICAgICAgICAvLyBvbmUgY2hhcmFjdGVyIHRvIHNlZSBpZiB3ZSBmaW5kIGEgbmV3bGluZSBiZWZvcmUgdGhpcyBsaW5lLlxuICAgICAgICAgICAgICAgIGxldCBsaW5lcyA9IHRleHQuc2xpY2Uoc3RhcnRQb3NpdGlvbiAtIDEpLnNwbGl0KFwiXFxuXCIpXG5cbiAgICAgICAgICAgICAgICAvLyBpZiB0aGUgbGFzdCBjaGFyIGJlZm9yZSBvdXIgbWF0Y2ggaXMgYSBuZXdsaW5lIHRoZW4gd2Ugd2lsbFxuICAgICAgICAgICAgICAgIC8vIGVuZCB1cCB3aXRoIGFuIGVtcHR5IHN0cmluZyBpbiBpbmRleCAwLlxuICAgICAgICAgICAgICAgIGlmKGxpbmVzWzBdID09PSBcIlwiICYmIGxpbmVzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgbGluZSA9IGxpbmVzWzFdXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbGluZSA9IHRleHQuc2xpY2Uoc3RhcnRQb3NpdGlvbikuc3BsaXQoXCJcXG5cIilbMF1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gbm93IHdlIHJlY2hlY2sgdGhlIHJlZ2V4IHRvIG1ha2Ugc3VyZSB0aGUgZm91bmQgbGluZSBpcyBcbiAgICAgICAgICAgIC8vIGEgdHJ1ZSBzdGFydCB0YWcuXG4gICAgICAgICAgICBpZihTVEFSVF9SRUdFWF9BUlJfV0hPTEVfTElORVtpXS50ZXN0KGxpbmUpKSB7XG4gICAgICAgICAgICAgICAgZm91bmQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHsgZm91bmQsIHN0YXJ0UG9zaXRpb24gfTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBjb250YWluc1N0YXJ0VGFnKHRleHQ6IHN0cmluZyk6IGJvb2xlYW4ge1xuICAgIHJldHVybiBmaW5kU3RhcnRUYWcodGV4dCkuZm91bmRcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzU3RhcnRUYWdXaXRoSUQodGV4dDogc3RyaW5nKToge2lzU3RhcnRUYWc6IGJvb2xlYW4sIGhhc0tleTogYm9vbGVhbn0ge1xuXG4gICAgbGV0IHN0YXJ0VGFnRGF0YSA9IGZpbmRTdGFydFRhZyh0ZXh0KTtcbiAgICBpZihzdGFydFRhZ0RhdGEuZm91bmQgPT09IHRydWUpIHtcblxuICAgICAgICBsZXQga2V5ID0gZ2V0U3RhcnRUYWdLZXkodGV4dClcbiAgICAgICAgaWYoa2V5ID09PSBudWxsIHx8IGtleSA9PT0gXCJcIikge1xuICAgICAgICAgICAgcmV0dXJuIHtpc1N0YXJ0VGFnOiB0cnVlLCBoYXNLZXk6IGZhbHNlfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge2lzU3RhcnRUYWc6IHRydWUsIGhhc0tleTogdHJ1ZX07XG4gICAgfVxuXG4gICAgcmV0dXJuIHtpc1N0YXJ0VGFnOiBmYWxzZSwgaGFzS2V5OiBmYWxzZX07XG59XG5cbmNvbnN0IEVORF9SRUdFWF9TVFJTID0gW1wiPT09ICplbmQtbXVsdGktY29sdW1uXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBcIj09PSAqbXVsdGktY29sdW1uLWVuZFwiXVxuY29uc3QgRU5EX1JFR0VYX0FSUjogUmVnRXhwW10gPSBbXTtcbmZvcihsZXQgaSA9IDA7IGkgPCBFTkRfUkVHRVhfU1RSUy5sZW5ndGg7IGkrKykge1xuICAgIEVORF9SRUdFWF9BUlIucHVzaChuZXcgUmVnRXhwKEVORF9SRUdFWF9TVFJTW2ldKSk7XG59XG5mdW5jdGlvbiBmaW5kRW5kVGFnKHRleHQ6IHN0cmluZyk6IHsgZm91bmQ6IGJvb2xlYW4sIHN0YXJ0UG9zaXRpb246IG51bWJlciB9IHtcblxuICAgIGxldCBmb3VuZCA9IGZhbHNlO1xuICAgIGxldCBzdGFydFBvc2l0aW9uID0gLTE7XG4gICAgZm9yKGxldCBpID0gMDsgaTwgRU5EX1JFR0VYX0FSUi5sZW5ndGg7IGkrKykge1xuXG4gICAgICAgIGlmKEVORF9SRUdFWF9BUlJbaV0udGVzdCh0ZXh0KSkge1xuICAgICAgICAgICAgZm91bmQgPSB0cnVlO1xuICAgICAgICAgICAgc3RhcnRQb3NpdGlvbiA9IHRleHQuc2VhcmNoKEVORF9SRUdFWF9TVFJTW2ldKVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4geyBmb3VuZCwgc3RhcnRQb3NpdGlvbiB9O1xufVxuZXhwb3J0IGZ1bmN0aW9uIGNvbnRhaW5zRW5kVGFnKHRleHQ6IHN0cmluZyk6IGJvb2xlYW4ge1xuICAgIHJldHVybiBmaW5kRW5kVGFnKHRleHQpLmZvdW5kXG59XG5cbmNvbnN0IENPTF9SRUdFWF9TVFJTOiBzdHJpbmdbXSA9IFtcIj09PSAqY29sdW1uLWVuZCAqPT09XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCI9PT0gKmVuZC1jb2x1bW4gKj09PVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiPT09ICpjb2x1bW4tYnJlYWsgKj09PVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiPT09ICpicmVhay1jb2x1bW4gKj09PVwiXTtcbmNvbnN0IENPTF9SRUdFWF9BUlI6IFJlZ0V4cFtdID0gW107XG5mb3IobGV0IGkgPSAwOyBpIDwgQ09MX1JFR0VYX1NUUlMubGVuZ3RoOyBpKyspIHtcbiAgICBDT0xfUkVHRVhfQVJSLnB1c2gobmV3IFJlZ0V4cChDT0xfUkVHRVhfU1RSU1tpXSkpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGNvbnRhaW5zQ29sRW5kVGFnKHRleHQ6IHN0cmluZyk6IGJvb2xlYW4ge1xuXG4gICAgbGV0IGZvdW5kID0gZmFsc2U7XG4gICAgZm9yKGxldCBpID0gMDsgaTwgQ09MX1JFR0VYX0FSUi5sZW5ndGg7IGkrKykge1xuXG4gICAgICAgIGlmKENPTF9SRUdFWF9BUlJbaV0udGVzdCh0ZXh0KSkge1xuICAgICAgICAgICAgZm91bmQgPSB0cnVlO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZm91bmQ7XG59XG5cbmNvbnN0IENPTF9TRVRUSU5HU19SRUdFWF9TVFJTID0gW1wiYGBgc2V0dGluZ3NcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiYGBgY29sdW1uLXNldHRpbmdzXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcImBgYG11bHRpLWNvbHVtbi1zZXR0aW5nc1wiXTtcbmNvbnN0IENPTF9TRVRUSU5HU19SRUdFWF9BUlI6IFJlZ0V4cFtdID0gW107XG5mb3IobGV0IGkgPSAwOyBpIDwgQ09MX1NFVFRJTkdTX1JFR0VYX1NUUlMubGVuZ3RoOyBpKyspIHtcbiAgICBDT0xfU0VUVElOR1NfUkVHRVhfQVJSLnB1c2gobmV3IFJlZ0V4cChDT0xfU0VUVElOR1NfUkVHRVhfU1RSU1tpXSkpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGNvbnRhaW5zQ29sU2V0dGluZ3NUYWcodGV4dDogc3RyaW5nKTogYm9vbGVhbiB7XG5cbiAgICBsZXQgZm91bmQgPSBmYWxzZTtcbiAgICBmb3IobGV0IGkgPSAwOyBpPCBDT0xfU0VUVElOR1NfUkVHRVhfQVJSLmxlbmd0aDsgaSsrKSB7XG5cbiAgICAgICAgaWYoQ09MX1NFVFRJTkdTX1JFR0VYX0FSUltpXS50ZXN0KHRleHQpKSB7XG4gICAgICAgICAgICBmb3VuZCA9IHRydWU7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBmb3VuZDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlQ29sdW1uU2V0dGluZ3Moc2V0dGluZ3NTdHI6IHN0cmluZyk6IE11bHRpQ29sdW1uU2V0dGluZ3Mge1xuXG4gICAgLy8gU2V0IHRoZSBtaW5pbXVtIG51bWJlciBvZiBjb2x1bW5kcyB0byAyLlxuICAgIGxldCBudW1iZXJPZkNvbHVtbnMgPSAyO1xuICAgIGxldCBjb2x1bW5MYXlvdXQ6IENvbHVtbkxheW91dCA9IENvbHVtbkxheW91dC5zdGFuZGFyZFxuICAgIGxldCBib3JkZXJEcmF3bjogYm9vbGVhbiA9IHRydWU7XG4gICAgbGV0IHNoYWRvd0RyYXduOiBib29sZWFuID0gdHJ1ZTtcblxuICAgIGxldCBzZXR0aW5nc0xpbmVzID0gc2V0dGluZ3NTdHIuc3BsaXQoXCJcXG5cIik7XG5cbiAgICBmb3IobGV0IGkgPSAwOyBpIDwgc2V0dGluZ3NMaW5lcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZihzZXR0aW5nc0xpbmVzW2ldLnRvTG93ZXJDYXNlKCkucmVwbGFjZSgvXFxzL2csIFwiXCIpLmNvbnRhaW5zKFwibnVtYmVyb2Zjb2x1bW5zOlwiKSkge1xuICAgICAgICAgICAgbGV0IHVzZXJEZWZOdW1iZXJPZkNvbHMgPSBwYXJzZUludChzZXR0aW5nc0xpbmVzW2ldLnNwbGl0KFwiOlwiKVsxXSlcblxuICAgICAgICAgICAgaWYoTnVtYmVyLmlzTmFOKHVzZXJEZWZOdW1iZXJPZkNvbHMpID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgIGlmKHVzZXJEZWZOdW1iZXJPZkNvbHMgPT09IDMpIHtcbiAgICAgICAgICAgICAgICAgICAgbnVtYmVyT2ZDb2x1bW5zID0gM1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmKHVzZXJEZWZOdW1iZXJPZkNvbHMgPT09IDIpIHtcbiAgICAgICAgICAgICAgICAgICAgbnVtYmVyT2ZDb2x1bW5zID0gMjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZm9yKGxldCBpID0gMDsgaSA8IHNldHRpbmdzTGluZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYoc2V0dGluZ3NMaW5lc1tpXS50b0xvd2VyQ2FzZSgpLnJlcGxhY2UoL1xccy9nLCBcIlwiKS5jb250YWlucyhcImxhcmdlc3Rjb2x1bW46XCIpKSB7XG5cbiAgICAgICAgICAgIGxldCBzZXR0aW5nID0gc2V0dGluZ3NMaW5lc1tpXS5zcGxpdChcIjpcIilbMV0udHJpbVN0YXJ0KCkudHJpbUVuZCgpLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICBsZXQgdXNlckRlZkxheW91dDogQ29sdW1uTGF5b3V0ID0gKDxhbnk+Q29sdW1uTGF5b3V0KVtzZXR0aW5nXVxuXG4gICAgICAgICAgICBpZih1c2VyRGVmTGF5b3V0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBjb2x1bW5MYXlvdXQgPSB1c2VyRGVmTGF5b3V0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgZm9yKGxldCBpID0gMDsgaSA8IHNldHRpbmdzTGluZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYoc2V0dGluZ3NMaW5lc1tpXS50b0xvd2VyQ2FzZSgpLnJlcGxhY2UoL1xccy9nLCBcIlwiKS5jb250YWlucyhcImJvcmRlcjpcIikpIHtcblxuICAgICAgICAgICAgbGV0IHNldHRpbmcgPSBzZXR0aW5nc0xpbmVzW2ldLnNwbGl0KFwiOlwiKVsxXS50cmltU3RhcnQoKS50cmltRW5kKCkudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgIGxldCBpc0JvcmRlckRyYXduOiBCb3JkZXJPcHRpb24gPSAoPGFueT5Cb3JkZXJPcHRpb24pW3NldHRpbmddXG5cbiAgICAgICAgICAgIGlmKGlzQm9yZGVyRHJhd24gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHN3aXRjaChpc0JvcmRlckRyYXduKXtcbiAgICAgICAgICAgICAgICAgICAgY2FzZShCb3JkZXJPcHRpb24uZGlzYWJsZWQpOlxuICAgICAgICAgICAgICAgICAgICBjYXNlKEJvcmRlck9wdGlvbi5vZmYpOlxuICAgICAgICAgICAgICAgICAgICBjYXNlKEJvcmRlck9wdGlvbi5mYWxzZSk6XG4gICAgICAgICAgICAgICAgICAgICAgICBib3JkZXJEcmF3biA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgZm9yKGxldCBpID0gMDsgaSA8IHNldHRpbmdzTGluZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYoc2V0dGluZ3NMaW5lc1tpXS50b0xvd2VyQ2FzZSgpLnJlcGxhY2UoL1xccy9nLCBcIlwiKS5jb250YWlucyhcInNoYWRvdzpcIikpIHtcblxuICAgICAgICAgICAgbGV0IHNldHRpbmcgPSBzZXR0aW5nc0xpbmVzW2ldLnNwbGl0KFwiOlwiKVsxXS50cmltU3RhcnQoKS50cmltRW5kKCkudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgIGxldCBpc1NoYWRvd0RyYXduOiBTaGFkb3dPcHRpb24gPSAoPGFueT5TaGFkb3dPcHRpb24pW3NldHRpbmddXG5cbiAgICAgICAgICAgIGlmKGlzU2hhZG93RHJhd24gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHN3aXRjaChpc1NoYWRvd0RyYXduKXtcbiAgICAgICAgICAgICAgICAgICAgY2FzZShTaGFkb3dPcHRpb24uZGlzYWJsZWQpOlxuICAgICAgICAgICAgICAgICAgICBjYXNlKFNoYWRvd09wdGlvbi5vZmYpOlxuICAgICAgICAgICAgICAgICAgICBjYXNlKFNoYWRvd09wdGlvbi5mYWxzZSk6XG4gICAgICAgICAgICAgICAgICAgICAgICBzaGFkb3dEcmF3biA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgbGV0IHNldHRpbmdzID0geyBudW1iZXJPZkNvbHVtbnMsIGNvbHVtbkxheW91dCwgZHJhd0JvcmRlcjogYm9yZGVyRHJhd24sIGRyYXdTaGFkb3c6IHNoYWRvd0RyYXduIH1cblxuICAgIHJldHVybiBzZXR0aW5ncztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNvdW50U3RhcnRUYWdzKHRleHQ6IHN0cmluZyk6IHsgbnVtYmVyT2ZUYWdzOiBudW1iZXIsIGtleXM6IHN0cmluZ1tdIH0ge1xuXG4gICAgbGV0IGtleXM6IHN0cmluZ1tdID0gW107XG4gICAgbGV0IHN0YXJ0VGFnRGF0YSA9IGZpbmRTdGFydFRhZyh0ZXh0KTtcbiAgICB3aGlsZShzdGFydFRhZ0RhdGEuZm91bmQpIHtcbiAgICAgICAgXG4gICAgICAgIC8vIFNsaWNlIG9mZiBldmVyeXRoaW5nIGJlZm9yZSB0aGUgdGFnXG4gICAgICAgIHRleHQgPSB0ZXh0LnNsaWNlKHN0YXJ0VGFnRGF0YS5zdGFydFBvc2l0aW9uKTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogR2V0IGp1c3QgdGhlIHN0YXJ0IHRhZyBsaW5lIGFuZCB0aGVuIHNldCB0ZXh0IHRvIGV2ZXJ5dGhpbmcganVzdFxuICAgICAgICAgKiBhZnRlciB0aGUgc3RhcnQgdGFnLlxuICAgICAgICAgKi9cbiAgICAgICAgbGV0IHRhZyA9IHRleHQuc3BsaXQoXCJcXG5cIilbMF07XG4gICAgICAgIHRleHQgPSB0ZXh0LnNsaWNlKDEpOyAvLyBUaGlzIG1vdmVzIHRoZSB0ZXh0IDEgY2hhcmFjdGVyIHNvIHdlIGRvbnQgbWF0Y2ggdGhlIHNhbWUgdGFnLlxuXG4gICAgICAgIC8vIFBhcnNlIG91dCB0aGUga2V5IGFuZCBhcHBlbmQgdG8gdGhlIGxpc3QuXG4gICAgICAgIGxldCBrZXkgPSBnZXRTdGFydFRhZ0tleSh0YWcpO1xuICAgICAgICBpZihrZXkgPT09IG51bGwpIHtcbiAgICAgICAgICAgIGtleSA9IFwiXCJcbiAgICAgICAgfVxuICAgICAgICBrZXlzLnB1c2goa2V5KTtcblxuICAgICAgICAvLyBTZWFyY2ggYWdhaW4gZm9yIGFub3RoZXIgdGFnIGJlZm9yZSBsb29waW5nLlxuICAgICAgICBzdGFydFRhZ0RhdGEgPSBmaW5kU3RhcnRUYWcodGV4dCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHsgbnVtYmVyT2ZUYWdzOiBrZXlzLmxlbmd0aCwga2V5cyB9O1xufVxuXG4vKipcbiAqIFRoaXMgZnVuY3Rpb24gd2lsbCBmaWx0ZXIgYSBzZXQgb2Ygc3RyaW5ncywgcmV0dXJuaW5nIGFsbCBpdGVtcyBzdGFydGluZ1xuICogZnJvbSB0aGUgY2xvc2VzdCBvcGVuIHN0YXJ0IHRhZyB0aHJvdWdoIHRoZSBsYXN0IGl0ZW0gaW4gdGhlIHNldC4gXG4gKiBcbiAqIFRoZSBmdW5jdGlvbiBmaWx0ZXJzIG91dCBhbGwgZW5kIHRhZ3MgdG8gbWFrZSBzdXJlIHRoYXQgdGhlIHN0YXJ0IHRhZyB3ZSBcbiAqIGZpbmQgaXMgdGhlIHByb3BlciBzdGFydCB0YWcgZm9yIHRoZSBsaXN0IHNlbnQuIFxuICogQHBhcmFtIGxpbmVzQWJvdmVBcnJheSBcbiAqIEByZXR1cm5zIFxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0U3RhcnRCbG9ja0Fib3ZlTGluZShsaW5lc0Fib3ZlQXJyYXk6IHN0cmluZ1tdKTogeyBzdGFydEJsb2NrS2V5OiBzdHJpbmcsIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaW5lc0Fib3ZlQXJyYXk6IHN0cmluZ1tdIH0gfCBudWxsIHtcblxuICAgIC8vIFJlZHVjZSB0aGUgYXJyYXkgZG93biBpbnRvIGEgc2luZ2xlIHN0cmluZyBzbyB0aGF0IHdlIGNhblxuICAgIC8vIGVhc2lseSBSZWdFeCBvdmVyIHRoZSBzdHJpbmcgYW5kIGZpbmQgdGhlIGluZGljaWVzIHdlJ3JlIGxvb2tpbmcgZm9yLlxuICAgIGxldCBsaW5lc0Fib3ZlU3RyID0gbGluZXNBYm92ZUFycmF5LnJlZHVjZSgocHJldiwgY3VycmVudCkgPT4ge1xuICAgICAgICByZXR1cm4gcHJldiArIFwiXFxuXCIgICsgY3VycmVudDtcbiAgICB9LCBcIlwiKTtcblxuICAgIC8qXG4gICAgICAgICogRmlyc3QgdGhpbmcgd2UgbmVlZCB0byBkbyBpcyBjaGVjayBpZiB0aGVyZSBhcmUgYW55IGVuZCB0YWdzIGluIHRoZVxuICAgICAgICAqIHNldCBvZiBzdHJpbmdzICh3aGljaCBsb2dpY2FsbHkgd291bGQgY2xvc2Ugc3RhcnQgdGFncyBhbmQgdGhlcmVmb3JlXG4gICAgICAgICogdGhlIHN0YXJ0IHRhZyBpdCBjbG9zZXMgaXMgbm90IHdoYXQgd2Ugd2FudCkuIElmIHRoZXJlIGFyZSB3ZSB3YW50IHRvIFxuICAgICAgICAqIHNsb3dseSBuYXJyb3cgZG93biBvdXIgc2V0IG9mIHN0cmluZ3MgdW50aWwgdGhlIGxhc3QgZW5kIHRhZyBpcyBcbiAgICAgICAgKiByZW1vdmVkLiBUaGlzIG1ha2VzIGl0IGVhc2llciB0byBmaW5kIHRoZSBjbG9zZXN0IG9wZW4gc3RhcnQgdGFnIFxuICAgICAgICAqIGluIHRoZSBkYXRhLlxuICAgICAgICAqL1xuICAgIGxldCBlbmRUYWdTZXJhY2hEYXRhID0gZmluZEVuZFRhZyhsaW5lc0Fib3ZlU3RyKTtcbiAgICB3aGlsZShlbmRUYWdTZXJhY2hEYXRhLmZvdW5kID09PSB0cnVlKSB7XG5cbiAgICAgICAgLy8gR2V0IHRoZSBpbmRleCBvZiB3aGVyZSB0aGUgZmlyc3QgcmVnZXggbWF0Y2ggaW4gdGhlXG4gICAgICAgIC8vIHN0cmluZyBpcy4gdGhlbiB3ZSBzbGljZSBmcm9tIDAgdG8gaW5kZXggb2ZmIG9mIHRoZSBzdHJpbmdcbiAgICAgICAgLy8gc3BsaXQgaXQgYnkgbmV3bGluZSwgY3V0IG9mZiB0aGUgZmlyc3QgbGluZSAod2hpY2ggYWN0dWFsbHlcbiAgICAgICAgLy8gY29udGFpbnMgdGhlIHJlZ2V4KSB0aGVuIHJlZHVjZSBiYWNrIGRvd24gdG8gYSBzaW5nbGUgc3RyaW5nLlxuICAgICAgICAvL1xuICAgICAgICAvLyBUT0RPOiBUaGlzIGNvdWxkIGJlIHNpbXBsaWZpZWQgaWYgd2UganVzdCBzbGljZSB0aGUgdGV4dCBhZnRlclxuICAgICAgICAvLyB0aGUgZW5kIHRhZyBpbnN0ZWFkIG9mIHRoZSBiZWdpbmluZy5cbiAgICAgICAgbGV0IGluZGV4T2ZSZWdleCA9IGVuZFRhZ1NlcmFjaERhdGEuc3RhcnRQb3NpdGlvbjtcbiAgICAgICAgbGluZXNBYm92ZUFycmF5ID0gbGluZXNBYm92ZVN0ci5zbGljZShpbmRleE9mUmVnZXgpLnNwbGl0KFwiXFxuXCIpLnNwbGljZSgxKVxuICAgICAgICBsaW5lc0Fib3ZlU3RyID0gbGluZXNBYm92ZUFycmF5LnJlZHVjZSgocHJldiwgY3VycmVudCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHByZXYgKyBcIlxcblwiICArIGN1cnJlbnQ7XG4gICAgICAgIH0sIFwiXCIpO1xuICAgICAgICBlbmRUYWdTZXJhY2hEYXRhID0gZmluZEVuZFRhZyhsaW5lc0Fib3ZlU3RyKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBOb3cgd2UgaGF2ZSB0aGUgc2V0IG9mIGxpbmVzIGFmdGVyIGFsbCBvdGhlciBlbmQgdGFncy4gV2Ugbm93XG4gICAgICogbmVlZCB0byBjaGVjayBpZiB0aGVyZSBpcyBzdGlsbCBhIHN0YXJ0IHRhZyBsZWZ0IGluIHRoZSBkYXRhLiBJZiBcbiAgICAgKiB0aGVyZSBpcyBubyBzdGFydCB0YWcgdGhlbiB3ZSB3YW50IHRvIHJldHVybiBhbiBlbXB0eSBhcnJheSBhbmQgZW1wdHkgXG4gICAgICoga2V5LlxuICAgICAqLyBcbiAgICBsZXQgc3RhcnRCbG9ja0tleSA9IFwiXCI7XG4gICAgbGV0IHN0YXJ0VGFnU2VhcmNoRGF0YSA9IGZpbmRTdGFydFRhZyhsaW5lc0Fib3ZlU3RyKTtcbiAgICBpZihzdGFydFRhZ1NlYXJjaERhdGEuZm91bmQgPT09IGZhbHNlKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBlbHNlIHtcblxuICAgICAgICAvKipcbiAgICAgICAgICogTm93IHdlIGtub3cgdGhlcmUgaXMgYXQgbGVhc3QgMSBzdGFydCBrZXkgbGVmdCwgaG93ZXZlciB0aGVyZVxuICAgICAgICAgKiBtYXkgYmUgbXVsdGlwbGUgc3RhcnQga2V5cyBpZiB0aGUgdXNlciBpcyBub3QgY2xvc2luZyB0aGVpclxuICAgICAgICAgKiBibG9ja3MuIFdlIGN1cnJlbnRseSBkb250IGFsbG93IHJlY3VzaXZlIHNwbGl0dGluZyBzbyB3ZSBcbiAgICAgICAgICogd2FudCB0byBnZXQgdGhlIGxhc3Qga2V5IGluIG91ciByZW1haW5pbmcgc2V0LiBTYW1lIGlkZWEgYXNcbiAgICAgICAgICogYWJvdmUuXG4gICAgICAgICAqL1xuICAgICAgICB3aGlsZShzdGFydFRhZ1NlYXJjaERhdGEuZm91bmQgPT09IHRydWUpIHtcblxuICAgICAgICAgICAgLy8gR2V0IHRoZSBpbmRleCBvZiB3aGVyZSB0aGUgZmlyc3QgcmVnZXggbWF0Y2ggaW4gdGhlXG4gICAgICAgICAgICAvLyBzdHJpbmcgaXMuIHRoZW4gd2Ugc2xpY2UgZnJvbSAwIHRvIGluZGV4IG9mZiBvZiB0aGUgc3RyaW5nXG4gICAgICAgICAgICAvLyBzcGxpdCBpdCBieSBuZXdsaW5lLCBjdXQgb2ZmIHRoZSBmaXJzdCBsaW5lICh3aGljaCBhY3R1YWxseVxuICAgICAgICAgICAgLy8gY29udGFpbnMgdGhlIHJlZ2V4KSB0aGVuIHJlZHVjZSBiYWNrIGRvd24gdG8gYSBzaW5nbGUgc3RyaW5nLlxuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIC8vIFRPRE86IFRoaXMgY291bGQgYmUgc2ltcGxpZmllZCBpZiB3ZSBqdXN0IHNsaWNlIHRoZSB0ZXh0IGFmdGVyXG4gICAgICAgICAgICAvLyB0aGUgZW5kIHRhZyBpbnN0ZWFkIG9mIHRoZSBiZWdpbmluZy5cbiAgICAgICAgICAgIGxldCBzdGFydEluZGV4ID0gc3RhcnRUYWdTZWFyY2hEYXRhLnN0YXJ0UG9zaXRpb247XG5cbiAgICAgICAgICAgIGxpbmVzQWJvdmVBcnJheSA9IGxpbmVzQWJvdmVTdHIuc2xpY2Uoc3RhcnRJbmRleCkuc3BsaXQoXCJcXG5cIilcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgbGV0IHN0YXJ0VGFnID0gbGluZXNBYm92ZUFycmF5WzBdO1xuICAgICAgICAgICAgbGV0IGtleSA9IGdldFN0YXJ0VGFnS2V5KHN0YXJ0VGFnKTtcbiAgICAgICAgICAgIGlmKGtleSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHN0YXJ0QmxvY2tLZXkgPSBrZXk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGxpbmVzQWJvdmVBcnJheSA9IGxpbmVzQWJvdmVBcnJheS5zcGxpY2UoMSlcbiAgICAgICAgICAgIGxpbmVzQWJvdmVTdHIgPSBsaW5lc0Fib3ZlQXJyYXkucmVkdWNlKChwcmV2LCBjdXJyZW50KSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHByZXYgKyBcIlxcblwiICArIGN1cnJlbnQ7XG4gICAgICAgICAgICB9LCBcIlwiKTtcblxuICAgICAgICAgICAgc3RhcnRUYWdTZWFyY2hEYXRhID0gZmluZFN0YXJ0VGFnKGxpbmVzQWJvdmVTdHIpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgaWYoc3RhcnRCbG9ja0tleSA9PT0gXCJcIikge1xuXG4gICAgICAgIGxldCBjb2RlQmxvY2tEYXRhID0gcGFyc2VDb2RlQmxvY2tTdGFydChsaW5lc0Fib3ZlQXJyYXkpXG4gICAgICAgIGlmKGNvZGVCbG9ja0RhdGEgIT09IG51bGwpIHtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgc3RhcnRCbG9ja0tleSA9IGNvZGVCbG9ja0RhdGEuaWQ7XG5cbiAgICAgICAgICAgIGlmKGNvZGVCbG9ja0RhdGEuaW5kZXggPiAwKSB7XG4gICAgICAgICAgICAgICAgbGluZXNBYm92ZUFycmF5ID0gbGluZXNBYm92ZUFycmF5LnNsaWNlKGNvZGVCbG9ja0RhdGEuaW5kZXggKyAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB7IHN0YXJ0QmxvY2tLZXksIGxpbmVzQWJvdmVBcnJheSB9O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0RW5kQmxvY2tCZWxvdyhsaW5lc0JlbG93OiBzdHJpbmdbXSk6IHN0cmluZ1tdIHtcblxuICAgIC8vIFJlZHVjZSB0aGUgYXJyYXkgZG93biBpbnRvIGEgc2luZ2xlIHN0cmluZyBzbyB0aGF0IHdlIGNhblxuICAgIC8vIGVhc2lseSBSZWdFeCBvdmVyIHRoZSBzdHJpbmcgYW5kIGZpbmQgdGhlIGluZGljaWVzIHdlJ3JlIGxvb2tpbmcgZm9yLlxuICAgIGxldCBsaW5lc0JlbG93U3RyID0gbGluZXNCZWxvdy5yZWR1Y2UoKHByZXYsIGN1cnJlbnQpID0+IHtcbiAgICAgICAgcmV0dXJuIHByZXYgKyBcIlxcblwiICArIGN1cnJlbnQ7XG4gICAgfSwgXCJcIik7XG4gICAgbGV0IGVuZFRhZ1NlcmFjaERhdGEgPSBmaW5kRW5kVGFnKGxpbmVzQmVsb3dTdHIpO1xuICAgIGxldCBzdGFydFRhZ1NlYXJjaERhdGEgPSBmaW5kU3RhcnRUYWcobGluZXNCZWxvd1N0cik7XG5cbiAgICBsZXQgc2xpY2VFbmRJbmRleCA9IC0xOyAvLyBJZiBuZWl0aGVyIHN0YXJ0IG9yIGVuZCBmb3VuZCB3ZSByZXR1cm4gdGhlIGVudGlyZSBhcnJheS5cbiAgICBpZihlbmRUYWdTZXJhY2hEYXRhLmZvdW5kID09PSB0cnVlICYmIHN0YXJ0VGFnU2VhcmNoRGF0YS5mb3VuZCA9PT0gZmFsc2UpIHtcblxuICAgICAgICBzbGljZUVuZEluZGV4ID0gZW5kVGFnU2VyYWNoRGF0YS5zdGFydFBvc2l0aW9uO1xuICAgIH1cbiAgICBlbHNlIGlmKGVuZFRhZ1NlcmFjaERhdGEuZm91bmQgPT09IGZhbHNlICYmIHN0YXJ0VGFnU2VhcmNoRGF0YS5mb3VuZCA9PT0gdHJ1ZSkge1xuXG4gICAgICAgIHNsaWNlRW5kSW5kZXggPSBzdGFydFRhZ1NlYXJjaERhdGEuc3RhcnRQb3NpdGlvbjtcbiAgICB9XG4gICAgZWxzZSBpZihlbmRUYWdTZXJhY2hEYXRhLmZvdW5kID09PSB0cnVlICYmIHN0YXJ0VGFnU2VhcmNoRGF0YS5mb3VuZCA9PT0gdHJ1ZSkge1xuXG4gICAgICAgIHNsaWNlRW5kSW5kZXggPSBlbmRUYWdTZXJhY2hEYXRhLnN0YXJ0UG9zaXRpb247XG4gICAgICAgIGlmKHN0YXJ0VGFnU2VhcmNoRGF0YS5zdGFydFBvc2l0aW9uIDwgZW5kVGFnU2VyYWNoRGF0YS5zdGFydFBvc2l0aW9uKSB7XG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogSWYgd2UgZm91bmQgYSBzdGFydCB0YWcgYmVmb3JlIGFuIGVuZCB0YWcgd2Ugd2FudCB0byB1c2UgdGhlIHN0YXJ0IHRhZ1xuICAgICAgICAgICAgICogb3VyIGN1cnJlbnQgYmxvY2sgaXMgbm90IHByb3Blcmx5IGVuZGVkIGFuZCB3ZSB1c2UgdGhlIG5leHQgc3RhcnQgdGFnIFxuICAgICAgICAgICAgICogYXMgb3VyIGxpbWl0XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHNsaWNlRW5kSW5kZXggPSBzdGFydFRhZ1NlYXJjaERhdGEuc3RhcnRQb3NpdGlvbjtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBsaW5lc0JlbG93LnNsaWNlKDAsIHNsaWNlRW5kSW5kZXgpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0U3RhcnRUYWdLZXkoc3RhcnRUYWc6IHN0cmluZyk6IHN0cmluZyB8IG51bGwge1xuXG4gICAgbGV0IGtleVNwbGl0ID0gc3RhcnRUYWcuc3BsaXQoXCI6XCIpO1xuICAgIGlmKGtleVNwbGl0Lmxlbmd0aCA+IDEpe1xuICAgICAgICByZXR1cm4ga2V5U3BsaXRbMV0ucmVwbGFjZShcIiBcIiwgXCJcIilcbiAgICB9XG5cbiAgICByZXR1cm4gbnVsbDtcbn1cblxuXG5jb25zdCBUQUJfSEVBREVSX0VORF9SRUdFWF9TVFIgPSBcIl5gYGAkXCI7XG5jb25zdCBUQUJfSEVBREVSX0VORF9SRUdFWDogUmVnRXhwID0gbmV3IFJlZ0V4cChUQUJfSEVBREVSX0VORF9SRUdFWF9TVFIpO1xuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlQ29kZUJsb2NrU3RhcnQoY29kZUJsb2NrTGluZXM6IHN0cmluZ1tdKTogeyBpZDogc3RyaW5nLCBpbmRleDogbnVtYmVyfSB8IG51bGwge1xuXG4gICAgbGV0IGlkID0gbnVsbDtcbiAgICBmb3IobGV0IGkgPSAwOyBpIDwgY29kZUJsb2NrTGluZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbGV0IGxpbmUgPSBjb2RlQmxvY2tMaW5lc1tpXTtcblxuICAgICAgICBpZihpZCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgbGV0IGtleSA9IGxpbmUuc3BsaXQoXCI6XCIpWzBdO1xuICAgICAgICAgICAgaWYoa2V5LnRvTG93ZXJDYXNlKCkgPT09IFwicmVnaW9uIGlkXCIpIHtcbiAgICAgICAgICAgICAgICBpZCA9IGxpbmUuc3BsaXQoXCI6XCIpWzFdLnRyaW0oKVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYoVEFCX0hFQURFUl9FTkRfUkVHRVgudGVzdChsaW5lKSkge1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgaWQ6IGlkLCBpbmRleDogaSB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgaWYoaWQgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4geyBpZDogaWQsIGluZGV4OiAtMSB9XG4gICAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gcGFyc2VDb2RlQmxvY2tTZXR0aW5ncyhjb2RlQmxvY2tMaW5lczogc3RyaW5nW10pOiBzdHJpbmcge1xuXG4gICAgbGV0IHNldHRpbmdzTGluZXMgPSBbXTtcbiAgICBmb3IobGV0IGkgPSAwOyBpIDwgY29kZUJsb2NrTGluZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbGV0IGxpbmUgPSBjb2RlQmxvY2tMaW5lc1tpXTtcblxuICAgICAgICBsZXQga2V5ID0gbGluZS5zcGxpdChcIjpcIilbMF07XG4gICAgICAgIGlmKGtleS50b0xvd2VyQ2FzZSgpICE9PSBcInJlZ2lvbiBpZFwiKSB7XG4gICAgICAgICAgICBzZXR0aW5nc0xpbmVzLnB1c2gobGluZSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gc2V0dGluZ3NMaW5lcy5qb2luKFwiXFxuXCIpO1xufSIsIi8qXG4gKiBGaWxlOiBtdWx0aS1jb2x1bW4tbWFya2Rvd24vc3JjL3V0aWxpdGllcy9jc3NEZWZpbml0aW9ucy50c1xuICogQ3JlYXRlZCBEYXRlOiBXZWRuZXNkYXksIEZlYnJ1YXJ5IDE2dGggMjAyMiwgMTE6MDk6MDYgYW1cbiAqIEF1dGhvcjogQ2FtZXJvbiBSb2JpbnNvblxuICogXG4gKiBDb3B5cmlnaHQgKGMpIDIwMjIgQ2FtZXJvbiBSb2JpbnNvblxuICovXG5cbmV4cG9ydCBlbnVtIE11bHRpQ29sdW1uTGF5b3V0Q1NTIHtcblxuICAgIFJlZ2lvblJvb3RDb250YWluZXJEaXYgPSBcIm11bHRpQ29sdW1uQ29udGFpbmVyXCIsXG4gICAgUmVnaW9uRXJyb3JDb250YWluZXJEaXYgPSBcIm11bHRpQ29sdW1uRXJyb3JDb250YWluZXJcIixcbiAgICBSZWdpb25Db250ZW50Q29udGFpbmVyRGl2ID0gXCJSZW5kZXJDb2xSZWdpb25cIixcbiAgICBSZWdpb25Db2x1bW5Db250YWluZXJEaXYgPSBcIm11bHRpQ29sdW1uUGFyZW50XCIsXG4gICAgUmVnaW9uQ29sdW1uQ29udGVudCA9IFwiY29sdW1uQ29udGVudFwiLFxuICAgIENvbHVtbkR1YWxFbGVtZW50Q29udGFpbmVyID0gXCJNdWx0aUNvbHVtbl9FbGVtZW50Q29udGFpbmVyXCIsXG4gICAgT3JpZ2luYWxFbGVtZW50VHlwZSA9IFwiTXVsdGlDb2x1bW5fT3JpZ2luYWxFbGVtZW50XCIsXG4gICAgQ2xvbmVkRWxlbWVudFR5cGUgPSBcIk11bHRpQ29sdW1uX0Nsb25lZEVsZW1lbnRcIlxufVxuXG5leHBvcnQgZW51bSBNdWx0aUNvbHVtblN0eWxlQ1NTIHtcblxuICAgIFJlZ2lvbkVycm9yTWVzc2FnZSA9IFwibXVsdGlDb2x1bW5FcnJvck1lc3NhZ2VcIixcbiAgICBSZWdpb25TZXR0aW5ncyA9IFwibXVsdGlDb2x1bW5TZXR0aW5nc1wiLFxuICAgIFJlZ2lvbkNvbnRlbnQgPSBcIm11bHRpQ29sdW1uQ29udGVudFwiLFxuICAgIFJlZ2lvbkVuZFRhZyA9IFwibXVsdGlDb2x1bW5SZWdpb25FbmRUYWdcIixcbiAgICBDb2x1bW5FbmRUYWcgPSBcIm11bHRpQ29sdW1uQnJlYWtcIixcbiAgICBSZWdpb25TaGFkb3cgPSBcIm11bHRpQ29sdW1uUGFyZW50U2hhZG93XCIsXG4gICAgQ29sdW1uU2hhZG93ID0gXCJjb2x1bW5TaGFkb3dcIixcbiAgICBDb2x1bW5Cb3JkZXIgPSBcImNvbHVtbkJvcmRlclwiLFxufSIsIi8qXG4gKiBGaWxlOiBtdWx0aS1jb2x1bW4tbWFya2Rvd24vc3JjL2RvbU1hbmFnZXIudHNcbiAqIENyZWF0ZWQgRGF0ZTogU2F0dXJkYXksIEphbnVhcnkgMzB0aCAyMDIyLCAzOjE2OjMyIHBtXG4gKiBBdXRob3I6IENhbWVyb24gUm9iaW5zb25cbiAqIFxuICogQ29weXJpZ2h0IChjKSAyMDIyIENhbWVyb24gUm9iaW5zb25cbiAqL1xuXG5pbXBvcnQgeyBwYXJzZUNvbHVtblNldHRpbmdzIH0gZnJvbSAnLi4vdXRpbGl0aWVzL3RleHRQYXJzZXInO1xuaW1wb3J0IHsgRE9NT2JqZWN0LCBET01PYmplY3RUYWcgfSBmcm9tICcuL2RvbU9iamVjdCc7XG5pbXBvcnQgeyBNdWx0aUNvbHVtblNldHRpbmdzLCBDb2x1bW5MYXlvdXQgfSBmcm9tIFwiLi4vcmVnaW9uU2V0dGluZ3NcIjtcbmltcG9ydCB7IE11bHRpQ29sdW1uTGF5b3V0Q1NTLCBNdWx0aUNvbHVtblN0eWxlQ1NTIH0gZnJvbSAnLi4vdXRpbGl0aWVzL2Nzc0RlZmluaXRpb25zJztcblxuZXhwb3J0IGNsYXNzIEdsb2JhbERPTU1hbmFnZXIge1xuICAgIG1hbmFnZXJzOiBNYXA8c3RyaW5nLCBGaWxlRE9NTWFuYWdlcj47XG5cbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5tYW5hZ2VycyA9IG5ldyBNYXAoKTtcbiAgICB9XG5cbiAgICBwdWJsaWMgcmVtb3ZlRmlsZU1hbmFnZXJDYWxsYmFjayhrZXk6IHN0cmluZykge1xuICAgICAgICBpZih0aGlzLm1hbmFnZXJzLmhhcyhrZXkpID09PSB0cnVlKSB7XG4gICAgICAgICAgICB0aGlzLm1hbmFnZXJzLmRlbGV0ZShrZXkpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcHVibGljIGdldEZpbGVNYW5hZ2VyKGtleTogc3RyaW5nKSB7XG5cbiAgICAgICAgbGV0IGZpbGVNYW5hZ2VyID0gbnVsbDtcbiAgICAgICAgaWYodGhpcy5tYW5hZ2Vycy5oYXMoa2V5KSA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgZmlsZU1hbmFnZXIgPSB0aGlzLm1hbmFnZXJzLmdldChrZXkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZmlsZU1hbmFnZXIgPSBjcmVhdGVGaWxlRE9NTWFuYWdlcih0aGlzLCBrZXkpO1xuICAgICAgICAgICAgdGhpcy5tYW5hZ2Vycy5zZXQoa2V5LCBmaWxlTWFuYWdlcik7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZmlsZU1hbmFnZXI7XG4gICAgfVxuXG4gICAgcHVibGljIGdldEFsbEZpbGVNYW5hZ2VycygpIHtcbiAgICAgICAgcmV0dXJuIEFycmF5LmZyb20odGhpcy5tYW5hZ2Vycy52YWx1ZXMoKSk7XG4gICAgfVxufVxuXG5leHBvcnQgdHlwZSBGaWxlRE9NTWFuYWdlciA9IHtcbiAgICByZWdpb25NYXA6IE1hcDxzdHJpbmcsIFJlZ2lvbkRPTU1hbmFnZXI+LFxuICAgIGhhc1N0YXJ0VGFnOiBib29sZWFuLFxuICAgIGNyZWF0ZVJlZ2lvbmFsTWFuYWdlcjogKHJlZ2lvbktleTogc3RyaW5nLCByb290RWxlbWVudDogSFRNTEVsZW1lbnQsIGVycm9yRWxlbWVudDogSFRNTEVsZW1lbnQsIHJlbmRlclJlZ2lvbkVsZW1lbnQ6IEhUTUxFbGVtZW50KSA9PiBSZWdpb25ET01NYW5hZ2VyXG4gICAgZ2V0UmVnaW9uYWxNYW5hZ2VyOiAocmVnaW9uS2V5OiBzdHJpbmcpID0+IFJlZ2lvbkRPTU1hbmFnZXIgfCBudWxsLFxuICAgIGdldEFsbFJlZ2lvbmFsTWFuYWdlcnM6ICgpID0+IFJlZ2lvbkRPTU1hbmFnZXJbXSxcbiAgICByZW1vdmVSZWdpb246IChyZWdpb25LZXk6IHN0cmluZykgPT4gdm9pZCxcbiAgICBzZXRIYXNTdGFydFRhZzogKCkgPT4gdm9pZCxcbiAgICBnZXRIYXNTdGFydFRhZzogKCkgPT4gYm9vbGVhbixcbiAgICBnZXROdW1iZXJPZlJlZ2lvbnM6ICgpID0+IG51bWJlcixcbiAgICBjaGVja0tleUV4aXN0czogKGNoZWNrS2V5OiBzdHJpbmcpID0+IGJvb2xlYW5cbn1cbmZ1bmN0aW9uIGNyZWF0ZUZpbGVET01NYW5hZ2VyKHBhcmVudE1hbmFnZXI6IEdsb2JhbERPTU1hbmFnZXIsIGZpbGVLZXk6IHN0cmluZyk6IEZpbGVET01NYW5hZ2VyIHtcbiAgICBcbiAgICBsZXQgcmVnaW9uTWFwOiBNYXA8c3RyaW5nLCBSZWdpb25ET01NYW5hZ2VyPiA9IG5ldyBNYXAoKTtcbiAgICBsZXQgaGFzU3RhcnRUYWc6IGJvb2xlYW4gPSBmYWxzZTtcblxuICAgIGZ1bmN0aW9uIHJlbW92ZVJlZ2lvbihyZWdpb25LZXk6IHN0cmluZyk6IHZvaWQge1xuXG4gICAgICAgIGxldCByZWdpb25NYW5hZ2VyID0gcmVnaW9uTWFwLmdldChyZWdpb25LZXkpO1xuICAgICAgICBpZihyZWdpb25NYW5hZ2VyKSB7XG4gICAgICAgICAgICByZWdpb25NYW5hZ2VyLmRpc3BsYXlPcmlnaW5hbEVsZW1lbnRzKCk7XG4gICAgICAgIH1cblxuICAgICAgICByZWdpb25NYXAuZGVsZXRlKHJlZ2lvbktleSk7XG4gICAgICAgIFxuICAgICAgICBpZihyZWdpb25NYXAuc2l6ZSA9PT0gMCkge1xuICAgICAgICAgICAgcGFyZW50TWFuYWdlci5yZW1vdmVGaWxlTWFuYWdlckNhbGxiYWNrKGZpbGVLZXkpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY3JlYXRlUmVnaW9uYWxNYW5hZ2VyKHJlZ2lvbktleTogc3RyaW5nLCByb290RWxlbWVudDogSFRNTEVsZW1lbnQsIGVycm9yRWxlbWVudDogSFRNTEVsZW1lbnQsIHJlbmRlclJlZ2lvbkVsZW1lbnQ6IEhUTUxFbGVtZW50KTogUmVnaW9uRE9NTWFuYWdlciB7XG5cbiAgICAgICAgLy9UT0RPOiBVc2UgdGhlIGVycm9yIGVsZW1lbnQgd2hlbmV2ZXIgdGhlcmUgaXMgYW4gZXJyb3IuXG5cbiAgICAgICAgbGV0IHJlZ29uYWxNYW5hZ2VyID0gY3JlYXRlUmVnaW9uYWxEb21NYW5hZ2VyKHRoaXMsIHJlZ2lvbktleSwgcm9vdEVsZW1lbnQsIHJlbmRlclJlZ2lvbkVsZW1lbnQpO1xuICAgICAgICByZWdpb25NYXAuc2V0KHJlZ2lvbktleSwgcmVnb25hbE1hbmFnZXIpO1xuICAgICAgICByZXR1cm4gcmVnb25hbE1hbmFnZXI7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0UmVnaW9uYWxNYW5hZ2VyKHJlZ2lvbktleTogc3RyaW5nKTogUmVnaW9uRE9NTWFuYWdlciB8IG51bGwge1xuXG4gICAgICAgIGxldCByZWdvbmFsTWFuYWdlciA9IG51bGw7XG4gICAgICAgIGlmKHJlZ2lvbk1hcC5oYXMocmVnaW9uS2V5KSA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgcmVnb25hbE1hbmFnZXIgPSByZWdpb25NYXAuZ2V0KHJlZ2lvbktleSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVnb25hbE1hbmFnZXI7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0QWxsUmVnaW9uYWxNYW5hZ2VycygpOiBSZWdpb25ET01NYW5hZ2VyW10ge1xuXG4gICAgICAgIHJldHVybiBBcnJheS5mcm9tKHJlZ2lvbk1hcC52YWx1ZXMoKSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2V0SGFzU3RhcnRUYWcoKSB7XG4gICAgICAgIGhhc1N0YXJ0VGFnID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRIYXNTdGFydFRhZygpIHtcbiAgICAgICAgcmV0dXJuIGhhc1N0YXJ0VGFnO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldE51bWJlck9mUmVnaW9ucygpIHtcbiAgICAgICAgcmV0dXJuIHJlZ2lvbk1hcC5zaXplXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY2hlY2tLZXlFeGlzdHMoY2hlY2tLZXk6IHN0cmluZykge1xuICAgICAgICByZXR1cm4gcmVnaW9uTWFwLmhhcyhjaGVja0tleSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHsgcmVnaW9uTWFwOiByZWdpb25NYXAsIFxuICAgICAgICBoYXNTdGFydFRhZzogaGFzU3RhcnRUYWcsICBcbiAgICAgICAgY3JlYXRlUmVnaW9uYWxNYW5hZ2VyOiBjcmVhdGVSZWdpb25hbE1hbmFnZXIsIFxuICAgICAgICBnZXRSZWdpb25hbE1hbmFnZXI6IGdldFJlZ2lvbmFsTWFuYWdlcixcbiAgICAgICAgZ2V0QWxsUmVnaW9uYWxNYW5hZ2VyczogZ2V0QWxsUmVnaW9uYWxNYW5hZ2VycyxcbiAgICAgICAgcmVtb3ZlUmVnaW9uOiByZW1vdmVSZWdpb24sIFxuICAgICAgICBzZXRIYXNTdGFydFRhZzogc2V0SGFzU3RhcnRUYWcsIFxuICAgICAgICBnZXRIYXNTdGFydFRhZzogZ2V0SGFzU3RhcnRUYWcsXG4gICAgICAgIGdldE51bWJlck9mUmVnaW9uczogZ2V0TnVtYmVyT2ZSZWdpb25zLFxuICAgICAgICBjaGVja0tleUV4aXN0czogY2hlY2tLZXlFeGlzdHNcbiAgICB9XG59XG5cbmV4cG9ydCB0eXBlIE11bHRpQ29sdW1uUmVuZGVyRGF0YSA9IHsgXG4gICAgcGFyZW50UmVuZGVyRWxlbWVudDogSFRNTEVsZW1lbnQsIFxuICAgIHBhcmVudFJlbmRlclNldHRpbmdzOiBNdWx0aUNvbHVtblNldHRpbmdzLFxuICAgIGRvbU9iamVjdHM6IERPTU9iamVjdFtdXG59XG5cbmV4cG9ydCBjbGFzcyBSZWdpb25ET01NYW5hZ2VyIHtcblxuICAgIGRvbUxpc3Q6IERPTU9iamVjdFtdID0gW11cbiAgICBwdWJsaWMgZG9tT2JqZWN0TWFwOiBNYXA8c3RyaW5nLCBET01PYmplY3Q+ID0gbmV3IE1hcCgpO1xuICAgIHJlZ2lvblBhcmVudDogSFRNTEVsZW1lbnQ7XG4gICAgcmVnaW9uS2V5OiBzdHJpbmc7XG4gICAgcm9vdEVsZW1lbnQ6IEhUTUxFbGVtZW50O1xuICAgIGZpbGVNYW5hZ2VyOiBGaWxlRE9NTWFuYWdlcjtcbiAgICByZWdpb25hbFNldHRpbmdzOiBNdWx0aUNvbHVtblNldHRpbmdzID0ge251bWJlck9mQ29sdW1uczogMiwgY29sdW1uTGF5b3V0OiBDb2x1bW5MYXlvdXQuc3RhbmRhcmQsIGRyYXdCb3JkZXI6IHRydWUsIGRyYXdTaGFkb3c6IHRydWV9O1xuXG4gICAgY29uc3RydWN0b3IoZmlsZU1hbmFnZXI6IEZpbGVET01NYW5hZ2VyLCByZWdpb25LZXk6IHN0cmluZywgcm9vdEVsZW1lbnQ6IEhUTUxFbGVtZW50LCByZWdpb25QYXJlbnQ6IEhUTUxFbGVtZW50KSB7XG4gICAgICAgIHRoaXMucmVnaW9uUGFyZW50ID0gcmVnaW9uUGFyZW50O1xuICAgICAgICB0aGlzLnJlZ2lvbktleSA9IHJlZ2lvbktleTtcbiAgICAgICAgdGhpcy5yb290RWxlbWVudCA9IHJvb3RFbGVtZW50O1xuICAgICAgICB0aGlzLmZpbGVNYW5hZ2VyID0gZmlsZU1hbmFnZXI7XG4gICAgfVxuXG4gICAgcHVibGljIGFkZE9iamVjdChzaWJsaW5nc0Fib3ZlOiBIVE1MRGl2RWxlbWVudCwgc2libGluZ3NCZWxvdzogSFRNTERpdkVsZW1lbnQsIG9iajogRE9NT2JqZWN0KTogbnVtYmVyIHtcblxuICAgICAgICBsZXQgcHJldk9iaiA9IHNpYmxpbmdzQWJvdmUuY2hpbGRyZW5bc2libGluZ3NBYm92ZS5jaGlsZHJlbi5sZW5ndGggLSAxXSBhcyBIVE1MRWxlbWVudDtcbiAgICAgICAgbGV0IG5leHRPYmogPSBzaWJsaW5nc0JlbG93LmNoaWxkcmVuWzBdIGFzIEhUTUxFbGVtZW50O1xuXG4gICAgICAgIGxldCBhZGRBdEluZGV4ID0gc2libGluZ3NBYm92ZS5jaGlsZHJlbi5sZW5ndGg7XG5cbiAgICAgICAgbGV0IHByZXZPYmpUZXh0ID0gXCJcIlxuICAgICAgICBpZihwcmV2T2JqICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgcHJldk9ialRleHQgPSBwcmV2T2JqLmlubmVyVGV4dDtcblxuICAgICAgICAgICAgZm9yKGxldCBpID0gdGhpcy5kb21MaXN0Lmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICAgICAgaWYodGhpcy5kb21MaXN0W2ldLm5vZGVLZXkgPT09IHByZXZPYmouaW5uZXJUZXh0KSB7XG4gICAgICAgICAgICAgICAgICAgIGFkZEF0SW5kZXggPSBpICsgMTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgbGV0IG5leHRFbEluZGV4ID0gYWRkQXRJbmRleDtcbiAgICAgICAgbGV0IG5leHRPYmpUZXh0ID0gXCJcIlxuICAgICAgICBpZihuZXh0T2JqICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgbGV0IGZvdW5kTmV4dCA9IGZhbHNlO1xuICAgICAgICAgICAgbmV4dE9ialRleHQgPSBuZXh0T2JqLmlubmVyVGV4dDtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgZm9yKGxldCBpID0gYWRkQXRJbmRleDsgaSA8IHRoaXMuZG9tTGlzdC5sZW5ndGg7IGkrKykge1xuXG4gICAgICAgICAgICAgICAgaWYodGhpcy5kb21MaXN0W2ldLm5vZGVLZXkgPT09IG5leHRPYmouaW5uZXJUZXh0LnRyaW0oKSkge1xuICAgIFxuICAgICAgICAgICAgICAgICAgICBuZXh0RWxJbmRleCA9IGk7XG4gICAgICAgICAgICAgICAgICAgIGZvdW5kTmV4dCA9IHRydWVcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gY29uc29sZS5sb2coXCIgUHJldjogXCIsIHNpYmxpbmdzQWJvdmUuY2hpbGRyZW5bc2libGluZ3NBYm92ZS5jaGlsZHJlbi5sZW5ndGggLSAxXSwgXCJBZGRpbmc6IFwiLCBvYmouZWxlbWVudCwgXCIgTmV4dDogXCIsIHNpYmxpbmdzQmVsb3cuY2hpbGRyZW5bMF0sIFwiT3ZlcndyaXRpbmc6XCIsIHRoaXMuZG9tTGlzdC5zbGljZShhZGRBdEluZGV4LCBuZXh0RWxJbmRleCkpO1xuXG4gICAgICAgIHRoaXMuZG9tTGlzdC5zcGxpY2UoYWRkQXRJbmRleCwgbmV4dEVsSW5kZXggLSBhZGRBdEluZGV4LCBvYmopO1xuICAgICAgICB0aGlzLmRvbU9iamVjdE1hcC5zZXQob2JqLlVJRCwgb2JqKTtcblxuICAgICAgICAvLyAvKipcbiAgICAgICAgLy8gICogTWFrZSBhIGNvcHkgb2YgdGhlIGxpc3QgdG8gbG9nLCBvbmx5IGJlY2F1c2VcbiAgICAgICAgLy8gICogY29uc29sZSBsb2cgdXBkYXRlcyBpdHMgcmVmZXJlbmNlcyB3aXRoIHVwZGF0ZXMgaW4gbWVtb3J5LlxuICAgICAgICAvLyAgKi9cbiAgICAgICAgLy8gbGV0IHggPSB0aGlzLmRvbUxpc3Quc2xpY2UoMCk7XG4gICAgICAgIC8vIGNvbnNvbGUubG9nKHgpO1xuXG4gICAgICAgIHJldHVybiBhZGRBdEluZGV4O1xuICAgIH1cblxuICAgIHB1YmxpYyByZW1vdmVPYmplY3Qob2JqZWN0VUlEOiBzdHJpbmcpOiB2b2lkIHtcblxuICAgICAgICAvLyAvKipcbiAgICAgICAgLy8gICogTWFrZSBhIGNvcHkgb2YgdGhlIGxpc3QgdG8gbG9nXG4gICAgICAgIC8vICAqL1xuICAgICAgICAvLyBsZXQgeCA9IGRvbUxpc3Quc2xpY2UoMCk7XG4gICAgICAgIC8vIGNvbnNvbGUubG9nKHgpO1xuXG4gICAgICAgIC8vIEdldCB0aGUgb2JqZWN0IGJ5IGtleSwgcmVtb3ZlIGl0IGZyb20gdGhlIG1hcCBhbmQgdGhlblxuICAgICAgICAvLyBmcm9tIHRoZSBsaXN0LlxuICAgICAgICBsZXQgb2JqID0gdGhpcy5kb21PYmplY3RNYXAuZ2V0KG9iamVjdFVJRCk7XG4gICAgICAgIHRoaXMuZG9tT2JqZWN0TWFwLmRlbGV0ZShvYmplY3RVSUQpO1xuICAgICAgICBcbiAgICAgICAgaWYob2JqID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmKHRoaXMuZG9tTGlzdC5jb250YWlucyhvYmopKSB7XG4gICAgICAgICAgICB0aGlzLmRvbUxpc3QucmVtb3ZlKG9iaik7XG4gICAgICAgIH1cblxuICAgICAgICBpZih0aGlzLmRvbUxpc3QubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICB0aGlzLmZpbGVNYW5hZ2VyLnJlbW92ZVJlZ2lvbih0aGlzLnJlZ2lvbktleSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyB4ID0gZG9tTGlzdC5zbGljZSgwKTtcbiAgICAgICAgLy8gY29uc29sZS5sb2coeCk7XG4gICAgfVxuXG4gICAgcHVibGljIHVwZGF0ZUVsZW1lbnRUYWcob2JqZWN0VUlEOiBzdHJpbmcsIG5ld1RhZzogRE9NT2JqZWN0VGFnKTogdm9pZCB7XG5cbiAgICAgICAgbGV0IG9iaiA9IHRoaXMuZG9tT2JqZWN0TWFwLmdldChvYmplY3RVSUQpO1xuICAgICAgICBsZXQgaW5kZXggPSB0aGlzLmRvbUxpc3QuaW5kZXhPZihvYmopO1xuICAgICAgICBpZihpbmRleCAhPT0gLTEpIHtcbiAgICAgICAgICAgIHRoaXMuZG9tTGlzdFtpbmRleF0udGFnID0gbmV3VGFnO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcHVibGljIHNldFJlZ2lvbmFsU2V0dGluZ3Moc2V0dGluZ3NUZXh0OiBzdHJpbmcpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5yZWdpb25hbFNldHRpbmdzID0gcGFyc2VDb2x1bW5TZXR0aW5ncyhzZXR0aW5nc1RleHQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gb2JqZWN0IGNvbnRhaW5pbmcgYWxsIG5lY2Vzc2FyeSBpbmZvcm1hdGlvbiBmb3IgdGhlIHJlZ2lvblxuICAgICAqIHRvIGJlIHJlbmRlcmVkIHRvIHRoZSBwcmV2aWV3IHBhbmUuXG4gICAgICogXG4gICAgICogQHJldHVybnMgYSBNdWx0aUNvbHVtblJlbmRlckRhdGEgb2JqZWN0IHdpdGggdGhlIHJvb3QgRE9NIGVsZW1lbnQsIHNldHRpbmdzIG9iamVjdCwgYW5kIFxuICAgICAqIGFsbCBjaGlsZCBvYmplY3RzIGluIHRoZSBvcmRlciB0aGV5IHNob3VsZCBiZSByZW5kZXJlZC5cbiAgICAgKi9cbiAgICBwdWJsaWMgZ2V0UmVnaW9uUmVuZGVyRGF0YSgpOiBNdWx0aUNvbHVtblJlbmRlckRhdGEge1xuXG4gICAgICAgIHJldHVybiB7IFxuICAgICAgICAgICAgcGFyZW50UmVuZGVyRWxlbWVudDogdGhpcy5yZWdpb25QYXJlbnQsIFxuICAgICAgICAgICAgcGFyZW50UmVuZGVyU2V0dGluZ3M6IHRoaXMucmVnaW9uYWxTZXR0aW5ncyxcbiAgICAgICAgICAgIGRvbU9iamVjdHM6IHRoaXMuZG9tTGlzdFxuICAgICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgZnVjdGlvbiBpcyBjYWxsZWQgd2hlbiBhIHN0YXJ0IHRhZyBpcyByZW1vdmVkIGZyb20gdmlldyBtZWFuaW5nXG4gICAgICogb3VyIHBhcmVudCBlbGVtZW50IHN0b3JpbmcgdGhlIG11bHRpLWNvbHVtbiByZWdpb24gaXMgcmVtb3ZlZC4gSXQgXG4gICAgICogcmVtb3ZlcyB0aGUgQ1NTIGNsYXNzIGZyb20gYWxsIG9mIHRoZSBlbGVtZW50cyBzbyB0aGV5IHdpbGwgYmVcbiAgICAgKiByZS1yZW5kZXJlZCBpbiB0aGUgcHJldmlldyB3aW5kb3cuXG4gICAgICovXG4gICAgcHVibGljIGRpc3BsYXlPcmlnaW5hbEVsZW1lbnRzKCkge1xuXG4gICAgICAgIFxuICAgICAgICBmb3IobGV0IGkgPSAwOyBpIDwgdGhpcy5kb21MaXN0Lmxlbmd0aDsgaSsrKSB7XG5cbiAgICAgICAgICAgIGlmKHRoaXMuZG9tTGlzdFtpXS5vcmlnaW5hbEVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmRvbUxpc3RbaV0ub3JpZ2luYWxFbGVtZW50LnJlbW92ZUNsYXNzZXMoW011bHRpQ29sdW1uU3R5bGVDU1MuUmVnaW9uRW5kVGFnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBNdWx0aUNvbHVtblN0eWxlQ1NTLkNvbHVtbkVuZFRhZyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgTXVsdGlDb2x1bW5TdHlsZUNTUy5SZWdpb25TZXR0aW5ncyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgTXVsdGlDb2x1bW5TdHlsZUNTUy5SZWdpb25Db250ZW50XSk7XG4gICAgICAgICAgICAgICAgaWYodGhpcy5kb21MaXN0W2ldLm9yaWdpbmFsRWxlbWVudC5wYXJlbnRFbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZG9tTGlzdFtpXS5vcmlnaW5hbEVsZW1lbnQucGFyZW50RWxlbWVudC5yZW1vdmVDaGlsZCh0aGlzLmRvbUxpc3RbaV0ub3JpZ2luYWxFbGVtZW50KVxuICAgICAgICAgICAgICAgIH0gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgcHVibGljIGdldFJvb3RSZWdpb25FbGVtZW50KCk6IEhUTUxFbGVtZW50IHtcbiAgICAgICAgcmV0dXJuIHRoaXMucm9vdEVsZW1lbnQ7XG4gICAgfVxuXG4gICAgcHVibGljIGdldElEKCk6IHN0cmluZyB7XG4gICAgICAgIHJldHVybiB0aGlzLnJlZ2lvbktleVxuICAgIH1cbn1cblxuZnVuY3Rpb24gY3JlYXRlUmVnaW9uYWxEb21NYW5hZ2VyKGZpbGVNYW5hZ2VyOiBGaWxlRE9NTWFuYWdlciwgcmVnaW9uS2V5OiBzdHJpbmcsIHJvb3RFbGVtZW50OiBIVE1MRWxlbWVudCwgcmVuZGVyUmVnaW9uRWxlbWVudDogSFRNTEVsZW1lbnQpOiBSZWdpb25ET01NYW5hZ2VyIHtcbiAgICByZXR1cm4gbmV3IFJlZ2lvbkRPTU1hbmFnZXIoZmlsZU1hbmFnZXIsIHJlZ2lvbktleSwgcm9vdEVsZW1lbnQsIHJlbmRlclJlZ2lvbkVsZW1lbnQpXG59IiwiLypcbiAqIEZpbGVuYW1lOiBtdWx0aS1jb2x1bW4tbWFya2Rvd24vc3JjL3V0aWxpdGllcy91dGlscy50c1xuICogQ3JlYXRlZCBEYXRlOiBUdWVzZGF5LCBKYW51YXJ5IDMwdGggMjAyMiwgNDowMjoxOSBwbVxuICogQXV0aG9yOiBDYW1lcm9uIFJvYmluc29uXG4gKiBcbiAqIENvcHlyaWdodCAoYykgMjAyMiBDYW1lcm9uIFJvYmluc29uXG4gKi9cblxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0VUlEKGxlbmd0aDogbnVtYmVyID0gMTApOiBzdHJpbmcge1xuXG4gICAgaWYobGVuZ3RoID4gMTApIHtcbiAgICAgICAgbGVuZ3RoID0gMTA7XG4gICAgfVxuICAgIGxldCBVSUQgPSBNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKDM2KS5zdWJzdHJpbmcoMik7XG4gICAgVUlEID0gVUlELnNsaWNlKDAsIGxlbmd0aCk7XG4gICAgXG4gICAgcmV0dXJuIFVJRDtcbn0iLCJleHBvcnQgZW51bSBFbGVtZW50UmVuZGVyVHlwZSB7XG4gICAgdW5kZWZpbmVkLFxuICAgIG5vcm1hbFJlbmRlcixcbiAgICBzcGVjaWFsUmVuZGVyXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRFbGVtZW50UmVuZGVyVHlwZShlbGVtZW50OiBIVE1MRWxlbWVudCk6IEVsZW1lbnRSZW5kZXJUeXBlIHtcblxuICAgIC8qKlxuICAgICAqIExvb2sgZm9yIHNwZWNpZmljIGtpbmRzIG9mIGVsZW1lbnRzIGJ5IHRoZWlyIENTUyBjbGFzcyBuYW1lcyBoZXJlLiBUaGVzZSBcbiAgICAgKiBhcmUgZ29pbmcgdG8gYmUgYnJpdHRsZSBsaW5rcyBhcyB0aGV5IHJlbHkgb24gb3RoZXIgcGx1Z2luIGRlZmluaXRpb25zIGJ1dFxuICAgICAqIGFzIHRoaXMgaXMgb25seSBhZGRpbmcgaW4gZXh0cmEgY29tcGF0YWJpbGl0eSB0byB0aGUgcGx1Z2lucyBkZWZpbmVkIGhlcmUgXG4gICAgICogaXQgc2hvdWxkIGJlIG9rLlxuICAgICAqIFxuICAgICAqIFRoZXNlIG1heSBiZSBjbGFzc2VzIG9uIG9uZSBvZiB0aGUgc2ltcGxlIGVsZW1lbnRzIChzdWNoIGFzIGEgcGFyYWdyYXBoKVxuICAgICAqIHRoYXQgd2Ugc2VhcmNoIGZvciBiZWxvdyBzbyBuZWVkIHRvIGxvb2sgZm9yIHRoZXNlIGZpcnN0LlxuICAgICAqL1xuICAgIGlmKGhhc0RpY2VSb2xsZXIoZWxlbWVudCkgPT09IHRydWUgfHxcbiAgICAgICBoYXNDb3B5QnV0dG9uKGVsZW1lbnQpID09PSB0cnVlKSB7XG5cbiAgICAgICAgcmV0dXJuIEVsZW1lbnRSZW5kZXJUeXBlLnNwZWNpYWxSZW5kZXJcbiAgICB9XG5cbiAgICBpZihoYXNBZG1vbml0aW9uKGVsZW1lbnQpID09PSB0cnVlIHx8XG4gICAgICAgaXNJRnJhbWUoZWxlbWVudCkgPT09IHRydWUpIHtcbiAgICAgICAgXG4gICAgICAgIHJldHVybiBFbGVtZW50UmVuZGVyVHlwZS5ub3JtYWxSZW5kZXJcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJZiB3ZSBkaWRudCBmaW5kIGEgc3BlY2lhbCBlbGVtZW50IHdlIHdhbnQgdG8gY2hlY2sgZm9yIHNpbXBsZSBlbGVtZW50c1xuICAgICAqIHN1Y2ggYXMgcGFyYWdyYXBocyBvciBsaXN0cy4gSW4gdGhlIGN1cnJlbnQgaW1wbGVtZW50YXRpb24gd2Ugb25seSBzZXQgdXBcbiAgICAgKiB0aGUgc3BlY2lhbCBjYXNlIGZvciBcInNwZWNpYWxSZW5kZXJcIiBlbGVtZW50cyBzbyB0aGlzICpzaG91bGQqIGJlIHNhdmluZ1xuICAgICAqIHNvbWUgcmVuZGVyaW5nIHRpbWUgYnkgc2V0dGluZyB0aGVzZSB0YWdzIHByb3Blcmx5LlxuICAgICAqL1xuICAgIGlmKGhhc1BhcmFncmFwaChlbGVtZW50KSB8fCBcbiAgICAgICBoYXNIZWFkZXIoZWxlbWVudCkgICAgfHxcbiAgICAgICBoYXNMaXN0KGVsZW1lbnQpKSB7XG5cbiAgICAgICAgcmV0dXJuIEVsZW1lbnRSZW5kZXJUeXBlLm5vcm1hbFJlbmRlcjtcbiAgICB9XG5cbiAgICAvLyBJZiBzdGlsbCBub3RoaW5nIGZvdW5kIHdlIHJldHVybiBvdGhlciBhcyB0aGUgZGVmYXVsdCByZXNwb25zZSBpZiBub3RoaW5nIGVsc2UgZm91bmQuXG4gICAgcmV0dXJuIEVsZW1lbnRSZW5kZXJUeXBlLnNwZWNpYWxSZW5kZXI7XG59XG5cbmZ1bmN0aW9uIGhhc1BhcmFncmFwaChlbGVtZW50OiBIVE1MRWxlbWVudCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiBlbGVtZW50LmlubmVySFRNTC5zdGFydHNXaXRoKFwiPHBcIik7XG59XG5cbmZ1bmN0aW9uIGhhc0hlYWRlcihlbGVtZW50OiBIVE1MRWxlbWVudCk6IGJvb2xlYW4ge1xuXG4gICAgaWYoZWxlbWVudC5pbm5lckhUTUwuc3RhcnRzV2l0aChcIjxoMVwiKSB8fCBcbiAgICAgICBlbGVtZW50LmlubmVySFRNTC5zdGFydHNXaXRoKFwiPGgyXCIpIHx8IFxuICAgICAgIGVsZW1lbnQuaW5uZXJIVE1MLnN0YXJ0c1dpdGgoXCI8aDNcIikgfHwgXG4gICAgICAgZWxlbWVudC5pbm5lckhUTUwuc3RhcnRzV2l0aChcIjxoNFwiKSB8fFxuICAgICAgIGVsZW1lbnQuaW5uZXJIVE1MLnN0YXJ0c1dpdGgoXCI8aDVcIikgfHxcbiAgICAgICBlbGVtZW50LmlubmVySFRNTC5zdGFydHNXaXRoKFwiPGg2XCIpKSB7XG5cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBoYXNMaXN0KGVsZW1lbnQ6IEhUTUxFbGVtZW50KTogYm9vbGVhbiB7XG4gICAgXG4gICAgaWYoZWxlbWVudC5pbm5lckhUTUwuc3RhcnRzV2l0aChcIjx1bFwiKSB8fCBcbiAgICAgICBlbGVtZW50LmlubmVySFRNTC5zdGFydHNXaXRoKFwiPG9sXCIpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gaGFzQ29weUJ1dHRvbihlbGVtZW50OiBIVE1MRWxlbWVudCk6IGJvb2xlYW4ge1xuICAgIGlmKGVsZW1lbnQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZShcImNvcHktY29kZS1idXR0b25cIikubGVuZ3RoICE9PSAwKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHJldHVybiBmYWxzZVxufVxuXG5mdW5jdGlvbiBoYXNEaWNlUm9sbGVyKGVsZW1lbnQ6IEhUTUxFbGVtZW50KTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIGVsZW1lbnQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZShcImRpY2Utcm9sbGVyXCIpLmxlbmd0aCAhPT0gMDtcbn1cblxuZnVuY3Rpb24gaGFzQWRtb25pdGlvbihlbGVtZW50OiBIVE1MRWxlbWVudCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiBlbGVtZW50LmdldEVsZW1lbnRzQnlDbGFzc05hbWUoXCJhZG1vbml0aW9uXCIpLmxlbmd0aCAhPT0gMDtcbn1cblxuZnVuY3Rpb24gaXNJRnJhbWUoZWxlbWVudDogSFRNTEVsZW1lbnQpOiBib29sZWFuIHtcblxuICAgIGlmKGVsZW1lbnQuY2hpbGRyZW4ubGVuZ3RoID4gMCkge1xuXG4gICAgICAgIHJldHVybiBlbGVtZW50LmZpcnN0Q2hpbGQubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gXCJpZnJhbWVcIjtcbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2Vcbn0iLCIvKlxuICogRmlsZW5hbWU6IG11bHRpLWNvbHVtbi1tYXJrZG93bi9zcmMvZG9tT2JqZWN0LnRzXG4gKiBDcmVhdGVkIERhdGU6IFR1ZXNkYXksIEZlYnJ1YXJ5IDFzdCAyMDIyLCAxMjowNDowMCBwbVxuICogQXV0aG9yOiBDYW1lcm9uIFJvYmluc29uXG4gKiBcbiAqIENvcHlyaWdodCAoYykgMjAyMiBDYW1lcm9uIFJvYmluc29uXG4gKi9cblxuaW1wb3J0IHsgZ2V0VUlEIH0gZnJvbSBcIi4uL3V0aWxpdGllcy91dGlsc1wiO1xuaW1wb3J0IHsgRWxlbWVudFJlbmRlclR5cGUgfSBmcm9tIFwiLi4vdXRpbGl0aWVzL2VsZW1lbnRSZW5kZXJUeXBlUGFyc2VyXCI7XG5pbXBvcnQgeyBNdWx0aUNvbHVtblNldHRpbmdzIH0gZnJvbSBcIi4uL3JlZ2lvblNldHRpbmdzXCI7XG5cbmV4cG9ydCBlbnVtIERPTU9iamVjdFRhZyB7XG4gICAgbm9uZSxcbiAgICBzdGFydFJlZ2lvbixcbiAgICByZWdpb25TZXR0aW5ncyxcbiAgICBjb2x1bW5CcmVhayxcbiAgICBlbmRSZWdpb25cbn1cblxuZXhwb3J0IGNsYXNzIERPTU9iamVjdCB7XG4gICAgbm9kZUtleTogc3RyaW5nO1xuICAgIG9yaWdpbmFsRWxlbWVudDogSFRNTEVsZW1lbnQ7XG4gICAgY2xvbmVkRWxlbWVudDogSFRNTEVsZW1lbnQ7XG4gICAgVUlEOiBzdHJpbmc7XG4gICAgdGFnOiBET01PYmplY3RUYWc7XG4gICAgdXNpbmdPcmlnaW5hbEVsZW1lbnQ6IGJvb2xlYW5cbiAgICBlbGVtZW50VHlwZTogRWxlbWVudFJlbmRlclR5cGUgPSBFbGVtZW50UmVuZGVyVHlwZS51bmRlZmluZWQ7XG4gICAgZWxlbWVudENvbnRhaW5lcjogSFRNTERpdkVsZW1lbnQgPSBudWxsO1xuXG4gICAgY29uc3RydWN0b3IoZWxlbWVudDogSFRNTEVsZW1lbnQsIFxuICAgICAgICAgICAgICAgIHJhbmRvbUlEOnN0cmluZyA9IGdldFVJRCgpLCBcbiAgICAgICAgICAgICAgICB0YWc6IERPTU9iamVjdFRhZyA9IERPTU9iamVjdFRhZy5ub25lICkge1xuICAgICAgICB0aGlzLm5vZGVLZXkgPSBlbGVtZW50LmlubmVyVGV4dC50cmltKCk7XG4gICAgICAgIHRoaXMub3JpZ2luYWxFbGVtZW50ID0gZWxlbWVudDtcbiAgICAgICAgdGhpcy5VSUQgPSByYW5kb21JRDtcbiAgICAgICAgdGhpcy50YWcgPSB0YWc7XG4gICAgICAgIHRoaXMudXNpbmdPcmlnaW5hbEVsZW1lbnQgPSBmYWxzZVxuICAgIH1cblxuICAgIHNldE1haW5ET01FbGVtZW50KGRvbUVsZW1lbnQ6IEhUTUxFbGVtZW50KSB7XG4gICAgICAgIHRoaXMub3JpZ2luYWxFbGVtZW50ID0gZG9tRWxlbWVudDtcbiAgICAgICAgdGhpcy51c2luZ09yaWdpbmFsRWxlbWVudCA9IHRydWVcbiAgICB9XG59XG5cbmV4cG9ydCBjbGFzcyBET01TdGFydFJlZ2lvbk9iamVjdCBleHRlbmRzIERPTU9iamVjdCB7XG5cbiAgICByZWdpb25FbGVtZW50OiBIVE1MRWxlbWVudDtcblxuICAgIGNvbnN0cnVjdG9yKGJhc2VET01PYmplY3Q6IERPTU9iamVjdCwgcmVnaW9uRWxlbWVudDogSFRNTEVsZW1lbnQpIHtcblxuICAgICAgICBzdXBlcihiYXNlRE9NT2JqZWN0Lm9yaWdpbmFsRWxlbWVudCwgYmFzZURPTU9iamVjdC5VSUQsIERPTU9iamVjdFRhZy5zdGFydFJlZ2lvbik7XG4gICAgICAgIHRoaXMucmVnaW9uRWxlbWVudCA9IHJlZ2lvbkVsZW1lbnQ7XG4gICAgfVxufVxuXG5leHBvcnQgY2xhc3MgVGFza0xpc3RET01PYmplY3QgZXh0ZW5kcyBET01PYmplY3Qge1xuXG4gICAgb3JpZ2luYWxDaGVja2JveGVzOiBIVE1MRWxlbWVudFtdID0gW107XG5cbiAgICBjb25zdHJ1Y3RvcihiYXNlRE9NT2JqZWN0OiBET01PYmplY3QpIHtcblxuICAgICAgICBzdXBlcihiYXNlRE9NT2JqZWN0Lm9yaWdpbmFsRWxlbWVudCwgYmFzZURPTU9iamVjdC5VSUQsIERPTU9iamVjdFRhZy5zdGFydFJlZ2lvbik7XG4gICAgfVxuXG4gICAgY2hlY2tib3hDbGlja2VkKGluZGV4OiBudW1iZXIpIHtcblxuICAgICAgICBpZihpbmRleCA8IHRoaXMub3JpZ2luYWxDaGVja2JveGVzLmxlbmd0aCkge1xuXG4gICAgICAgICAgICBsZXQgb3JpZ2luYWxJbnB1dCA9IHRoaXMub3JpZ2luYWxDaGVja2JveGVzW2luZGV4XS5maXJzdENoaWxkIGFzIEhUTUxJbnB1dEVsZW1lbnQ7XG4gICAgICAgICAgICBvcmlnaW5hbElucHV0LmNsaWNrKCk7XG4gICAgICAgIH1cbiAgICB9XG59IiwiLypcclxuICogRmlsZTogbXVsdGktY29sdW1uLW1hcmtkb3duL3NyYy9tYWluLnRzXHJcbiAqIENyZWF0ZWQgRGF0ZTogVHVlc2RheSwgT2N0b2JlciA1dGggMjAyMSwgMTowOSBwbVxyXG4gKiBBdXRob3I6IENhbWVyb24gUm9iaW5zb25cclxuICogXHJcbiAqIENvcHlyaWdodCAoYykgMjAyMiBDYW1lcm9uIFJvYmluc29uXHJcbiAqL1xyXG5cclxuaW1wb3J0IHsgTm90aWNlLCBQbHVnaW4sICBNYXJrZG93blJlbmRlckNoaWxkLCBNYXJrZG93blJlbmRlcmVyIH0gZnJvbSAnb2JzaWRpYW4nO1xyXG5pbXBvcnQgKiBhcyBtdWx0aUNvbHVtblBhcnNlciBmcm9tICcuL3V0aWxpdGllcy90ZXh0UGFyc2VyJztcclxuaW1wb3J0IHsgUmVnaW9uRE9NTWFuYWdlciwgTXVsdGlDb2x1bW5SZW5kZXJEYXRhLCBHbG9iYWxET01NYW5hZ2VyIH0gZnJvbSAnLi9kb21fbWFuYWdlci9kb21NYW5hZ2VyJztcclxuaW1wb3J0IHsgRE9NT2JqZWN0LCBET01PYmplY3RUYWcsIFRhc2tMaXN0RE9NT2JqZWN0IH0gZnJvbSAnLi9kb21fbWFuYWdlci9kb21PYmplY3QnO1xyXG5pbXBvcnQgeyBNdWx0aUNvbHVtblNldHRpbmdzLCBDb2x1bW5MYXlvdXQgfSBmcm9tIFwiLi9yZWdpb25TZXR0aW5nc1wiO1xyXG5cclxuaW1wb3J0IHsgZ2V0VUlEIH0gZnJvbSAnLi91dGlsaXRpZXMvdXRpbHMnO1xyXG5pbXBvcnQgeyBNdWx0aUNvbHVtbkxheW91dENTUywgTXVsdGlDb2x1bW5TdHlsZUNTUyB9IGZyb20gJy4vdXRpbGl0aWVzL2Nzc0RlZmluaXRpb25zJztcclxuaW1wb3J0IHsgRWxlbWVudFJlbmRlclR5cGUsIGdldEVsZW1lbnRSZW5kZXJUeXBlIH0gZnJvbSAnLi91dGlsaXRpZXMvZWxlbWVudFJlbmRlclR5cGVQYXJzZXInO1xyXG5cclxuXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIE11bHRpQ29sdW1uTWFya2Rvd24gZXh0ZW5kcyBQbHVnaW4ge1xyXG5cdC8vIHNldHRpbmdzOiBTcGxpdENvbHVtbk1hcmtkb3duU2V0dGluZ3M7XHJcblxyXG4gICAgZ2xvYmFsTWFuYWdlcjogR2xvYmFsRE9NTWFuYWdlciA9IG5ldyBHbG9iYWxET01NYW5hZ2VyKCk7XHJcblxyXG5cdGFzeW5jIG9ubG9hZCgpIHtcclxuXHJcbiAgICAgICAgY29uc29sZS5sb2coXCJMb2FkaW5nIG11bHRpLWNvbHVtbiBtYXJrZG93blwiKTtcclxuXHJcblxyXG4gICAgICAgIHRoaXMuc2V0dXBNYXJrZG93blBvc3RQcm9jZXNzb3IoKTtcclxuXHJcbiAgICAgICAgLy9UT0RPOiBTZXQgdXAgdGhpcyBhcyBhIG1vZGFsIHRvIHNldCBzZXR0aW5ncyBhdXRvbWF0aWNhbGx5XHJcbiAgICAgICAgdGhpcy5hZGRDb21tYW5kKHsgICAgICAgICAgICBcclxuICAgICAgICAgICAgaWQ6IGBpbnNlcnQtbXVsdGktY29sdW1uLXJlZ2lvbmAsXHJcbiAgICAgICAgICAgIG5hbWU6IGBJbnNlcnQgTXVsdGktQ29sdW1uIFJlZ2lvbmAsXHJcbiAgICAgICAgICAgIGVkaXRvckNhbGxiYWNrOiAoZWRpdG9yLCB2aWV3KSA9PiB7XHJcblxyXG4gICAgICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgICAgICBlZGl0b3IuZ2V0RG9jKCkucmVwbGFjZVNlbGVjdGlvbihcclxuYFxyXG49PT0gbXVsdGktY29sdW1uLXN0YXJ0OiBJRF8ke2dldFVJRCg0KX1cclxuXFxgXFxgXFxgY29sdW1uLXNldHRpbmdzXHJcbk51bWJlciBvZiBDb2x1bW5zOiAyXHJcbkxhcmdlc3QgQ29sdW1uOiBzdGFuZGFyZFxyXG5cXGBcXGBcXGBcclxuXHJcbj09PSBlbmQtY29sdW1uID09PVxyXG5cclxuPT09IG11bHRpLWNvbHVtbi1lbmRcclxuXHJcbiR7ZWRpdG9yLmdldERvYygpLmdldFNlbGVjdGlvbigpfWBcclxuICAgICAgICAgICAgICAgICAgICApO1xyXG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIG5ldyBOb3RpY2UoXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiRW5jb3VudGVyZWQgYW4gZXJyb3IgaW5zZXJ0aW5nIGEgbXVsdGktY29sdW1uIHJlZ2lvbi4gUGxlYXNlIHRyeSBhZ2FpbiBsYXRlci5cIlxyXG4gICAgICAgICAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgdGhpcy5hZGRDb21tYW5kKHsgICAgICAgICAgICBcclxuICAgICAgICAgICAgaWQ6IGBhZGQtSURzLVRvLW11bHRpLWNvbHVtbi1yZWdpb25gLFxyXG4gICAgICAgICAgICBuYW1lOiBgRml4IE1pc3NpbmcgSURzIGZvciBNdWx0aS1Db2x1bW4gUmVnaW9uc2AsXHJcbiAgICAgICAgICAgIGVkaXRvckNhbGxiYWNrOiAoZWRpdG9yLCB2aWV3KSA9PiB7XHJcblxyXG4gICAgICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAgICAgKiBOb3Qgc3VyZSBpZiB0aGVyZSBpcyBhbiBlYXNpZXIgd2F5IHRvIGRvIHRoaXMuXHJcbiAgICAgICAgICAgICAgICAgICAgICogXHJcbiAgICAgICAgICAgICAgICAgICAgICogR2V0IGFsbCBvZiB0aGUgbGluZXMgb2YgdGhlIGRvY3VtZW50IHNwbGl0IGJ5IG5ld2xpbmVzLlxyXG4gICAgICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCBsaW5lcyA9IGVkaXRvci5nZXRSYW5nZSh7IGxpbmU6IDAsIGNoOiAwIH0sIHsgbGluZTogZWRpdG9yLmdldERvYygpLmxpbmVDb3VudCgpLCBjaDogMH0pLnNwbGl0KFwiXFxuXCIpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAgICAgKiBMb29wIHRocm91Z2ggYWxsIG9mIHRoZSBsaW5lcyBjaGVja2luZyBpZiB0aGUgbGluZSBpcyBhIFxyXG4gICAgICAgICAgICAgICAgICAgICAqIHN0YXJ0IHRhZyBhbmQgaWYgc28gaXMgaXQgbWlzc2luZyBhbiBJRC5cclxuICAgICAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgICAgICBsZXQgbGluZXNXaXRob3V0SURzID0gW11cclxuICAgICAgICAgICAgICAgICAgICBsZXQgdGV4dFdpdGhvdXRJRHMgPSBbXVxyXG4gICAgICAgICAgICAgICAgICAgIGZvcihsZXQgaSA9IDA7IGkgPCBsaW5lcy5sZW5ndGg7IGkrKykge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGRhdGEgPSBtdWx0aUNvbHVtblBhcnNlci5pc1N0YXJ0VGFnV2l0aElEKGxpbmVzW2ldKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYoZGF0YS5pc1N0YXJ0VGFnID09PSB0cnVlICYmIGRhdGEuaGFzS2V5ID09PSBmYWxzZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGluZXNXaXRob3V0SURzLnB1c2goaSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZXh0V2l0aG91dElEcy5wdXNoKGxpbmVzW2ldKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfSAgICAgICAgICAgICAgICAgICAgXHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmKGxpbmVzV2l0aG91dElEcy5sZW5ndGggPT09IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbmV3IE5vdGljZSAoXCJGb3VuZCAwIG1pc3NpbmcgSURzIGluIHRoZSBjdXJyZW50IGRvY3VtZW50LlwiKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgICAgICogTm93IGxvb3AgdGhyb3VnaCBlYWNoIGxpbmUgdGhhdCBpcyBtaXNzaW5nIGFuIElEIGFuZFxyXG4gICAgICAgICAgICAgICAgICAgICAqIGdlbmVyYXRlIGEgcmFuZG9tIElEIGFuZCByZXBsYWNlIHRoZSBvcmlnaW5hbCB0ZXh0LlxyXG4gICAgICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgICAgIGZvcihsZXQgaSA9IDA7IGkgPCBsaW5lc1dpdGhvdXRJRHMubGVuZ3RoOyBpKyspIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBvcmlnaW5hbFRleHQgPSB0ZXh0V2l0aG91dElEc1tpXVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgdGV4dCA9IG9yaWdpbmFsVGV4dDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGV4dCA9IHRleHQudHJpbUVuZCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZih0ZXh0LmNoYXJBdCh0ZXh0Lmxlbmd0aCAtIDEpID09PSBcIjpcIikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGV4dCA9IHRleHQuc2xpY2UoMCwgdGV4dC5sZW5ndGgtMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgdGV4dCA9IGAke3RleHR9OiBJRF8ke2dldFVJRCg0KX1gO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgZWRpdG9yLnJlcGxhY2VSYW5nZSh0ZXh0LCB7IGxpbmU6IGxpbmVzV2l0aG91dElEc1tpXSwgY2g6IDAgfSwgXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeyBsaW5lOiBsaW5lc1dpdGhvdXRJRHNbaV0sIGNoOiBvcmlnaW5hbFRleHQubGVuZ3RofSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIG5ldyBOb3RpY2UgKGBSZXBsYWNlZCAke2xpbmVzV2l0aG91dElEcy5sZW5ndGh9IG1pc3NpbmcgSUQocykgaW4gdGhlIGN1cnJlbnQgZG9jdW1lbnQuYCk7XHJcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbmV3IE5vdGljZShcclxuICAgICAgICAgICAgICAgICAgICAgICAgXCJFbmNvdW50ZXJlZCBhbiBlcnJvciBhZGRpZ24gSURzIHRvIG11bHRpLWNvbHVtbiByZWdpb25zLiBQbGVhc2UgdHJ5IGFnYWluIGxhdGVyLlwiXHJcbiAgICAgICAgICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICB0aGlzLnJlZ2lzdGVySW50ZXJ2YWwod2luZG93LnNldEludGVydmFsKCgpID0+IHtcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIHRoaXMuVXBkYXRlT3BlbkZpbGVQcmV2aWV3cygpO1xyXG4gICAgICAgIH0sIDUwMCkpO1xyXG4gICAgfVxyXG5cclxuICAgIFVwZGF0ZU9wZW5GaWxlUHJldmlld3MoKSB7XHJcblxyXG4gICAgICAgIGxldCBmaWxlTWFuYWdlcnMgPSB0aGlzLmdsb2JhbE1hbmFnZXIuZ2V0QWxsRmlsZU1hbmFnZXJzKCk7XHJcbiAgICAgICAgZmlsZU1hbmFnZXJzLmZvckVhY2goZWxlbWVudCA9PiB7XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICBsZXQgcmVnaW9uYWxNYW5hZ2VycyA9IGVsZW1lbnQuZ2V0QWxsUmVnaW9uYWxNYW5hZ2VycygpO1xyXG4gICAgICAgICAgICByZWdpb25hbE1hbmFnZXJzLmZvckVhY2gocmVnaW9uTWFuYWdlciA9PiB7XHJcbiAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgIGxldCBwYXJlbnRFbGVtZW50RGF0YTogTXVsdGlDb2x1bW5SZW5kZXJEYXRhID0gcmVnaW9uTWFuYWdlci5nZXRSZWdpb25SZW5kZXJEYXRhKCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZVJlbmRlcmVkTWFya2Rvd24ocGFyZW50RWxlbWVudERhdGEuZG9tT2JqZWN0cyk7ICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICBzZXR1cE1hcmtkb3duUG9zdFByb2Nlc3NvcigpIHtcclxuXHJcbiAgICAgICAgdGhpcy5yZWdpc3Rlck1hcmtkb3duUG9zdFByb2Nlc3Nvcihhc3luYyAoZWwsIGN0eCkgPT4ge1xyXG5cclxuICAgICAgICAgICAgY29uc3Qgc291cmNlUGF0aCA9IGN0eC5zb3VyY2VQYXRoO1xyXG5cclxuICAgICAgICAgICAgbGV0IGZpbGVET01NYW5hZ2VyID0gdGhpcy5nbG9iYWxNYW5hZ2VyLmdldEZpbGVNYW5hZ2VyKHNvdXJjZVBhdGgpO1xyXG4gICAgICAgICAgICBpZihmaWxlRE9NTWFuYWdlciA9PT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJGb3VuZCBudWxsIERPTSBtYW5hZ2VyLiBDb3VsZCBub3QgcHJvY2VzcyBtdWx0aS1jb2x1bW4gbWFya2Rvd24uXCIpXHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBUaGlzIGJsb2NrIG9mIGNvZGUgcnVucyB3aGVuIHRoZSBleHBvcnQgdGFnIGlzIGluIHRoZSBmcm9udG1hdHRlciBzb1xyXG4gICAgICAgICAgICAgKiB3ZSBhc3N1bWUgdGhhdCB0aGUgdXNlciBpcyBhdHRlbXB0aW5nIHRvIGV4cG9ydCB0aGUgZG9jdW1lbnQuXHJcbiAgICAgICAgICAgICAqIFxyXG4gICAgICAgICAgICAgKiBXZSBsb29wIG92ZXIgdGhlIGVsZW1lbnRzIHBhc3NlZCBhbmQgbG9vayBmb3IgY2hpbGRyZW4gdGhhdCB3b3VsZCBiZVxyXG4gICAgICAgICAgICAgKiB3aXRoaW4gYSBtdWx0aS1jb2x1bW4gcmVnaW9uLiBJZiB3ZSBmaW5kIHRoZW0gd2UgcmVtb3ZlIHRoZW0gZnJvbVxyXG4gICAgICAgICAgICAgKiB0aGUgcGFyZW50IHNvIHRoZXkgYXJlIG5vdCBleHBvcnRlZCB0byB0aGUgUERGLlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgaWYodGhpcy5jaGVja0V4cG9ydGluZyhlbCkpIHtcclxuXHJcbiAgICAgICAgICAgICAgICBsZXQgZG9jQ2hpbGRyZW4gPSBBcnJheS5mcm9tKGVsLmNoaWxkTm9kZXMpO1xyXG4gICAgICAgICAgICAgICAgbGV0IGNoaWxkcmVuVG9SZW1vdmUgPSBbXVxyXG5cclxuICAgICAgICAgICAgICAgIGxldCBpbkJsb2NrID0gZmFsc2VcclxuICAgICAgICAgICAgICAgIGZvcihsZXQgaSA9IDA7IGkgPCBkb2NDaGlsZHJlbi5sZW5ndGg7IGkrKykge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBsZXQgY2hpbGQgPSBkb2NDaGlsZHJlbltpXTtcclxuICAgICAgICAgICAgICAgICAgICBpZihjaGlsZCBpbnN0YW5jZW9mIEhUTUxFbGVtZW50KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBjaGlsZEVsID0gY2hpbGQgYXMgSFRNTEVsZW1lbnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYoaW5CbG9jayA9PT0gZmFsc2UpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBibG9ja0RhdGEgPSBtdWx0aUNvbHVtblBhcnNlci5pc1N0YXJ0VGFnV2l0aElEKGNoaWxkLnRleHRDb250ZW50KVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYoYmxvY2tEYXRhLmlzU3RhcnRUYWcgPT09IHRydWUpIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5CbG9jayA9IHRydWU7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCByZWdpb25LZXkgPSBcIlwiXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYoYmxvY2tEYXRhLmhhc0tleSA9PT0gdHJ1ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgZm91bmRLZXkgPSBtdWx0aUNvbHVtblBhcnNlci5nZXRTdGFydFRhZ0tleShjaGlsZC50ZXh0Q29udGVudClcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYoZm91bmRLZXkgIT09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlZ2lvbktleSA9IGZvdW5kS2V5O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IobGV0IGkgPSBjaGlsZC5jaGlsZHJlbi5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaGlsZC5jaGlsZHJlbltpXS5kZXRhY2goKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hpbGQuaW5uZXJUZXh0ID0gXCJcIlxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaGlsZC5jbGFzc0xpc3QuYWRkKE11bHRpQ29sdW1uTGF5b3V0Q1NTLlJlZ2lvblJvb3RDb250YWluZXJEaXYpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHJlbmRlckVycm9yUmVnaW9uID0gY2hpbGQuY3JlYXRlRGl2KHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xzOiBgJHtNdWx0aUNvbHVtbkxheW91dENTUy5SZWdpb25FcnJvckNvbnRhaW5lckRpdn0sICR7TXVsdGlDb2x1bW5TdHlsZUNTUy5SZWdpb25FcnJvck1lc3NhZ2V9YCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgcmVuZGVyQ29sdW1uUmVnaW9uID0gY2hpbGQuY3JlYXRlRGl2KHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xzOiBNdWx0aUNvbHVtbkxheW91dENTUy5SZWdpb25Db250ZW50Q29udGFpbmVyRGl2XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSlcclxuXHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiZ2V0dGluZyByZWdpb24gZnJvbSBrZXlcIiwgcmVnaW9uS2V5KVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCByZWdpb25hbE1hbmFnZXI6IFJlZ2lvbkRPTU1hbmFnZXIgPSBmaWxlRE9NTWFuYWdlci5nZXRSZWdpb25hbE1hbmFnZXIocmVnaW9uS2V5KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZihyZWdpb25hbE1hbmFnZXIgPT09IG51bGwpIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlbmRlckVycm9yUmVnaW9uLmlubmVyVGV4dCA9IFwiRXJyb3IgcmVuZGVyaW5nIG11bHRpLWNvbHVtbiByZWdpb24uXFxuUGxlYXNlIGNsb3NlIGFuZCByZW9wZW4gdGhlIGZpbGUsIHRoZW4gbWFrZSBzdXJlIHlvdSBhcmUgaW4gcmVhZGluZyBtb2RlIGJlZm9yZSBleHBvcnRpbmcuXCJcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiUmVuZGVyaW5nIHJlZ2lvbj9cIilcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBwYXJlbnRFbGVtZW50RGF0YTogTXVsdGlDb2x1bW5SZW5kZXJEYXRhID0gcmVnaW9uYWxNYW5hZ2VyLmdldFJlZ2lvblJlbmRlckRhdGEoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIERlZmF1bHQgc2V0IHNoYWRvdyB0byBvZmYgZm9yIGV4cG9ydGluZyBQREZzXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCByZW5kZXJTZXR0aW5ncyA9IHBhcmVudEVsZW1lbnREYXRhLnBhcmVudFJlbmRlclNldHRpbmdzXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlbmRlclNldHRpbmdzLmRyYXdTaGFkb3cgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucmVuZGVyQ29sdW1uTWFya2Rvd24ocGFyZW50RWxlbWVudERhdGEucGFyZW50UmVuZGVyRWxlbWVudCwgcGFyZW50RWxlbWVudERhdGEuZG9tT2JqZWN0cywgcmVuZGVyU2V0dGluZ3MpO1xyXG4gICAgICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJlbmRlckNvbHVtbk1hcmtkb3duKHJlbmRlckNvbHVtblJlZ2lvbiwgcGFyZW50RWxlbWVudERhdGEuZG9tT2JqZWN0cy5zbGljZSgpLCBwYXJlbnRFbGVtZW50RGF0YS5wYXJlbnRSZW5kZXJTZXR0aW5ncyk7ICAgXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKG11bHRpQ29sdW1uUGFyc2VyLmNvbnRhaW5zRW5kVGFnKGNoaWxkLnRleHRDb250ZW50KSA9PT0gdHJ1ZSkge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbkJsb2NrID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hpbGRyZW5Ub1JlbW92ZS5wdXNoKGNoaWxkKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIGNoaWxkcmVuVG9SZW1vdmUuZm9yRWFjaChjaGlsZCA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgZWwucmVtb3ZlQ2hpbGQoY2hpbGQpO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIEdldCB0aGUgaW5mbyBmb3Igb3VyIGN1cnJlbnQgY29udGV4dCBhbmQgdGhlbiBjaGVja1xyXG4gICAgICAgICAgICAvLyBpZiB0aGUgZW50aXJlIHRleHQgY29udGFpbnMgYSBzdGFydCB0YWcuIElmIHRoZXJlIGlzXHJcbiAgICAgICAgICAgIC8vIG5vIHN0YXJ0IHRhZyBpbiB0aGUgZG9jdW1lbnQgd2UgY2FuIGp1c3QgcmV0dXJuIGFuZFxyXG4gICAgICAgICAgICAvLyBpZ25vcmUgdGhlIHJlc3Qgb2YgdGhlIHBhcnNpbmcuXHJcbiAgICAgICAgICAgIGxldCBpbmZvID0gY3R4LmdldFNlY3Rpb25JbmZvKGVsKTtcclxuXHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBXZSBuZWVkIHRoZSBjb250ZXh0IGluZm8gdG8gcHJvcGVybHkgcGFyc2Ugc28gcmV0dXJuaW5nIGhlcmUgXHJcbiAgICAgICAgICAgICAqIGluZm8gaXMgbnVsbC4gVE9ETzogU2V0IGVycm9yIGluIHZpZXcgaWYgdGhpcyBvY2N1cnMuXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBpZighaW5mbykge1xyXG5cclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIElmIHdlIGVuY291bnRlciBhIHN0YXJ0IHRhZyBvbiB0aGUgZG9jdW1lbnQgd2Ugc2V0IHRoZSBmbGFnIHRvIHN0YXJ0XHJcbiAgICAgICAgICAgICAqIHBhcnNpbmcgdGhlIHJlc3Qgb2YgdGhlIGRvY3VtZW50LlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgaWYobXVsdGlDb2x1bW5QYXJzZXIuY29udGFpbnNTdGFydFRhZyhlbC50ZXh0Q29udGVudCkpIHtcclxuICAgICAgICAgICAgICAgIGZpbGVET01NYW5hZ2VyLnNldEhhc1N0YXJ0VGFnKCk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8qKiBcclxuICAgICAgICAgICAgICogSWYgdGhlIGRvY3VtZW50IGRvZXMgbm90IGNvbnRhaW4gYW55IHN0YXJ0IHRhZ3Mgd2UgaWdub3JlIHRoZVxyXG4gICAgICAgICAgICAgKiByZXN0IG9mIHRoZSBwYXJzaW5nLiBUaGlzIGlzIG9ubHkgc2V0IHRvIHRydWUgb25jZSB0aGUgZmlyc3RcclxuICAgICAgICAgICAgICogc3RhcnQgdGFnIGVsZW1lbnQgaXMgcGFyc2VkIGFib3ZlLlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgaWYoZmlsZURPTU1hbmFnZXIuZ2V0SGFzU3RhcnRUYWcoKSA9PT0gZmFsc2UpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIFRha2UgdGhlIGluZm8gcHJvdmlkZWQgYW5kIGdlbmVyYXRlIHRoZSByZXF1aXJlZCB2YXJpYWJsZXMgZnJvbSBcclxuICAgICAgICAgICAgICogdGhlIGxpbmUgc3RhcnQgYW5kIGVuZCB2YWx1ZXMuXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBsZXQgZG9jTGluZXMgPSBpbmZvLnRleHQuc3BsaXQoXCJcXG5cIik7XHJcbiAgICAgICAgICAgIGxldCBsaW5lc0Fib3ZlQXJyYXkgPSBkb2NMaW5lcy5zbGljZSgwLCBpbmZvLmxpbmVTdGFydClcclxuICAgICAgICAgICAgbGV0IGxpbmVzT2ZFbGVtZW50ID0gZG9jTGluZXMuc2xpY2UoaW5mby5saW5lU3RhcnQsIGluZm8ubGluZUVuZCArIDEpO1xyXG4gICAgICAgICAgICBsZXQgbGluZXNCZWxvd0FycmF5ID0gZG9jTGluZXMuc2xpY2UoaW5mby5saW5lRW5kICsgMSlcclxuXHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBJZiB0aGUgY3VycmVudCBsaW5lIGlzIGEgc3RhcnQgdGFnIHdlIHdhbnQgdG8gc2V0IHVwIHRoZVxyXG4gICAgICAgICAgICAgKiByZWdpb24gbWFuYWdlci4gVGhlIHJlZ2lvbmFsIG1hbmFnZXIgdGFrZXMgY2FyZVxyXG4gICAgICAgICAgICAgKiBvZiBhbGwgaXRlbXMgYmV0d2VlbiBpdCdzIHN0YXJ0IGFuZCBlbmQgdGFncyB3aGlsZSB0aGVcclxuICAgICAgICAgICAgICogZmlsZSBtYW5hZ2VyIHdlIGdvdCBhYm92ZSBhYm92ZSB0YWtlcyBjYXJlIG9mIGFsbCByZWdpb25hbCBcclxuICAgICAgICAgICAgICogbWFuYWdlcnMgaW4gZWFjaCBmaWxlLlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgbGV0IGVsZW1lbnRUZXh0U3BhY2VkID0gbGluZXNPZkVsZW1lbnQucmVkdWNlKChwcmV2LCBjdXJyKSA9PiB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcHJldiArIFwiXFxuXCIgKyBjdXJyO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgaWYobXVsdGlDb2x1bW5QYXJzZXIuY29udGFpbnNTdGFydFRhZyhlbC50ZXh0Q29udGVudCkpIHtcclxuXHJcbiAgICAgICAgICAgICAgICAvKiogXHJcbiAgICAgICAgICAgICAgICAgKiBTZXQgdXAgdGhlIGN1cnJlbnQgZWxlbWVudCB0byBhY3QgYXMgdGhlIHBhcmVudCBmb3IgdGhlIFxyXG4gICAgICAgICAgICAgICAgICogbXVsdGktY29sdW1uIHJlZ2lvbi5cclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgZWwuY2hpbGRyZW5bMF0uZGV0YWNoKCk7XHJcbiAgICAgICAgICAgICAgICBlbC5jbGFzc0xpc3QuYWRkKE11bHRpQ29sdW1uTGF5b3V0Q1NTLlJlZ2lvblJvb3RDb250YWluZXJEaXYpXHJcbiAgICAgICAgICAgICAgICBsZXQgcmVuZGVyRXJyb3JSZWdpb24gPSBlbC5jcmVhdGVEaXYoe1xyXG4gICAgICAgICAgICAgICAgICAgIGNsczogYCR7TXVsdGlDb2x1bW5MYXlvdXRDU1MuUmVnaW9uRXJyb3JDb250YWluZXJEaXZ9LCAke011bHRpQ29sdW1uU3R5bGVDU1MuUmVnaW9uRXJyb3JNZXNzYWdlfWAsXHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIGxldCByZW5kZXJDb2x1bW5SZWdpb24gPSBlbC5jcmVhdGVEaXYoe1xyXG4gICAgICAgICAgICAgICAgICAgIGNsczogTXVsdGlDb2x1bW5MYXlvdXRDU1MuUmVnaW9uQ29udGVudENvbnRhaW5lckRpdlxyXG4gICAgICAgICAgICAgICAgfSlcclxuXHJcbiAgICAgICAgICAgICAgICBsZXQgc3RhcnRCbG9ja0RhdGEgPSBtdWx0aUNvbHVtblBhcnNlci5nZXRTdGFydEJsb2NrQWJvdmVMaW5lKGxpbmVzT2ZFbGVtZW50KVxyXG4gICAgICAgICAgICAgICAgaWYoc3RhcnRCbG9ja0RhdGEgPT09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgIGxldCByZWdpb25LZXkgPSBzdGFydEJsb2NrRGF0YS5zdGFydEJsb2NrS2V5O1xyXG4gICAgICAgICAgICAgICAgaWYoZmlsZURPTU1hbmFnZXIuY2hlY2tLZXlFeGlzdHMocmVnaW9uS2V5KSA9PT0gdHJ1ZSkge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBsZXQgeyBudW1iZXJPZlRhZ3MsIGtleXMgfSA9IG11bHRpQ29sdW1uUGFyc2VyLmNvdW50U3RhcnRUYWdzKGluZm8udGV4dCk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGxldCBudW1NYXRjaGVzID0gMDtcclxuICAgICAgICAgICAgICAgICAgICBmb3IobGV0IGkgPSAwOyBpIDwgbnVtYmVyT2ZUYWdzOyBpKyspIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEJlY2F1c2Ugd2UgY2hlY2tlZCBpZiBrZXkgZXhpc3RzIG9uZSBvZiB0aGVzZSBoYXMgdG8gbWF0Y2guXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKGtleXNbaV0gPT09IHJlZ2lvbktleSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbnVtTWF0Y2hlcysrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBXZSBvbmx5IHdhbnQgdG8gZGlzcGxheSBhbiBlcnJvciBpZiB0aGVyZSBhcmUgbW9yZSB0aGFuIDIgb2YgdGhlIHNhbWUgaWQgYWNyb3NzXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gdGhlIHdob2xlIGRvY3VtZW50LiBUaGlzIHByZXZlbnRzIGVycm9zIHdoZW4gb2JzaWRpYW4gcmVsb2FkcyB0aGUgd2hvbGUgZG9jdW1lbnRcclxuICAgICAgICAgICAgICAgICAgICAvLyBhbmQgdGhlcmUgYXJlIHR3byBvZiB0aGUgc2FtZSBrZXkgaW4gdGhlIG1hcC5cclxuICAgICAgICAgICAgICAgICAgICBpZihudW1NYXRjaGVzID49IDIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYocmVnaW9uS2V5ID09PSBcIlwiKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZW5kZXJFcnJvclJlZ2lvbi5pbm5lclRleHQgPSBcIkZvdW5kIG11bHRpcGxlIHJlZ2lvbnMgd2l0aCBlbXB0eSBJRHMuIFBsZWFzZSBzZXQgYSB1bmlxdWUgSUQgYWZ0ZXIgZWFjaCBzdGFydCB0YWcuXFxuRUc6ICc9PT0gbXVsdGktY29sdW1uLXN0YXJ0OiByYW5kb21JRCdcXG5PciB1c2UgJ0ZpeCBNaXNzaW5nIElEcycgaW4gdGhlIGNvbW1hbmQgcGFsZXR0ZSBhbmQgcmVsb2FkIHRoZSBkb2N1bWVudC5cIlxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVuZGVyRXJyb3JSZWdpb24uaW5uZXJUZXh0ID0gXCJSZWdpb24gSUQgYWxyZWFkeSBleGlzdHMgaW4gZG9jdW1lbnQsIHBsZWFzZSBzZXQgYSB1bmlxdWUgSUQuXFxuRUc6ICc9PT0gbXVsdGktY29sdW1uLXN0YXJ0OiByYW5kb21JRCdcIlxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbC5pZCA9IGBNdWx0aUNvbHVtbklEOiR7cmVnaW9uS2V5fWBcclxuXHJcbiAgICAgICAgICAgICAgICBsZXQgZWxlbWVudE1hcmtkb3duUmVuZGVyZXIgPSBuZXcgTWFya2Rvd25SZW5kZXJDaGlsZChlbCk7XHJcbiAgICAgICAgICAgICAgICBmaWxlRE9NTWFuYWdlci5jcmVhdGVSZWdpb25hbE1hbmFnZXIocmVnaW9uS2V5LCBlbCwgcmVuZGVyRXJyb3JSZWdpb24sIHJlbmRlckNvbHVtblJlZ2lvbik7XHJcbiAgICAgICAgICAgICAgICBlbGVtZW50TWFya2Rvd25SZW5kZXJlci5vbnVubG9hZCA9ICgpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICBpZihmaWxlRE9NTWFuYWdlcikge1xyXG4gICAgXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpbGVET01NYW5hZ2VyLnJlbW92ZVJlZ2lvbihzdGFydEJsb2NrRGF0YS5zdGFydEJsb2NrS2V5KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgY3R4LmFkZENoaWxkKGVsZW1lbnRNYXJrZG93blJlbmRlcmVyKTtcclxuXHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIE5vdyB3ZSBoYXZlIGNyZWF0ZWQgb3VyIHJlZ2lvbmFsIG1hbmFnZXIgYW5kIGRlZmluZWQgd2hhdCBlbGVtZW50cyBcclxuICAgICAgICAgICAgICAgICAqIG5lZWQgdG8gYmUgcmVuZGVyZWQgaW50by4gU28gd2UgY2FuIHJldHVybiB3aXRob3V0IGFueSBtb3JlIHByb2Nlc3NpbmcuXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIHJldHVyblxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogQ2hlY2sgaWYgYW55IG9mIHRoZSBsaW5lcyBhYm92ZSB1cyBjb250YWluIGEgc3RhcnQgYmxvY2ssIGFuZCBpZlxyXG4gICAgICAgICAgICAgKiBzbyBnZXQgdGhlIGxpbmVzIGZyb20gb3VyIGN1cnJlbnQgZWxlbWVudCB0byB0aGUgc3RhcnQgYmxvY2suXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBsZXQgc3RhcnRCb2NrQWJvdmUgPSBtdWx0aUNvbHVtblBhcnNlci5nZXRTdGFydEJsb2NrQWJvdmVMaW5lKGxpbmVzQWJvdmVBcnJheSk7XHJcbiAgICAgICAgICAgIGlmKHN0YXJ0Qm9ja0Fib3ZlID09PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIFdlIG5vdyBrbm93IHdlJ3JlIHdpdGhpbiBhIG11bHRpLWNvbHVtbiByZWdpb24sIHNvIHdlIHVwZGF0ZSBvdXJcclxuICAgICAgICAgICAgICogbGlzdCBvZiBsaW5lcyBhYm92ZSB0byBqdXN0IGJlIHRoZSBpdGVtcyB3aXRoaW4gdGhpcyByZWdpb24uXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBsaW5lc0Fib3ZlQXJyYXkgPSBzdGFydEJvY2tBYm92ZS5saW5lc0Fib3ZlQXJyYXk7XHJcblxyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogV2UgdXNlIHRoZSBzdGFydCBibG9jaydzIGtleSB0byBnZXQgb3VyIHJlZ2lvbmFsIG1hbmFnZXIuIElmIHRoaXNcclxuICAgICAgICAgICAgICogbG9va3VwIGZhaWxzIHdlIGNhbiBub3QgY29udGludWUgcHJvY2Vzc2luZyB0aGlzIGVsZW1lbnQuXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBsZXQgcmVnaW9uYWxNYW5hZ2VyOiBSZWdpb25ET01NYW5hZ2VyID0gZmlsZURPTU1hbmFnZXIuZ2V0UmVnaW9uYWxNYW5hZ2VyKHN0YXJ0Qm9ja0Fib3ZlLnN0YXJ0QmxvY2tLZXkpO1xyXG4gICAgICAgICAgICBpZihyZWdpb25hbE1hbmFnZXIgPT09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIHJldHVyblxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogVG8gbWFrZSBzdXJlIHdlJ3JlIHBsYWNpbmcgdGhlIGl0ZW0gaW4gdGhlIHJpZ2h0IGxvY2F0aW9uIChhbmQgXHJcbiAgICAgICAgICAgICAqIG92ZXJ3cml0ZSBlbGVtZW50cyB0aGF0IGFyZSBub3cgZ29uZSkgd2Ugbm93IHdhbnQgYWxsIG9mIHRoZVxyXG4gICAgICAgICAgICAgKiBsaW5lcyBhZnRlciB0aGlzIGVsZW1lbnQgdXAgdG8gdGhlIGVuZCB0YWcuXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBsaW5lc0JlbG93QXJyYXkgPSAgbXVsdGlDb2x1bW5QYXJzZXIuZ2V0RW5kQmxvY2tCZWxvdyhsaW5lc0JlbG93QXJyYXkpO1xyXG5cclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIE5vdyB3ZSB0YWtlIHRoZSBsaW5lcyBhYm92ZSBvdXIgY3VycmVudCBlbGVtZW50IHVwIHVudGlsIHRoZVxyXG4gICAgICAgICAgICAgKiBzdGFydCByZWdpb24gdGFnIGFuZCByZW5kZXIgdGhhdCBpbnRvIGFuIEhUTUwgZWxlbWVudC4gV2Ugd2lsbCBcclxuICAgICAgICAgICAgICogdXNlIHRoZXNlIGVsZW1lbnRzIHRvIGRldGVybWluZSB3aGVyZSB0byBwbGFjZSBvdXIgY3VycmVudCBlbGVtZW50LlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgbGV0IHNpYmxpbmdzQWJvdmU6IEhUTUxEaXZFbGVtZW50ID0gcmVuZGVyTWFya2Rvd25Gcm9tTGluZXMobGluZXNBYm92ZUFycmF5LCBzb3VyY2VQYXRoKTtcclxuXHJcbiAgICAgICAgICAgIGxldCBzaWJsaW5nc0JlbG93OiBIVE1MRGl2RWxlbWVudCA9IHJlbmRlck1hcmtkb3duRnJvbUxpbmVzKGxpbmVzQmVsb3dBcnJheSwgc291cmNlUGF0aCk7XHJcblxyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogU2V0IHVwIG91ciBkb20gb2JqZWN0IHRvIGJlIGFkZGVkIHRvIHRoZSBtYW5hZ2VyLlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgbGV0IGN1cnJlbnRPYmplY3Q6IERPTU9iamVjdCA9IG5ldyBET01PYmplY3QoZWwpXHJcbiAgICAgICAgICAgIGVsLmlkID0gY3VycmVudE9iamVjdC5VSUQ7XHJcblxyXG4gICAgICAgICAgICBjdXJyZW50T2JqZWN0ID0gdGhpcy5jaGVja1NwZWNpYWxFbGVtZW50KGN1cnJlbnRPYmplY3QpXHJcblxyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogTm93IHdlIGFkZCB0aGUgb2JqZWN0IHRvIHRoZSBtYW5hZ2VyIGFuZCB0aGVuIHNldHVwIHRoZVxyXG4gICAgICAgICAgICAgKiBjYWxsYmFjayBmb3Igd2hlbiB0aGUgb2JqZWN0IGlzIHJlbW92ZWQgZnJvbSB2aWV3IHRoYXQgd2lsbCByZW1vdmUgXHJcbiAgICAgICAgICAgICAqIHRoZSBpdGVtIGZyb20gdGhlIG1hbmFnZXIuXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICByZWdpb25hbE1hbmFnZXIuYWRkT2JqZWN0KHNpYmxpbmdzQWJvdmUsIHNpYmxpbmdzQmVsb3csIGN1cnJlbnRPYmplY3QpO1xyXG5cclxuICAgICAgICAgICAgbGV0IGVsZW1lbnRNYXJrZG93blJlbmRlcmVyID0gbmV3IE1hcmtkb3duUmVuZGVyQ2hpbGQoZWwpO1xyXG4gICAgICAgICAgICBlbGVtZW50TWFya2Rvd25SZW5kZXJlci5vbnVubG9hZCA9ICgpID0+IHtcclxuICAgICAgICAgICAgICAgIGlmKHJlZ2lvbmFsTWFuYWdlcikge1xyXG4gICAgICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgICAgIC8vIFdlIGNhbiBhdHRlbXB0IHRvIHVwZGF0ZSB0aGUgdmlldyBoZXJlIGFmdGVyIHRoZSBpdGVtIGlzIHJlbW92ZWRcclxuICAgICAgICAgICAgICAgICAgICAvLyBidXQgbmVlZCB0byBnZXQgdGhlIGl0ZW0ncyBwYXJlbnQgZWxlbWVudCBiZWZvcmUgcmVtb3Zpbmcgb2JqZWN0IGZyb20gbWFuYWdlci5cclxuICAgICAgICAgICAgICAgICAgICBsZXQgcmVnaW9uUmVuZGVyRGF0YTogTXVsdGlDb2x1bW5SZW5kZXJEYXRhID0gcmVnaW9uYWxNYW5hZ2VyLmdldFJlZ2lvblJlbmRlckRhdGEoKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgcmVnaW9uYWxNYW5hZ2VyLnJlbW92ZU9iamVjdChjdXJyZW50T2JqZWN0LlVJRCk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICAgICAqIE5lZWQgdG8gY2hlY2sgaGVyZSBpZiBlbGVtZW50IGlzIG51bGwgYXMgdGhpcyBjbG9zdXJlIHdpbGwgYmUgY2FsbGVkXHJcbiAgICAgICAgICAgICAgICAgICAgICogcmVwZWF0ZWRseSBvbiBmaWxlIGNoYW5nZS5cclxuICAgICAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgICAgICBpZihyZWdpb25SZW5kZXJEYXRhLnBhcmVudFJlbmRlckVsZW1lbnQgPT09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlbmRlckNvbHVtbk1hcmtkb3duKHJlZ2lvblJlbmRlckRhdGEucGFyZW50UmVuZGVyRWxlbWVudCwgcmVnaW9uUmVuZGVyRGF0YS5kb21PYmplY3RzLCByZWdpb25SZW5kZXJEYXRhLnBhcmVudFJlbmRlclNldHRpbmdzKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgY3R4LmFkZENoaWxkKGVsZW1lbnRNYXJrZG93blJlbmRlcmVyKTtcclxuXHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBOb3cgd2UgY2hlY2sgaWYgb3VyIGN1cnJlbnQgZWxlbWVudCBpcyBhIHNwZWNpYWwgZmxhZyBzbyB3ZSBjYW5cclxuICAgICAgICAgICAgICogcHJvcGVybHkgc2V0IHRoZSBlbGVtZW50IHRhZyB3aXRoaW4gdGhlIHJlZ2lvbmFsIG1hbmFnZXIuXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBpZihtdWx0aUNvbHVtblBhcnNlci5jb250YWluc0VuZFRhZyhlbC50ZXh0Q29udGVudCkgPT09IHRydWUpIHtcclxuXHJcbiAgICAgICAgICAgICAgICBlbC5hZGRDbGFzcyhNdWx0aUNvbHVtblN0eWxlQ1NTLlJlZ2lvbkVuZFRhZylcclxuICAgICAgICAgICAgICAgIHJlZ2lvbmFsTWFuYWdlci51cGRhdGVFbGVtZW50VGFnKGN1cnJlbnRPYmplY3QuVUlELCBET01PYmplY3RUYWcuZW5kUmVnaW9uKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmKG11bHRpQ29sdW1uUGFyc2VyLmNvbnRhaW5zQ29sRW5kVGFnKGVsZW1lbnRUZXh0U3BhY2VkKSA9PT0gdHJ1ZSkge1xyXG5cclxuICAgICAgICAgICAgICAgIGVsLmFkZENsYXNzKE11bHRpQ29sdW1uU3R5bGVDU1MuQ29sdW1uRW5kVGFnKVxyXG4gICAgICAgICAgICAgICAgcmVnaW9uYWxNYW5hZ2VyLnVwZGF0ZUVsZW1lbnRUYWcoY3VycmVudE9iamVjdC5VSUQsIERPTU9iamVjdFRhZy5jb2x1bW5CcmVhayk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZihtdWx0aUNvbHVtblBhcnNlci5jb250YWluc0NvbFNldHRpbmdzVGFnKGVsZW1lbnRUZXh0U3BhY2VkKSA9PT0gdHJ1ZSkge1xyXG5cclxuICAgICAgICAgICAgICAgIGVsLmFkZENsYXNzKE11bHRpQ29sdW1uU3R5bGVDU1MuUmVnaW9uU2V0dGluZ3MpXHJcbiAgICAgICAgICAgICAgICByZWdpb25hbE1hbmFnZXIuc2V0UmVnaW9uYWxTZXR0aW5ncyhlbGVtZW50VGV4dFNwYWNlZCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBlbC5hZGRDbGFzcyhNdWx0aUNvbHVtblN0eWxlQ1NTLlJlZ2lvbkNvbnRlbnQpXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBVc2Ugb3VyIHJlZ2lvbmFsIG1hbmFnZXIgdG8gZ2V0IGV2ZXJ5dGhpbmcgbmVlZGVkIHRvIHJlbmRlciB0aGUgcmVnaW9uLlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgbGV0IHBhcmVudEVsZW1lbnREYXRhOiBNdWx0aUNvbHVtblJlbmRlckRhdGEgPSByZWdpb25hbE1hbmFnZXIuZ2V0UmVnaW9uUmVuZGVyRGF0YSgpO1xyXG4gICAgICAgICAgICB0aGlzLnJlbmRlckNvbHVtbk1hcmtkb3duKHBhcmVudEVsZW1lbnREYXRhLnBhcmVudFJlbmRlckVsZW1lbnQsIHBhcmVudEVsZW1lbnREYXRhLmRvbU9iamVjdHMsIHBhcmVudEVsZW1lbnREYXRhLnBhcmVudFJlbmRlclNldHRpbmdzKTtcclxuXHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoaXMgZnVuY3Rpb24gdGFrZXMgaW4gdGhlIGRhdGEgZm9yIHRoZSBtdWx0aS1jb2x1bW4gcmVnaW9uIGFuZCBzZXRzIHVwIHRoZSBcclxuICAgICAqIHVzZXIgZGVmaW5lZCBudW1iZXIgb2YgY2hpbGRyZW4gd2l0aCB0aGUgcHJvcGVyIGNzcyBjbGFzc2VzIHRvIGJlIHJlbmRlcmVkIHByb3Blcmx5LlxyXG4gICAgICogXHJcbiAgICAgKiBAcGFyYW0gcGFyZW50RWxlbWVudCBUaGUgZWxlbWVudCB0aGF0IHRoZSBtdWx0aS1jb2x1bW4gcmVnaW9uIHdpbGwgYmUgcmVuZGVyZWQgdW5kZXIuXHJcbiAgICAgKiBAcGFyYW0gcmVnaW9uRWxlbWVudHMgVGhlIGxpc3Qgb2YgRE9NIG9iamVjdHMgdGhhdCB3aWxsIGJlIGNvcHBpZWQgdW5kZXIgdGhlIHBhcmVudCBvYmplY3RcclxuICAgICAqIEBwYXJhbSBzZXR0aW5ncyBUaGUgc2V0dGluZ3MgdGhlIHVzZXIgaGFzIGRlZmluZWQgZm9yIHRoZSByZWdpb24uXHJcbiAgICAgKi9cclxuICAgIHJlbmRlckNvbHVtbk1hcmtkb3duKHBhcmVudEVsZW1lbnQ6IEhUTUxFbGVtZW50LCByZWdpb25FbGVtZW50czogRE9NT2JqZWN0W10sIHNldHRpbmdzOiBNdWx0aUNvbHVtblNldHRpbmdzKSB7XHJcblxyXG4gICAgICAgIGxldCBtdWx0aUNvbHVtblBhcmVudCA9IGNyZWF0ZURpdih7XHJcbiAgICAgICAgICAgIGNsczogTXVsdGlDb2x1bW5MYXlvdXRDU1MuUmVnaW9uQ29sdW1uQ29udGFpbmVyRGl2LFxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGlmKHNldHRpbmdzLmRyYXdTaGFkb3cgPT09IHRydWUpIHtcclxuICAgICAgICAgICAgbXVsdGlDb2x1bW5QYXJlbnQuYWRkQ2xhc3MoTXVsdGlDb2x1bW5TdHlsZUNTUy5SZWdpb25TaGFkb3cpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUGFzcyBvdXIgcGFyZW50IGRpdiBhbmQgc2V0dGluZ3MgdG8gcGFyc2VyIHRvIGNyZWF0ZSB0aGUgcmVxdWlyZWRcclxuICAgICAgICAgKiBjb2x1bW4gZGl2cyBhcyBjaGlsZHJlbiBvZiB0aGUgcGFyZW50LlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGxldCBjb2x1bW5Db250ZW50RGl2cyA9IGdldENvbHVtbkNvbnRlbnREaXZzKHNldHRpbmdzLCBtdWx0aUNvbHVtblBhcmVudCk7XHJcbiAgICAgICAgZm9yKGxldCBpID0gMDsgaSA8IGNvbHVtbkNvbnRlbnREaXZzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGlmKHNldHRpbmdzLmRyYXdCb3JkZXIgPT09IHRydWUpIHtcclxuICAgICAgICAgICAgICAgIGNvbHVtbkNvbnRlbnREaXZzW2ldLmFkZENsYXNzKE11bHRpQ29sdW1uU3R5bGVDU1MuQ29sdW1uQm9yZGVyKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYoc2V0dGluZ3MuZHJhd1NoYWRvdyA9PT0gdHJ1ZSkge1xyXG4gICAgICAgICAgICAgICAgY29sdW1uQ29udGVudERpdnNbaV0uYWRkQ2xhc3MoTXVsdGlDb2x1bW5TdHlsZUNTUy5Db2x1bW5TaGFkb3cpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBDcmVhdGUgbWFya2Rvd24gcmVuZGVyZXIgdG8gcGFyc2UgdGhlIHBhc3NlZCBtYXJrZG93blxyXG4gICAgICAgIC8vIGJldHdlZW4gdGhlIHRhZ3MuXHJcbiAgICAgICAgbGV0IG1hcmtkb3duUmVuZGVyQ2hpbGQgPSBuZXcgTWFya2Rvd25SZW5kZXJDaGlsZChcclxuICAgICAgICAgICAgbXVsdGlDb2x1bW5QYXJlbnRcclxuICAgICAgICApO1xyXG5cclxuICAgICAgICAvLyBSZW1vdmUgZXZlcnkgb3RoZXIgY2hpbGQgZnJvbSB0aGUgcGFyZW50IHNvIFxyXG4gICAgICAgIC8vIHdlIGRvbnQgZW5kIHVwIHdpdGggbXVsdGlwbGUgc2V0cyBvZiBkYXRhLiBUaGlzIHNob3VsZFxyXG4gICAgICAgIC8vIHJlYWxseSBvbmx5IG5lZWQgdG8gbG9vcCBvbmNlIGZvciBpID0gMCBidXQgbG9vcCBqdXN0XHJcbiAgICAgICAgLy8gaW4gY2FzZS5cclxuICAgICAgICBmb3IobGV0IGkgPSBwYXJlbnRFbGVtZW50LmNoaWxkcmVuLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XHJcbiAgICAgICAgICAgIHBhcmVudEVsZW1lbnQuY2hpbGRyZW5baV0uZGV0YWNoKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHBhcmVudEVsZW1lbnQuYXBwZW5kQ2hpbGQobWFya2Rvd25SZW5kZXJDaGlsZC5jb250YWluZXJFbCk7XHJcblxyXG4gICAgICAgIGxldCBjb2x1bW5JbmRleCA9IDA7XHJcbiAgICAgICAgZm9yKGxldCBpID0gMDsgaSA8IHJlZ2lvbkVsZW1lbnRzLmxlbmd0aDsgaSsrKSB7XHJcblxyXG4gICAgICAgICAgICBpZiAocmVnaW9uRWxlbWVudHNbaV0udGFnICE9PSBET01PYmplY3RUYWcuc3RhcnRSZWdpb24gICAgfHxcclxuICAgICAgICAgICAgICAgIHJlZ2lvbkVsZW1lbnRzW2ldLnRhZyAhPT0gRE9NT2JqZWN0VGFnLnJlZ2lvblNldHRpbmdzIHx8XHJcbiAgICAgICAgICAgICAgICByZWdpb25FbGVtZW50c1tpXS50YWcgIT09IERPTU9iamVjdFRhZy5lbmRSZWdpb24gICAgICB8fFxyXG4gICAgICAgICAgICAgICAgcmVnaW9uRWxlbWVudHNbaV0udGFnICE9PSBET01PYmplY3RUYWcuY29sdW1uQnJlYWsgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gV2Ugc3RvcmUgdGhlIGVsZW1lbnRzIGluIGEgd3JhcHBlciBjb250YWluZXIgdW50aWwgd2UgZGV0ZXJtaW5lXHJcbiAgICAgICAgICAgICAgICBsZXQgZWxlbWVudCA9IGNyZWF0ZURpdih7XHJcbiAgICAgICAgICAgICAgICAgICAgY2xzOiBNdWx0aUNvbHVtbkxheW91dENTUy5Db2x1bW5EdWFsRWxlbWVudENvbnRhaW5lcixcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgcmVnaW9uRWxlbWVudHNbaV0uZWxlbWVudENvbnRhaW5lciA9IGVsZW1lbnQ7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gT3RoZXJ3aXNlIHdlIGp1c3QgbWFrZSBhIGNvcHkgb2YgdGhlIG9yaWdpbmFsIGVsZW1lbnQgdG8gZGlzcGxheS5cclxuICAgICAgICAgICAgICAgIGxldCBjbG9uZWRFbGVtZW50ID0gcmVnaW9uRWxlbWVudHNbaV0ub3JpZ2luYWxFbGVtZW50LmNsb25lTm9kZSh0cnVlKSBhcyBIVE1MRGl2RWxlbWVudDtcclxuICAgICAgICAgICAgICAgIHJlZ2lvbkVsZW1lbnRzW2ldLmNsb25lZEVsZW1lbnQgPSBjbG9uZWRFbGVtZW50O1xyXG4gICAgICAgICAgICAgICAgZWxlbWVudC5hcHBlbmRDaGlsZChjbG9uZWRFbGVtZW50KTtcclxuXHJcbiAgICAgICAgICAgICAgICBpZihyZWdpb25FbGVtZW50c1tpXSBpbnN0YW5jZW9mIFRhc2tMaXN0RE9NT2JqZWN0KSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZml4Q2xvbmVkQ2hlY2tMaXN0QnV0dG9ucyhyZWdpb25FbGVtZW50c1tpXSBhcyBUYXNrTGlzdERPTU9iamVjdCwgdHJ1ZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgaWYoZWxlbWVudCAhPT0gbnVsbCkge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBjb2x1bW5Db250ZW50RGl2c1tjb2x1bW5JbmRleF0uYXBwZW5kQ2hpbGQoZWxlbWVudCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBJZiB0aGUgdGFnIGlzIGEgY29sdW1uIGJyZWFrIHdlIHVwZGF0ZSB0aGUgY29sdW1uIGluZGV4IGFmdGVyXHJcbiAgICAgICAgICAgICAgICAgKiBhcHBlbmRpbmcgdGhlIGl0ZW0gdG8gdGhlIGNvbHVtbiBkaXYuIFRoaXMga2VlcHMgdGhlIG1haW4gRE9NXHJcbiAgICAgICAgICAgICAgICAgKiBjbGVhbmVyIGJ5IHJlbW92aW5nIG90aGVyIGl0ZW1zIGFuZCBwbGFjaW5nIHRoZW0gYWxsIHdpdGhpblxyXG4gICAgICAgICAgICAgICAgICogYSByZWdpb24gY29udGFpbmVyLlxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICBpZihyZWdpb25FbGVtZW50c1tpXS50YWcgPT09IERPTU9iamVjdFRhZy5jb2x1bW5CcmVhayAmJiBcclxuICAgICAgICAgICAgICAgICAgIChjb2x1bW5JbmRleCArIDEpIDwgc2V0dGluZ3MubnVtYmVyT2ZDb2x1bW5zKSB7XHJcbiAgICAgXHJcbiAgICAgICAgICAgICAgICAgICAgIGNvbHVtbkluZGV4Kys7XHJcbiAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhpcyBmdW5jdGlvbiB0YWtlcyBpbiB0aGUgb3JpZ2luYWwgZWxlbWVudCBhbmQgaXRzIGNsb25lIGFuZCBjaGVja3MgaWZcclxuICAgICAqIHRoZSBlbGVtZW50IGNvbnRhaW5zIGEgdGFzay1saXN0LWl0ZW0gY2xhc3MuIElmIHNvIGl0IGxvb3BzIHRocm91Z2ggYWxsXHJcbiAgICAgKiBpdGVtcyBpbiB0aGUgbGlzdCBhbmQgZml4ZXMgdGhlaXIgY2hlY2tib3hlcyB0byBwcm9wZXJseSBmaXJlIGFuIGV2ZW50LlxyXG4gICAgICogVGhlIG5ldyBjaGVja2JveCBjYWxscyB0aGUgY2xpY2sgZnVuY3Rpb24gb24gdGhlIG9yaWdpbmFsIGNoZWNrYm94IHNvIFxyXG4gICAgICogY29tcGF0YWJpbGl0eSB3aXRoIG90aGVyIHBsdWdpbnMgKnNob3VsZCogcmVtYWluLlxyXG4gICAgICogQHBhcmFtIGRvbUVsZW1lbnQgXHJcbiAgICAgKiBAcGFyYW0gaW5pdGFsaXplQ2hlY2tib3hlcyBcclxuICAgICAqL1xyXG4gICAgZml4Q2xvbmVkQ2hlY2tMaXN0QnV0dG9ucyhkb21FbGVtZW50OiBUYXNrTGlzdERPTU9iamVjdCwgaW5pdGFsaXplQ2hlY2tib3hlczogYm9vbGVhbiA9IGZhbHNlKSB7XHJcblxyXG4gICAgICAgIGxldCBlbGVtZW50OiBIVE1MRWxlbWVudCA9IGRvbUVsZW1lbnQub3JpZ2luYWxFbGVtZW50XHJcbiAgICAgICAgbGV0IGNsb25lZEVsZW1lbnQ6IEhUTUxFbGVtZW50ID0gZG9tRWxlbWVudC5jbG9uZWRFbGVtZW50O1xyXG5cclxuICAgICAgICBsZXQgY2xvbmVkTGlzdENoZWNrYm94ZXMgPSBBcnJheS5mcm9tKGNsb25lZEVsZW1lbnQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZShcInRhc2stbGlzdC1pdGVtXCIpKSBhcyBIVE1MRWxlbWVudFtdO1xyXG4gICAgICAgIGxldCBvcmlnaW5hbExpc3RDaGVja2JveGVzID0gQXJyYXkuZnJvbShlbGVtZW50LmdldEVsZW1lbnRzQnlDbGFzc05hbWUoXCJ0YXNrLWxpc3QtaXRlbVwiKSkgYXMgSFRNTEVsZW1lbnRbXTtcclxuICAgICAgICBcclxuICAgICAgICBpZihpbml0YWxpemVDaGVja2JveGVzID09PSB0cnVlKSB7XHJcblxyXG4gICAgICAgICAgICAvLyBXaGVuIHdlIGluaXRhbGl6ZSB3ZSByZW1vdmUgdGhlIG9sZCBpbnB1dCBjaGVja2JveCB0aGF0IGNvbnRhaW5zXHJcbiAgICAgICAgICAgIC8vIHRoZSB3ZWlyZCBjYWxsYmFjayBzaXR1YXRpb24gY2F1c2luZyB0aGUgYnVnLiBUaGVuIHdlIGNyZWF0ZSBhIG5ld1xyXG4gICAgICAgICAgICAvLyBjaGVja2JveCB0byByZXBsYWNlIGl0IGFuZCBzZXQgaXQgdXAgdG8gZmlyZSB0aGUgY2xpY2sgZXZlbnQgb25cclxuICAgICAgICAgICAgLy8gdGhlIG9yaWdpbmFsIGNoZWNrYm94IHNvIGZ1bmN0aW9uYWxpdHkgaXMgcmVzdG9yZWQuXHJcbiAgICAgICAgICAgIGZvcihsZXQgaSA9IDA7IGkgPCBvcmlnaW5hbExpc3RDaGVja2JveGVzLmxlbmd0aDsgaSsrKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgY29uc3QgY2hlY2tib3ggPSBjcmVhdGVFbCgnaW5wdXQnKTtcclxuXHJcbiAgICAgICAgICAgICAgICBsZXQgb3JpZ2luYWxJbnB1dCA9IG9yaWdpbmFsTGlzdENoZWNrYm94ZXNbaV0uZmlyc3RDaGlsZCBhcyBIVE1MSW5wdXRFbGVtZW50XHJcblxyXG4gICAgICAgICAgICAgICAgY2hlY2tib3guY2hlY2tlZCA9IG9yaWdpbmFsSW5wdXQuY2hlY2tlZDtcclxuICAgICAgICAgICAgICAgIGNsb25lZExpc3RDaGVja2JveGVzW2ldLnJlcGxhY2VDaGlsZChjaGVja2JveCwgY2xvbmVkTGlzdENoZWNrYm94ZXNbaV0uY2hpbGRyZW5bMF0pO1xyXG4gICAgICAgICAgICAgICAgY2hlY2tib3guYWRkQ2xhc3MoJ3Rhc2stbGlzdC1pdGVtLWNoZWNrYm94Jyk7XHJcbiAgICAgICAgICAgICAgICBjaGVja2JveC50eXBlID0gJ2NoZWNrYm94JztcclxuICAgICAgICAgICAgICAgIGNoZWNrYm94Lm9uQ2xpY2tFdmVudCgoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgZG9tRWxlbWVudC5jaGVja2JveENsaWNrZWQoaSlcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG5cclxuICAgICAgICAgICAgLy8gV2hlbmV2ZXIgd2UgcmVhY2ggdGhpcyBwb2ludCB3ZSB1cGRhdGUgb3VyIGxpc3Qgb2Ygb3JpZ2luYWwgY2hlY2tib3hlc1xyXG4gICAgICAgICAgICAvLyB0aGF0IG1heSBiZSBkaWZmZXJlbnQgZnJvbSBvdXIgY2FjaGUuIFRoaXMgaXMgZHVlIHRvIGhvdyBvYnNpZGlhblxyXG4gICAgICAgICAgICAvLyBjaGFuZ2VzIHRoZSBET00gdW5kZXJuZWF0aCB1cyBzbyB3ZSBuZWVkIHRvIGNvbnN0YW50bHkgdXBkYXRlIG91ciBjYWNoZS5cclxuICAgICAgICAgICAgZG9tRWxlbWVudC5vcmlnaW5hbENoZWNrYm94ZXMgPSBvcmlnaW5hbExpc3RDaGVja2JveGVzO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gV2hlbiB0aGUgVGFza3MgcGx1Z2luIGlzIGluc3RhbGxlZCB0aGUgY2xvbmVkIGNvcHkgb2YgdGhlIG9yaWdpbmFsIGVsZW1lbnQgY29udGFpbnNcclxuICAgICAgICAvLyBhbiBleHRyYSBlbGVtZW50IGZvciBzb21lIHJlYXNvbi4gSWYgdGhpcyBvY2N1cnMgZm9yIG90aGVyIHJlYXNvbnMgaGVyZSB3ZSBhZGp1c3RcclxuICAgICAgICAvLyB0aGF0IHRvIGtlZXAgdGhlIGNsb25lIHRoZSBzYW1lIGFzIHRoZSBvcmlnaW5hbC5cclxuICAgICAgICBpZihjbG9uZWRMaXN0Q2hlY2tib3hlcy5sZW5ndGggPiBvcmlnaW5hbExpc3RDaGVja2JveGVzLmxlbmd0aCkge1xyXG5cclxuICAgICAgICAgICAgZm9yKGxldCBpID0gb3JpZ2luYWxMaXN0Q2hlY2tib3hlcy5sZW5ndGg7IGkgPCBjbG9uZWRMaXN0Q2hlY2tib3hlcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICBkb21FbGVtZW50LmNsb25lZEVsZW1lbnQucmVtb3ZlQ2hpbGQoY2xvbmVkTGlzdENoZWNrYm94ZXNbaV0pXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgY2hlY2tTcGVjaWFsRWxlbWVudChkb21FbGVtZW50OiBET01PYmplY3QpIHtcclxuXHJcbiAgICAgICAgaWYoZG9tRWxlbWVudC5vcmlnaW5hbEVsZW1lbnQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZShcInRhc2stbGlzdC1pdGVtXCIpLmxlbmd0aCA+IDAgKSB7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gbmV3IFRhc2tMaXN0RE9NT2JqZWN0KGRvbUVsZW1lbnQpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIGRvbUVsZW1lbnQ7XHJcbiAgICB9XHJcblxyXG4gICAgc2V0VXBEdWFsUmVuZGVyKGRvbUVsZW1lbnQ6IERPTU9iamVjdCkge1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBJZiBvdXIgZWxlbWVudCBpcyBvZiBcInNwZWNpYWxSZW5kZXJcIiB0eXBlIGl0ICptYXkqIG5lZWQgdG8gYmUgcmVuZGVyZWRcclxuICAgICAgICAgKiB1c2luZyB0aGUgb3JpZ2luYWwgZWxlbWVudCByYXRoZXIgdGhhbiBhIGNvcHkuIEZvciBleGFtcGxlLCBhbiBlbGVtZW50XHJcbiAgICAgICAgICogbWF5IGhhdmUgYW4gb25DbGljayBldmVudCB0aGF0IHdvdWxkIG5vdCBnZXQgY29wcGllZCB0byB0aGUgY2xvbmUuXHJcbiAgICAgICAgICogXHJcbiAgICAgICAgICogSWYgd2UganVzdCBtb3ZlZCB0aGVzZSBlbGVtZW50cyBpbnRvIHRoZSByZWdpb24gaXQgd291bGQgZ2V0IFxyXG4gICAgICAgICAqIG1vdmVkIGJhY2sgb3V0IGludG8gdGhlIG9yaWdpbmFsIGxvY2F0aW9uIGluIHRoZSBET00gYnkgb2JzaWRpYW5cclxuICAgICAgICAgKiB3aGVuIHNjcm9sbGluZyBvciB3aGVuIHRoZSBmaWxlIGlzIHVwZGF0ZWQuIE9uIHRoZSBuZXh0IHJlZnJlc2ggaXRcclxuICAgICAgICAgKiB3b3VsZCBiZSBtb3ZlZCBiYWNrIGJ1dCB0aGF0IGNhbiBsZWFkIHRvIGEgcmVnaW9uIGp1bXBpbmdcclxuICAgICAgICAgKiBhcm91bmQgYXMgdGhlIGl0ZW0gaXMgbW92ZWQgaW4gYW5kIG91dC4gXHJcbiAgICAgICAgICogXHJcbiAgICAgICAgICogSGVyZSB3ZSBzZXQgdXAgdGhlIGRpdiB0byBjb250YWluIHRoZSBlbGVtZW50IGFuZCBjcmVhdGVcclxuICAgICAgICAgKiBhIHZpc3VhbCBvbmx5IGNsb25lIG9mIGl0LiBUaGUgY2xvbmUgd2lsbCBvbmx5IGJlIHZpc2libGVcclxuICAgICAgICAgKiB3aGVuIHRoZSBvcmlnaW5hbCBpcyBub3QgaW4gdGhlIG11bHRpLWNvbHVtbiByZWdpb24gc28gaXRcclxuICAgICAgICAgKiBzYXZlcyB1cyBmcm9tIHRoZSB2aXN1YWwgbm9pc2Ugb2YgdGhlIHJlZ2lvbiBqdW1waW5nIGFyb3VuZC5cclxuICAgICAgICAgKi9cclxuXHJcbiAgICAgICAgLy8gUmVtb3ZlIHRoZSBvbGQgZWxlbWVudHMgYmVmb3JlIHdlIHNldCB1cCB0aGUgZHVhbCByZW5kZXJlZCBlbGVtZW50cy5cclxuICAgICAgICBsZXQgY29udGFpbmVyRWxlbWVudDogSFRNTERpdkVsZW1lbnQgPSBkb21FbGVtZW50LmVsZW1lbnRDb250YWluZXJcclxuICAgICAgICBsZXQgcmVuZGVyRWxlbWVudDogSFRNTERpdkVsZW1lbnQgPSBkb21FbGVtZW50Lm9yaWdpbmFsRWxlbWVudCBhcyBIVE1MRGl2RWxlbWVudFxyXG4gICAgICAgIGZvcihsZXQgaSA9IGNvbnRhaW5lckVsZW1lbnQuY2hpbGRyZW4ubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcclxuICAgICAgICAgICAgY29udGFpbmVyRWxlbWVudC5jaGlsZHJlbltpXS5kZXRhY2goKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGNvbnRhaW5lckVsZW1lbnQuYXBwZW5kQ2hpbGQocmVuZGVyRWxlbWVudCkgICAgICAgICAgICAgICAgICAgIFxyXG4gICAgICAgIHJlbmRlckVsZW1lbnQuYWRkQ2xhc3MoTXVsdGlDb2x1bW5MYXlvdXRDU1MuT3JpZ2luYWxFbGVtZW50VHlwZSlcclxuXHJcbiAgICAgICAgbGV0IGNsb25lZE5vZGUgPSByZW5kZXJFbGVtZW50LmNsb25lTm9kZSh0cnVlKSBhcyBIVE1MRGl2RWxlbWVudDtcclxuICAgICAgICBjbG9uZWROb2RlLmFkZENsYXNzKE11bHRpQ29sdW1uTGF5b3V0Q1NTLkNsb25lZEVsZW1lbnRUeXBlKVxyXG4gICAgICAgIGNsb25lZE5vZGUucmVtb3ZlQ2xhc3NlcyhbTXVsdGlDb2x1bW5TdHlsZUNTUy5SZWdpb25Db250ZW50LCBNdWx0aUNvbHVtbkxheW91dENTUy5PcmlnaW5hbEVsZW1lbnRUeXBlXSlcclxuICAgICAgICBjb250YWluZXJFbGVtZW50LmFwcGVuZENoaWxkKGNsb25lZE5vZGUpO1xyXG4gICAgfVxyXG5cclxuICAgIHVwZGF0ZVJlbmRlcmVkTWFya2Rvd24ocmVnaW9uRWxlbWVudHM6IERPTU9iamVjdFtdKSB7XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRoaXMgZnVuY3Rpb24gYWN0cyBhcyB0aGUgdXBkYXRlIGxvb3AgZm9yIHRoZSBtdWx0aS1jb2x1bW4gcmVnaW9ucy5cclxuICAgICAgICAgKiBIZXJlIHdlIGxvb3AgdGhyb3VnaCBhbGwgb2YgdGhlIGVsZW1lbnRzIHdpdGhpbiB0aGUgcmVuZGVyZWQgcmVnaW9uIGFuZCBcclxuICAgICAgICAgKiBwb3RlbnRpYWxseSB1cGRhdGUgaG93IHRoaW5ncyBhcmUgcmVuZGVyZWQuIFdlIG5lZWQgdG8gZG8gdGhpcyBmb3JcclxuICAgICAgICAgKiBjb21wYXRhYmlsaXR5IHdpdGggb3RoZXIgcGx1Z2lucy4gXHJcbiAgICAgICAgICogXHJcbiAgICAgICAgICogSWYgdGhlIG11bHRpLWNvbHVtbiByZWdpb24gaXMgcmVuZGVyZWQgYmVmb3JlIG90aGVyIHBsdWdpbnMgdGhhdCBlZmZlY3RcclxuICAgICAgICAgKiBjb250ZW50IHdpdGhpbiB0aGUgcmVnaW9uIG91ciByZW5kZXJlZCBkYXRhIG1heSBub3QgcHJvcGVybHkgZGlzcGxheVxyXG4gICAgICAgICAqIHRoZSBjb250ZW50IGZyb20gdGhlIG90aGVyIHBsdWdpbi4gSGVyZSB3ZSBsb29wIHRocm91Z2ggdGhlIGVsZW1lbnRzIFxyXG4gICAgICAgICAqIGFmdGVyIGFsbCBwbHVnaW5zIGhhdmUgaGFkIGEgY2hhbmNlIHRvIHJ1biBhbmQgY2FuIG1ha2UgY2hhbmdlcyB0byB0aGVcclxuICAgICAgICAgKiBET00gYXQgdGhpcyBwb2ludC5cclxuICAgICAgICAgKi9cclxuICAgICAgICBmb3IobGV0IGkgPSAwOyBpIDwgcmVnaW9uRWxlbWVudHMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBIZXJlIHdlIGNoZWNrIGZvciBzcGVjaWFsIGNhc2VzIFxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgaWYocmVnaW9uRWxlbWVudHNbaV0gaW5zdGFuY2VvZiBUYXNrTGlzdERPTU9iamVjdCkge1xyXG5cclxuICAgICAgICAgICAgICAgIHRoaXMuZml4Q2xvbmVkQ2hlY2tMaXN0QnV0dG9ucyhyZWdpb25FbGVtZW50c1tpXSBhcyBUYXNrTGlzdERPTU9iamVjdCk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcblxyXG4gICAgICAgICAgICBsZXQgZWxlbWVudFR5cGUgPSByZWdpb25FbGVtZW50c1tpXS5lbGVtZW50VHlwZTtcclxuXHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBJZiB0aGUgZWxlbWVudCBpcyBub3QgY3VycmVudGx5IGEgc3BlY2lhbCByZW5kZXIgZWxlbWVudCB3ZSBjaGVjayBhZ2FpblxyXG4gICAgICAgICAgICAgKiBhcyB0aGUgb3JpZ2luYWwgZWxlbWVudCBtYXkgaGF2ZSBiZWVuIHVwZGF0ZWQuXHJcbiAgICAgICAgICAgICAqIFxyXG4gICAgICAgICAgICAgKiBUT0RPOiBmaW5kIGEgd2F5IHRvIFwiT2ZmaWNpYWxseVwiIG1hcmsgbm9ybWFsIGVsZW1lbnRzIHJhdGhlciB0aGFuXHJcbiAgICAgICAgICAgICAqIGNvbnRpbnVvdXNseSBzZWFyY2ggZm9yIHNwZWNpYWwgcmVuZGVyIHR5cGVzLlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgaWYoZWxlbWVudFR5cGUgIT09IEVsZW1lbnRSZW5kZXJUeXBlLnNwZWNpYWxSZW5kZXIpIHtcclxuICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgLy8gSWYgdGhlIG5ldyByZXN1bHQgcmV0dXJucyBhcyBhIHNwZWNpYWwgcmVuZGVyZXIgd2UgdXBkYXRlIHNvXHJcbiAgICAgICAgICAgICAgICAvLyB0aGlzIHdvbnQgcnVuIGFnYWluIGZvciB0aGlzIGl0ZW0uXHJcbiAgICAgICAgICAgICAgICBlbGVtZW50VHlwZSA9IGdldEVsZW1lbnRSZW5kZXJUeXBlKHJlZ2lvbkVsZW1lbnRzW2ldLm9yaWdpbmFsRWxlbWVudCk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmKGVsZW1lbnRUeXBlID09PSBFbGVtZW50UmVuZGVyVHlwZS5zcGVjaWFsUmVuZGVyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICByZWdpb25FbGVtZW50c1tpXS5lbGVtZW50VHlwZSA9IGVsZW1lbnRUeXBlO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zZXRVcER1YWxSZW5kZXIocmVnaW9uRWxlbWVudHNbaV0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuXHJcbiAgICBjaGVja0V4cG9ydGluZyhlbGVtZW50OiBIVE1MRWxlbWVudCk6IGJvb2xlYW4ge1xyXG5cclxuICAgICAgICBpZihlbGVtZW50ID09PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmKGVsZW1lbnQuY2xhc3NMaXN0LmNvbnRhaW5zKFwicHJpbnRcIikpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZihlbGVtZW50LnBhcmVudE5vZGUgIT09IG51bGwpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2hlY2tFeHBvcnRpbmcoZWxlbWVudC5wYXJlbnRFbGVtZW50KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIFNldHMgdXAgdGhlIENTUyBjbGFzc2VzIGFuZCB0aGUgbnVtYmVyIG9mIGNvbHVtbnMgYmFzZWQgb24gdGhlIHBhc3NlZCBzZXR0aW5ncy5cclxuICogQHBhcmFtIHNldHRpbmdzIFRoZSB1c2VyIGRlZmluZWQgc2V0dGluZ3MgdGhhdCBkZXRlcm1pbmUgd2hhdCBDU1MgaXMgc2V0IGhlcmUuXHJcbiAqIEBwYXJhbSBtdWx0aUNvbHVtblBhcmVudCBUaGUgcGFyZW50IG9iamVjdCB0aGF0IHRoZSBjb2x1bW4gZGl2cyB3aWxsIGJlIGNyZWF0ZWQgdW5kZXIuXHJcbiAqIEByZXR1cm5zIFRoZSBsaXN0IG9mIGNvbHVtbiBkaXZzIGNyZWF0ZWQgdW5kZXIgdGhlIHBhc3NlZCBwYXJlbnQgZWxlbWVudC5cclxuICovXHJcbmZ1bmN0aW9uIGdldENvbHVtbkNvbnRlbnREaXZzKHNldHRpbmdzOiBNdWx0aUNvbHVtblNldHRpbmdzLCBtdWx0aUNvbHVtblBhcmVudDogSFRNTERpdkVsZW1lbnQpOiBIVE1MRGl2RWxlbWVudFtdIHtcclxuXHJcbiAgICBsZXQgY29sdW1uQ29udGVudERpdnM6IEhUTUxEaXZFbGVtZW50W10gPSBbXVxyXG4gICAgaWYoc2V0dGluZ3MubnVtYmVyT2ZDb2x1bW5zID09PSAyKSB7XHJcblxyXG4gICAgICAgIHN3aXRjaChzZXR0aW5ncy5jb2x1bW5MYXlvdXQpIHtcclxuICAgICAgICAgICAgY2FzZShDb2x1bW5MYXlvdXQuc3RhbmRhcmQpOlxyXG4gICAgICAgICAgICBjYXNlKENvbHVtbkxheW91dC5taWRkbGUpOlxyXG4gICAgICAgICAgICBjYXNlKENvbHVtbkxheW91dC5jZW50ZXIpOlxyXG4gICAgICAgICAgICBjYXNlKENvbHVtbkxheW91dC50aGlyZCk6XHJcbiAgICAgICAgICAgICAgICBjb2x1bW5Db250ZW50RGl2cy5wdXNoKG11bHRpQ29sdW1uUGFyZW50LmNyZWF0ZURpdih7XHJcbiAgICAgICAgICAgICAgICAgICAgY2xzOiBgY29sdW1uQ29udGVudCB0d29FcXVhbENvbHVtbnNfTGVmdGBcclxuICAgICAgICAgICAgICAgIH0pKTtcclxuICAgICAgICAgICAgICAgIGNvbHVtbkNvbnRlbnREaXZzLnB1c2gobXVsdGlDb2x1bW5QYXJlbnQuY3JlYXRlRGl2KHtcclxuICAgICAgICAgICAgICAgICAgICBjbHM6IGBjb2x1bW5Db250ZW50IHR3b0VxdWFsQ29sdW1uc19SaWdodGBcclxuICAgICAgICAgICAgICAgIH0pKTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICAgICAgY2FzZShDb2x1bW5MYXlvdXQubGVmdCk6XHJcbiAgICAgICAgICAgIGNhc2UoQ29sdW1uTGF5b3V0LmZpcnN0KTpcclxuICAgICAgICAgICAgICAgIGNvbHVtbkNvbnRlbnREaXZzLnB1c2gobXVsdGlDb2x1bW5QYXJlbnQuY3JlYXRlRGl2KHtcclxuICAgICAgICAgICAgICAgICAgICBjbHM6IGBjb2x1bW5Db250ZW50IHR3b0NvbHVtbnNIZWF2eUxlZnRfTGVmdGBcclxuICAgICAgICAgICAgICAgIH0pKTtcclxuICAgICAgICAgICAgICAgIGNvbHVtbkNvbnRlbnREaXZzLnB1c2gobXVsdGlDb2x1bW5QYXJlbnQuY3JlYXRlRGl2KHtcclxuICAgICAgICAgICAgICAgICAgICBjbHM6IGBjb2x1bW5Db250ZW50IHR3b0NvbHVtbnNIZWF2eUxlZnRfUmlnaHRgXHJcbiAgICAgICAgICAgICAgICB9KSk7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgICAgIGNhc2UoQ29sdW1uTGF5b3V0LnJpZ2h0KTpcclxuICAgICAgICAgICAgY2FzZShDb2x1bW5MYXlvdXQuc2Vjb25kKTpcclxuICAgICAgICAgICAgY2FzZShDb2x1bW5MYXlvdXQubGFzdCk6XHJcbiAgICAgICAgICAgICAgICBjb2x1bW5Db250ZW50RGl2cy5wdXNoKG11bHRpQ29sdW1uUGFyZW50LmNyZWF0ZURpdih7XHJcbiAgICAgICAgICAgICAgICAgICAgY2xzOiBgY29sdW1uQ29udGVudCB0d29Db2x1bW5zSGVhdnlSaWdodF9MZWZ0YFxyXG4gICAgICAgICAgICAgICAgfSkpO1xyXG4gICAgICAgICAgICAgICAgY29sdW1uQ29udGVudERpdnMucHVzaChtdWx0aUNvbHVtblBhcmVudC5jcmVhdGVEaXYoe1xyXG4gICAgICAgICAgICAgICAgICAgIGNsczogYGNvbHVtbkNvbnRlbnQgdHdvQ29sdW1uc0hlYXZ5UmlnaHRfUmlnaHRgXHJcbiAgICAgICAgICAgICAgICB9KSk7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmKHNldHRpbmdzLm51bWJlck9mQ29sdW1ucyA9PT0gMykge1xyXG5cclxuICAgICAgICBzd2l0Y2goc2V0dGluZ3MuY29sdW1uTGF5b3V0KSB7XHJcbiAgICAgICAgICAgIGNhc2UoQ29sdW1uTGF5b3V0LnN0YW5kYXJkKTpcclxuICAgICAgICAgICAgICAgIGNvbHVtbkNvbnRlbnREaXZzLnB1c2gobXVsdGlDb2x1bW5QYXJlbnQuY3JlYXRlRGl2KHtcclxuICAgICAgICAgICAgICAgICAgICBjbHM6IGBjb2x1bW5Db250ZW50IHRocmVlRXF1YWxDb2x1bW5zX0xlZnRgXHJcbiAgICAgICAgICAgICAgICB9KSk7XHJcbiAgICAgICAgICAgICAgICBjb2x1bW5Db250ZW50RGl2cy5wdXNoKG11bHRpQ29sdW1uUGFyZW50LmNyZWF0ZURpdih7XHJcbiAgICAgICAgICAgICAgICAgICAgY2xzOiBgY29sdW1uQ29udGVudCB0aHJlZUVxdWFsQ29sdW1uc19NaWRkbGVgXHJcbiAgICAgICAgICAgICAgICB9KSk7XHJcbiAgICAgICAgICAgICAgICBjb2x1bW5Db250ZW50RGl2cy5wdXNoKG11bHRpQ29sdW1uUGFyZW50LmNyZWF0ZURpdih7XHJcbiAgICAgICAgICAgICAgICAgICAgY2xzOiBgY29sdW1uQ29udGVudCB0aHJlZUVxdWFsQ29sdW1uc19SaWdodGBcclxuICAgICAgICAgICAgICAgIH0pKTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICAgICAgY2FzZShDb2x1bW5MYXlvdXQubGVmdCk6XHJcbiAgICAgICAgICAgIGNhc2UoQ29sdW1uTGF5b3V0LmZpcnN0KTpcclxuICAgICAgICAgICAgICAgIGNvbHVtbkNvbnRlbnREaXZzLnB1c2gobXVsdGlDb2x1bW5QYXJlbnQuY3JlYXRlRGl2KHtcclxuICAgICAgICAgICAgICAgICAgICBjbHM6IGBjb2x1bW5Db250ZW50IHRocmVDb2x1bW5zSGVhdnlMZWZ0X0xlZnRgXHJcbiAgICAgICAgICAgICAgICB9KSk7XHJcbiAgICAgICAgICAgICAgICBjb2x1bW5Db250ZW50RGl2cy5wdXNoKG11bHRpQ29sdW1uUGFyZW50LmNyZWF0ZURpdih7XHJcbiAgICAgICAgICAgICAgICAgICAgY2xzOiBgY29sdW1uQ29udGVudCB0aHJlQ29sdW1uc0hlYXZ5TGVmdF9NaWRkbGVgXHJcbiAgICAgICAgICAgICAgICB9KSk7XHJcbiAgICAgICAgICAgICAgICBjb2x1bW5Db250ZW50RGl2cy5wdXNoKG11bHRpQ29sdW1uUGFyZW50LmNyZWF0ZURpdih7XHJcbiAgICAgICAgICAgICAgICAgICAgY2xzOiBgY29sdW1uQ29udGVudCB0aHJlQ29sdW1uc0hlYXZ5TGVmdF9SaWdodGBcclxuICAgICAgICAgICAgICAgIH0pKTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICAgICAgY2FzZShDb2x1bW5MYXlvdXQubWlkZGxlKTpcclxuICAgICAgICAgICAgY2FzZShDb2x1bW5MYXlvdXQuY2VudGVyKTpcclxuICAgICAgICAgICAgY2FzZShDb2x1bW5MYXlvdXQuc2Vjb25kKTpcclxuICAgICAgICAgICAgICAgIGNvbHVtbkNvbnRlbnREaXZzLnB1c2gobXVsdGlDb2x1bW5QYXJlbnQuY3JlYXRlRGl2KHtcclxuICAgICAgICAgICAgICAgICAgICBjbHM6IGBjb2x1bW5Db250ZW50IHRocmVDb2x1bW5zSGVhdnlNaWRkbGVfTGVmdGBcclxuICAgICAgICAgICAgICAgIH0pKTtcclxuICAgICAgICAgICAgICAgIGNvbHVtbkNvbnRlbnREaXZzLnB1c2gobXVsdGlDb2x1bW5QYXJlbnQuY3JlYXRlRGl2KHtcclxuICAgICAgICAgICAgICAgICAgICBjbHM6IGBjb2x1bW5Db250ZW50IHRocmVDb2x1bW5zSGVhdnlNaWRkbGVfTWlkZGxlYFxyXG4gICAgICAgICAgICAgICAgfSkpO1xyXG4gICAgICAgICAgICAgICAgY29sdW1uQ29udGVudERpdnMucHVzaChtdWx0aUNvbHVtblBhcmVudC5jcmVhdGVEaXYoe1xyXG4gICAgICAgICAgICAgICAgICAgIGNsczogYGNvbHVtbkNvbnRlbnQgdGhyZUNvbHVtbnNIZWF2eU1pZGRsZV9SaWdodGBcclxuICAgICAgICAgICAgICAgIH0pKTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICAgICAgY2FzZShDb2x1bW5MYXlvdXQucmlnaHQpOlxyXG4gICAgICAgICAgICBjYXNlKENvbHVtbkxheW91dC50aGlyZCk6XHJcbiAgICAgICAgICAgIGNhc2UoQ29sdW1uTGF5b3V0Lmxhc3QpOlxyXG4gICAgICAgICAgICAgICAgY29sdW1uQ29udGVudERpdnMucHVzaChtdWx0aUNvbHVtblBhcmVudC5jcmVhdGVEaXYoe1xyXG4gICAgICAgICAgICAgICAgICAgIGNsczogYGNvbHVtbkNvbnRlbnQgdGhyZUNvbHVtbnNIZWF2eVJpZ2h0X0xlZnRgXHJcbiAgICAgICAgICAgICAgICB9KSk7XHJcbiAgICAgICAgICAgICAgICBjb2x1bW5Db250ZW50RGl2cy5wdXNoKG11bHRpQ29sdW1uUGFyZW50LmNyZWF0ZURpdih7XHJcbiAgICAgICAgICAgICAgICAgICAgY2xzOiBgY29sdW1uQ29udGVudCB0aHJlQ29sdW1uc0hlYXZ5UmlnaHRfTWlkZGxlYFxyXG4gICAgICAgICAgICAgICAgfSkpO1xyXG4gICAgICAgICAgICAgICAgY29sdW1uQ29udGVudERpdnMucHVzaChtdWx0aUNvbHVtblBhcmVudC5jcmVhdGVEaXYoe1xyXG4gICAgICAgICAgICAgICAgICAgIGNsczogYGNvbHVtbkNvbnRlbnQgdGhyZUNvbHVtbnNIZWF2eVJpZ2h0X1JpZ2h0YFxyXG4gICAgICAgICAgICAgICAgfSkpO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBjb2x1bW5Db250ZW50RGl2cztcclxufVxyXG5cclxuXHJcbmV4cG9ydCB0eXBlIG5lYXJieVNpYmxpbmdzID0geyBcclxuICAgIHNpYmxpbmdzQWJvdmU6IEhUTUxEaXZFbGVtZW50LFxyXG4gICAgY3VycmVudE9iamVjdDogRE9NT2JqZWN0LCBcclxufVxyXG5mdW5jdGlvbiByZW5kZXJNYXJrZG93bkZyb21MaW5lcyhtZExpbmVzOiBzdHJpbmdbXSwgc291cmNlUGF0aDogc3RyaW5nKTogSFRNTERpdkVsZW1lbnQge1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogV2UgcmUtcmVuZGVyIGFsbCBvZiB0aGUgaXRlbXMgYWJvdmUgb3VyIGVsZW1lbnQsIHVudGlsIHRoZSBzdGFydCB0YWcsIFxyXG4gICAgICogc28gd2UgY2FuIGRldGVybWluZSB3aGVyZSB0byBwbGFjZSB0aGUgbmV3IGl0ZW0gaW4gdGhlIG1hbmFnZXIuXHJcbiAgICAgKiBcclxuICAgICAqIFRPRE86IENhbiByZWR1Y2UgdGhlIGFtb3VudCBuZWVkaW5nIHRvIGJlIHJlbmRlcmVkIGJ5IG9ubHkgcmVuZGVyaW5nIHRvXHJcbiAgICAgKiB0aGUgc3RhcnQgdGFnIG9yIGEgY29sdW1uLWJyZWFrIHdoaWNoZXZlciBpcyBjbG9zZXIuXHJcbiAgICAgKi9cclxuICAgIGxldCBzaWJsaW5ncyA9IGNyZWF0ZURpdigpO1xyXG4gICAgbGV0IG1hcmtkb3duUmVuZGVyQ2hpbGQgPSBuZXcgTWFya2Rvd25SZW5kZXJDaGlsZChcclxuICAgICAgICBzaWJsaW5nc1xyXG4gICAgKTtcclxuICAgIE1hcmtkb3duUmVuZGVyZXIucmVuZGVyTWFya2Rvd24oXHJcbiAgICAgICAgbWRMaW5lcy5yZWR1Y2UoKHByZXYsIGN1cnJlbnQpID0+IHtcclxuICAgICAgICAgICAgcmV0dXJuIHByZXYgKyBcIlxcblwiICArIGN1cnJlbnQ7XHJcbiAgICAgICAgfSwgXCJcIiksXHJcbiAgICAgICAgc2libGluZ3MsXHJcbiAgICAgICAgc291cmNlUGF0aCxcclxuICAgICAgICBtYXJrZG93blJlbmRlckNoaWxkXHJcbiAgICApO1xyXG5cclxuICAgIHJldHVybiBzaWJsaW5ncztcclxufSJdLCJuYW1lcyI6WyJQbHVnaW4iLCJOb3RpY2UiLCJtdWx0aUNvbHVtblBhcnNlci5pc1N0YXJ0VGFnV2l0aElEIiwibXVsdGlDb2x1bW5QYXJzZXIuZ2V0U3RhcnRUYWdLZXkiLCJtdWx0aUNvbHVtblBhcnNlci5jb250YWluc0VuZFRhZyIsIm11bHRpQ29sdW1uUGFyc2VyLmNvbnRhaW5zU3RhcnRUYWciLCJtdWx0aUNvbHVtblBhcnNlci5nZXRTdGFydEJsb2NrQWJvdmVMaW5lIiwibXVsdGlDb2x1bW5QYXJzZXIuY291bnRTdGFydFRhZ3MiLCJNYXJrZG93blJlbmRlckNoaWxkIiwibXVsdGlDb2x1bW5QYXJzZXIuZ2V0RW5kQmxvY2tCZWxvdyIsIm11bHRpQ29sdW1uUGFyc2VyLmNvbnRhaW5zQ29sRW5kVGFnIiwibXVsdGlDb2x1bW5QYXJzZXIuY29udGFpbnNDb2xTZXR0aW5nc1RhZyIsIk1hcmtkb3duUmVuZGVyZXIiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUF1REE7QUFDTyxTQUFTLFNBQVMsQ0FBQyxPQUFPLEVBQUUsVUFBVSxFQUFFLENBQUMsRUFBRSxTQUFTLEVBQUU7QUFDN0QsSUFBSSxTQUFTLEtBQUssQ0FBQyxLQUFLLEVBQUUsRUFBRSxPQUFPLEtBQUssWUFBWSxDQUFDLEdBQUcsS0FBSyxHQUFHLElBQUksQ0FBQyxDQUFDLFVBQVUsT0FBTyxFQUFFLEVBQUUsT0FBTyxDQUFDLEtBQUssQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLEVBQUU7QUFDaEgsSUFBSSxPQUFPLEtBQUssQ0FBQyxLQUFLLENBQUMsR0FBRyxPQUFPLENBQUMsRUFBRSxVQUFVLE9BQU8sRUFBRSxNQUFNLEVBQUU7QUFDL0QsUUFBUSxTQUFTLFNBQVMsQ0FBQyxLQUFLLEVBQUUsRUFBRSxJQUFJLEVBQUUsSUFBSSxDQUFDLFNBQVMsQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsT0FBTyxDQUFDLEVBQUUsRUFBRSxNQUFNLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRSxFQUFFO0FBQ25HLFFBQVEsU0FBUyxRQUFRLENBQUMsS0FBSyxFQUFFLEVB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
