// Written by Christopher Fraser
//
// Adapted from Various Credited open sources, see below
//
// Using NNFX Principles
//
// Above/Below Baseline represents Long/Short area
// C1 & C2 combine to show areas of trend
// Grey Candles are areas when trend not established
// Low Volume shows as Red Background 
// ATR Bands for Visual Indication Only
// ATR based TP and SL/TSL prices/values to assist Risk Managed position sizing
// Tunable Exit Indicators
// Restrict Entry based on how far price has moved from Baseline (Default 1.5x ATR, Tunable)
// Tunable Continuation Criteria (SSL & ATR Based)
// 
// Entry Indicated by a Blue Arrow Above/Below Candle in Direction of Price Movement
// Exit Indicated by a Yellow Arrow Above/Below Candle in Direction of Price Movement
//
// *** DO NOT USE Money Management on "Properties" setup. Risk is changed at the bottom of "Inputs" page instead ***
//
// Coders/Modifiers, Code Sections made collapsable. Hide/Unhide indicatior by line number
// 
// Credits
//
// Strategy - causecelebre - https://www.tradingview.com/u/causecelebre/
// SSL Channel - ErwinBeckers - https://www.tradingview.com/u/ErwinBeckers/
// Moving Averages - jiehonglim - https://www.tradingview.com/u/jiehonglim/
// Moving Averages - everget - https://www.tradingview.com/u/everget/
// Damian Volameter - xinolia - https://www.tradingview.com/v/MhBm66Wh/
// QQE Mod - Mihkel00 - https://www.tradingview.com/v/TpUW4muw/
// SSL Hybrid - Mihkel00 - https://www.tradingview.com/v/C3MlAWCw/
// Absolute Strength Histrogram - jiehonglim - https://uk.tradingview.com/script/PORR7A3k-Absolute-Strength-Histogram-v2-jh/
// Dillon Grech - https://www.youtube.com/watch?v=_uS8L64QsyI&list=PLlrbkHtbSFWL00pUwbYiYgHpUgso1j47u
// Super Trend - Sickojacko - https://uk.tradingview.com/script/qzo1iOfs-Super-SSL/
// Accelerator Oscillator - Hpotter - https://uk.tradingview.com/script/6bta0VWS-Accelerator-Oscillator-AC/
// KDJ - x4random - https://uk.tradingview.com/v/VLaO5HdZ/
// Waddah Attar Explosion - LazyBear - https://www.tradingview.com/script/iu3kKWDI-Waddah-Attar-Explosion-LazyBear/
// Cronex T Demarker - romulodl - Github
// Kuskus Starlight - https://www.tradingview.com/script/nZuBWW9j-Jurik-Moving-Average/
// Squeeze Momentum Indicator - Lazybear - https://www.tradingview.com/script/nqQ1DT5a-Squeeze-Momentum-Indicator-LazyBear/
// Anchored Momentum - Lazybear - https://uk.tradingview.com/script/TBTFDWDq-Anchored-Momentum-LazyBear/ 
// Wave Trend Occilator - Lazybear - https://www.tradingview.com/script/2KE8wTuF-Indicator-WaveTrend-Oscillator-WT/
// Trend Magic - KivancOzbilgic - https://www.tradingview.com/script/kRIjThLZ-Trend-Magic/
// Currency Strength - Boitoki - https://www.tradingview.com/v/kKZROEeM/
// ATR+Kijun-Sen - racer8 - https://www.tradingview.com/script/tVS7ATGw-ATR-Kijun-Sen/
//
// Script Revision 33 - Added 3Ma Filter under C2
// 12th May 2021
//
//
//
// @version=4
//
strategy("Strategy Tester - NNFX ", currency = currency.USD, initial_capital = 1000, pyramiding = 2, overlay=true, process_orders_on_close = true)
//
//==============================================================================
// Rules Inputs
//==============================================================================
//{
Hide_Overlay = input(false, title='Hide Overlay', group = "Overlay - Hide When Using as Profit Filter")
//
A_Bridge = input(false, title='A Bridge Too Far', group = "Entry Rules")
One_Candle = input(false, title='One Candle Rule', group = "Entry Rules")
Movement_Favour = input(false, title='Only Enter after/on Candle Moving in Direction of Trade - initial', group = "Entry Rules")
Movement_Favour_Cont = input(false, title='Only Enter after/on Candle Moving in Direction of Trade - continuation', group = "Entry Rules")
Use_C1 = input(false, title='Use Confirmation 1 Indicator', group = "Entry Rules")
Use_C2 = input(false, title='Use Confirmation 2 Indicator', group = "Entry Rules")
Use_Vol = input(false, title='Use Volume', group = "Entry Rules")
Use_BL = input(false, title='Use Baseline', group = "Entry Rules")
Use_Exit = input(false, title='Use Exit', group = "Entry Rules")
No_Continue = input(false, title='No Continuations', group = "Entry Rules")

single_position = input(false, title='Only Enter one position and with TP (2 for NNFX) ', group = "Entry Rules")
//
Baseline_ATR_Cross = input(1.0, title='Baseline ATR Cross Rule * ATR Value', group = "Entry Rules")
TP_ATR_Var = input(1.0, title='Take Profit ATR Value - * ATR Value', group = "Exit Rules")
TSL_ATR_Var= input(1.5, title='Fixed Stoploss ATR Rule - * ATR Value', group = "Exit Rules")
//
Use_EVZ= input(false, title='Use $EVZ Filter', group = "$EVZ Rules")
Lower_EVZ= input(1.0, title='Do not Trade when $EVZ is BELOW this value', group = "$EVZ Rules")
//
risk_ma_2 = input(120, title=   'Trading Warning MA Length (default 6 months)', group = "Profit Risk Warning", minval = 100)
risk_ma_3 = input(60, title=   'Trading Warning MA Length (default 3 months)', group = "Profit Risk Warning", minval = 40)
//
percentRisk     = input(title = "Risk per Trade - Default 2% per Trade or 1% per Position",   defval = 0.02, minval = 0.001, maxval = 0.1, group = "Money Management")
//
Use_Risk_Management = input(false, title='Use Kelly Ratio Position Sizing', group = "Risk Reduction Rules")
Kelly_Factor = input(1.0, title='Kelly Ratio Factor 1 - 10 (10 lowest)', group = "Risk Reduction Rules", minval = 1.0, maxval = 10.0)
Kelly_Min = input(0.5, title='Smallest Position size 0.01 to 1 ', group = "Risk Reduction Rules", minval = 0.01 , maxval = 1.0)
//}
//==============================================================================
// FOREX EXCHANGE - Currency Conversion
//==============================================================================
//{
quoteCurrency = syminfo.currency
//
usdUSDrate = security("USDUSD", "D", close[1])
gbpUSDrate = security("GBPUSD", "D", close[1])
audUSDrate = security("AUDUSD", "D", close[1])
nzdUSDrate = security("NZDUSD", "D", close[1])
cadUSDrate = security("CADUSD", "D", close[1])
chfUSDrate = security("CHFUSD", "D", close[1])
eurUSDrate = security("EURUSD", "D", close[1])
jpyUSDrate = security("JPYUSD", "D", close[1])
sgdUSDrate = security("SGDUSD", "D", close[1])
hkdUSDrate = security("HKDUSD", "D", close[1])
cnhUSDrate = security("CNHUSD", "D", close[1])
sekUSDrate = security("SEKUSD", "D", close[1])
nokUSDrate = security("NOKUSD", "D", close[1])
dkkUSDrate = security("DKKUSD", "D", close[1])
plnUSDrate = security("PLNUSD", "D", close[1])
zarUSDrate = security("ZARUSD", "D", close[1])
//
cr_function(source) => 
    if quoteCurrency == "USD"
        1
    else
        if quoteCurrency == "GBP"
            gbpUSDrate 
        else
            if quoteCurrency == "AUD"
                audUSDrate
            else
                if quoteCurrency == "NZD"
                    nzdUSDrate
                else
                    if quoteCurrency == "CAD"
                        cadUSDrate
                    else
                        if quoteCurrency == "CHF"
                            chfUSDrate
                        else
                            if quoteCurrency == "EUR"
                                eurUSDrate
                            else
                                if quoteCurrency == "JPY"
                                    jpyUSDrate
                                else
                                    if quoteCurrency == "SGD"
                                        sgdUSDrate
                                    else
                                        if quoteCurrency == "HKD"
                                            hkdUSDrate
                                        else
                                            if quoteCurrency == "CNH"
                                                cnhUSDrate / 0.16
                                            else
                                                if quoteCurrency == "SEK"
                                                    sekUSDrate
                                                else
                                                    if quoteCurrency == "NOK"
                                                        nokUSDrate
                                                    else
                                                        if quoteCurrency == "DKK"
                                                            dkkUSDrate / 0.16
                                                        else
                                                            if quoteCurrency == "PLN"
                                                                plnUSDrate / 0.3
                                                            else
                                                                zarUSDrate
//
cr_multi = cr_function(tr(true))
//}
//==============================================================================
// $EVZ
//==============================================================================
//{
EVZrate = security("EVZ", "D", close[1])
//
Block_EVZ = EVZrate < Lower_EVZ ? true : false
//}
//==============================================================================
// Backtest Inputs
//==============================================================================
//{
// Configure backtest start date with inputs
startDate = input(title="Start Date", type=input.integer,
     defval=1, minval=1, maxval=31, group = "Strategy Test Period")
startMonth = input(title="Start Month", type=input.integer,
     defval=1, minval=1, maxval=12, group = "Strategy Test Period")
startYear = input(title="Start Year", type=input.integer,
     defval=2018, minval=1800, maxval=2100, group = "Strategy Test Period")
//
// Configure backtest start date with inputs
finishDate = input(title="finish Date", type=input.integer,
     defval=31, minval=1, maxval=31, group = "Strategy Test Period")
finishMonth = input(title="finish Month", type=input.integer,
     defval=12, minval=1, maxval=12, group = "Strategy Test Period")
finishYear = input(title="finish Year", type=input.integer,
     defval=2020, minval=1800, maxval=2100, group = "Strategy Test Period")
//}
//==============================================================================
// Time Check
//==============================================================================
//{
// See if this bar's time happened on/after start date
afterStartDate = (time >= timestamp(syminfo.timezone,
     startYear, startMonth, startDate, 0, 0))
//
// See if this bar's time happened before finish date
beforeFinishDate = (time < timestamp(syminfo.timezone,
     finishYear, finishMonth, finishDate, 0, 0))
//}
//==============================================================================
// Set Counters
//==============================================================================
//{
Count_open_long = float(0.0)
Count_open_short = float(0.0)
Count_open_long_cont = float(0.0)
Count_open_short_cont = float(0.0)
Count_close_long = float(0.0)
Count_close_short = float(0.0)
Count_blc_long = float(0.0)
Count_blc_short = float(0.0)
Count_confirm_long = float(0.0)
Count_confirm_short = float(0.0)
//}
//==============================================================================
// Select C1 & C2
//==============================================================================
//{
C1_Type= input(title="C1 Indicator Type", type=input.string, defval="Accel_Oscillator", options=["Accel_Oscillator","Vortex_Indicator","QQE","Aroon","SSL_C1","Cronex_T_Demarker_Z_Cross","Squeeze_Momentum_Indicator","Price_Momentum_Oscillator","Anchored_Momentum","Wave_Trend_Oscillator","ATR+Kijun-Sen"], group = "Confirmation Indicators")
//
C2_Type = input(title="C2 Indicator Type", type=input.string, defval="Abs_Str_Histo", options=["Abs_Str_Histo","3MA_Trend","Super_Trend","QQE_Histo","KDJ","SSL_C2","Kuskus_Starlight","FX_Sniper_Ergodic","Coppock_curve","Trend_Magic","Willians_%R"], group = "Confirmation Indicators")
//}
//==============================================================================
// Select Exit Indicator
//==============================================================================
//{
Exit_Type = input(title="Exit Indicator Type", type=input.string, defval="SSL3", options=["C1","C2","SSL3"], group = "Exit Indicators")
//}
//==============================================================================
// Select Volume Indicator
//==============================================================================
//{
Vol_Type= input(title="Volume Indicator Type", type=input.string, defval="Damiani_Volameter", options=["Damiani_Volameter","Waddah_Attar_Explosion"], group = "Volume Indicators")
//}
//==============================================================================
// C1 Accelerator Oscillator
//==============================================================================
//{
nLengthSlow = input(34, minval=1, title="Length Slow", group = "C1 - Accelerator Oscillator")
nLengthFast = input(5, minval=1, title="Length Fast", group = "C1 - Accelerator Oscillator")
xSMA1_hl2 = sma(hl2, nLengthFast)
xSMA2_hl2 = sma(hl2, nLengthSlow)
xSMA1_SMA2 = xSMA1_hl2 - xSMA2_hl2
xSMA_hl2 = sma(xSMA1_SMA2, nLengthFast)
nRes =  xSMA1_SMA2 - xSMA_hl2
Acc_Long = nRes > nRes[1]
Acc_Short = not Acc_Long
//}
//==============================================================================
// C1 Vortex Indicator
//==============================================================================
//{
period_ = input(14, title="Length", minval=2, group = "C1 - Vortex Indicator")
deadband = input(1.10, title="Value - Min 1.0 - Recommended 1.05 to 1.1 ", minval=1, group = "C1 - Vortex Indicator")
VMP = sum( abs( high - low[1]), period_ )
VMM = sum( abs( low - high[1]), period_ )
STR = sum( atr(1), period_ )
VIP = VMP / STR
VIM = VMM / STR
//
VI_Long = ((VIP > VIM) and (VIP > deadband))
VI_Short = ((not (VIP > VIM)) and (VIM > deadband))
//}
//==============================================================================
// C1 QQE
//==============================================================================
//{
RSI_Period = input(6, title='RSI Length', group = "C1 - QQE")
SF = input(5, title='RSI Smoothing', group = "C1 - QQE")
QQE = input(3, title='Fast QQE Factor', group = "C1 - QQE")
ThreshHold = input(3, title="Thresh-hold", group = "C1 - QQE")
//
src2 = input(close, title="RSI Source", group = "C1 - QQE")
//
Wilders_Period = RSI_Period * 2 - 1
//
Rsi = rsi(src2, RSI_Period)
RsiMa = ema(Rsi, SF)
AtrRsi = abs(RsiMa[1] - RsiMa)
MaAtrRsi = ema(AtrRsi, Wilders_Period)
dar = ema(MaAtrRsi, Wilders_Period) * QQE
//
longband = 0.0
shortband = 0.0
trend = 0
//
DeltaFastAtrRsi = dar
RSIndex = RsiMa
newshortband = RSIndex + DeltaFastAtrRsi
newlongband = RSIndex - DeltaFastAtrRsi
longband := RSIndex[1] > longband[1] and RSIndex > longband[1] ? 
   max(longband[1], newlongband) : newlongband
shortband := RSIndex[1] < shortband[1] and RSIndex < shortband[1] ? 
   min(shortband[1], newshortband) : newshortband
cross_1 = cross(longband[1], RSIndex)
trend := cross(RSIndex, shortband[1]) ? 1 : cross_1 ? -1 : nz(trend[1], 1)
FastAtrRsiTL = trend == 1 ? longband : shortband
//
length = input(50, minval=1, title="Bollinger Length", group = "C1 - QQE")
mult2 = input(0.35, minval=0.001, maxval=5, step=0.1, title="BB Multiplier", group = "C1 - QQE")
basis = sma(FastAtrRsiTL - 50, length)
dev = mult2 * stdev(FastAtrRsiTL - 50, length)
upper = basis + dev
lower = basis - dev
//
// Zero cross
QQEzlong = 0
QQEzlong := nz(QQEzlong[1])
QQEzshort = 0
QQEzshort := nz(QQEzshort[1])
QQEzlong := RSIndex >= 50 ? QQEzlong + 1 : 0
QQEzshort := RSIndex < 50 ? QQEzshort + 1 : 0
//  
QQE_Long = RsiMa - 50 > upper
QQE_Short = RsiMa - 50 < lower
//}
//==============================================================================
// C1 Aroon
//==============================================================================
//{
Aroonlength = input(12, minval=1, group = "C1 - Aroon")
Aroonupper = 100 * (highestbars(high, Aroonlength+1) + Aroonlength)/Aroonlength
Aroonlower = 100 * (lowestbars(low, Aroonlength+1) + Aroonlength)/Aroonlength
//
Ind_1_L_Trigger = (C1_Type == "Aroon") ? (Aroonupper > Aroonlower)  ? true : false : false
Ind_1_S_Trigger = (C1_Type == "Aroon") ? (Aroonupper < Aroonlower) ? true : false : false
//}
//==============================================================================
// C1 SSL
//==============================================================================
//{
period_SSL_c1=input(title="Period", defval=10, group = "C1 - SSL")
len_SSL_c1=input(title="Period", defval=10, group = "C1 - SSL")
smaHigh_SSL_c1=sma(high, len_SSL_c1)
smaLow_SSL_c1=sma(low, len_SSL_c1)
Hlv_SSL_c1 = 0
Hlv_SSL_c1 := close > smaHigh_SSL_c1 ? 1 : close < smaLow_SSL_c1 ? -1 : Hlv_SSL_c1[1]
sslDown_SSL_c1 = Hlv_SSL_c1 < 0 ? smaHigh_SSL_c1: smaLow_SSL_c1
sslUp_SSL_c1   = Hlv_SSL_c1 < 0 ? smaLow_SSL_c1 : smaHigh_SSL_c1
//
long_SSL_c1 = sslUp_SSL_c1 > sslDown_SSL_c1 
short_SSL_c1 = sslUp_SSL_c1 < sslDown_SSL_c1 
//}
//==============================================================================
// C1 Cronex T Demarker Zero Cross 
//==============================================================================
//{
demarker_length = input(24, group = "C1 - Cronex T Demarker")
dem_step = input(4, group = "C1 - Cronex T Demarker")
curvature = input(0.618, group = "C1 - Cronex T Demarker")
//
e1 = 0.0
e2 = 0.0
e3 = 0.0
e4 = 0.0
e5 = 0.0
e6 = 0.0
//
deMax = high - high[1] > 0 ? high - high[1] : 0
deMin = low[1] - low > 0 ? low[1] - low : 0
//
demarker(dem_length) =>
    sma_deMax = sma(deMax, dem_length)
    sma_deMin = sma(deMin, dem_length)
    sma_deMax / (sma_deMax + sma_deMin)
//
n  = 1 + 0.5 * (demarker_length - 1)
w1 = 2 / (demarker_length + 1)
w2 = 1 - w1
b2 = curvature * curvature
b3 = b2 * curvature
c1 = -b3
c2 = (3 * (b2 + b3))
c3 = -3 * (2 * b2 + curvature + b3)
c4 = (1 + 3 * curvature + b3 + 3 * b2)
//
demarker_v = (demarker(demarker_length) + demarker(demarker_length + dem_step) + demarker(demarker_length + dem_step * 2) + demarker(demarker_length + dem_step * 3)) * 100 / 4 - 50
e1 := not na(demarker_v) ? w1 * demarker_v + w2 * e1[1] : 0
e2 := not na(demarker_v) ? w1 * e1 + w2 * e2[1] : 0
e3 := not na(demarker_v) ? w1 * e2 + w2 * e3[1] : 0
e4 := not na(demarker_v) ? w1 * e3 + w2 * e4[1] : 0
e5 := not na(demarker_v) ? w1 * e4 + w2 * e5[1] : 0
e6 := not na(demarker_v) ? w1 * e5 + w2 * e6[1] : 0
//
demarker_t = c1*e6 + c2*e5 + c3*e4 + c4*e3
//
Demarker_Long = crossover(demarker_v, 0)
Demarker_Short = crossunder(demarker_v, 0)
//
//remove comments to use as C1 triggers - AS A SIGNAL LINE CROSS
//Ind_1_Check_Trig = input(true, title = "Indicator 1 - C1 - Trigger")
//Ind_1_L_Trigger = Ind_1_Check_Trig ? crossover(demarker_v, demarker_t) : false
//Ind_1_S_Trigger = Ind_1_Check_Trig ? crossunder(demarker_v, demarker_t) : false
//
//remove comments to use as C2 confirmation
//Ind_2_Check_Conf = input(true, title = "Indicator 2 - C2 - Confirmation")
//Ind_2_L_Conf = Ind_2_Check_Conf ? demarker_v > 0 : true
//Ind_2_S_Conf = Ind_2_Check_Conf ? demarker_v < 0 : true
//}
//==============================================================================
// C1 Squeeze Momentum Indicator
//==============================================================================
//{
bb_squeeze_length       = input(20, title="BB Length", group = "C1 - Squeeze Momentum Indicator")
bb_squeeze_mult         = input(2.0,title="BB MultFactor", group = "C1 - Squeeze Momentum Indicator")
bb_squeeze_lengthKC     = input(20, title="KC Length", group = "C1 - Squeeze Momentum Indicator")
bb_squeeze_multKC       = input(1.5, title="KC MultFactor", group = "C1 - Squeeze Momentum Indicator")
bb_squeeze_useTrueRange = input(true, title="Use TrueRange (KC)", type=input.bool, group = "C1 - Squeeze Momentum Indicator")
//
// Calculate BB
source2 = close
basis2 = sma(source2, bb_squeeze_length)
dev2 = bb_squeeze_mult * stdev(source2, bb_squeeze_length)
upperBB = basis2 + dev2
lowerBB = basis2 - dev2
//
// Calculate KC
ma2 = sma(source2, bb_squeeze_lengthKC)
range2 = bb_squeeze_useTrueRange ? tr : (high - low)
rangema2 = sma(range2, bb_squeeze_lengthKC)
upperKC = ma2 + rangema2 * bb_squeeze_multKC
lowerKC = ma2 - rangema2 * bb_squeeze_multKC
//
sqzOn  = (lowerBB > lowerKC) and (upperBB < upperKC)
sqzOff = (lowerBB < lowerKC) and (upperBB > upperKC)
noSqz  = (sqzOn == false) and (sqzOff == false)
//
bb_squeeze_val = linreg(source2  -  avg(avg(highest(high, bb_squeeze_lengthKC), lowest(low, bb_squeeze_lengthKC)),sma(close,bb_squeeze_lengthKC)), bb_squeeze_lengthKC,0)
//
Squeeze_Long = crossover(bb_squeeze_val, 0)
Squeeze_Short = crossunder(bb_squeeze_val, 0)
//}
//==============================================================================
// C1 Price Momentum Oscillator
//==============================================================================
//{
PMOfirstLength = input(title="1st Smoothing Length", type=input.integer, defval=35, group = "C1 - Price Momentum Oscillator")
PMOsecondLength = input(title="2nd Smoothing Length", type=input.integer, defval=20, group = "C1 - Price Momentum Oscillator")
PMOsignalLength = input(title="Signal Length", type=input.integer, defval=10, group = "C1 - Price Momentum Oscillator")
PMOsrc = input(title="Source", type=input.source, defval=close, group = "C1 - Price Momentum Oscillator")
PMOpmo = ema(10 * ema(nz(roc(PMOsrc, 1)), PMOfirstLength), PMOsecondLength)
PMOsignal = ema(PMOpmo, PMOsignalLength)
//
Momentum_Long = crossover(PMOpmo, PMOsignal) 
Momentum_Short = crossunder(PMOpmo, PMOsignal)
//}
//==============================================================================
// C1 Anchored Momentum
//==============================================================================
//{
AMOM_LB_src=close
AMOM_LB_l=input(8, title="Momentum Period", group = "C1 - Anchored Momentum")
AMOM_LB_sl=input(10, title="Signal Period", group = "C1 - Anchored Momentum")
AMOM_LB_sm=input(true, title="Smooth Momentum", group = "C1 - Anchored Momentum")
AMOM_LB_smp=input(5, title="Smoothing Period", group = "C1 - Anchored Momentum")
AMOM_LB_p=2*AMOM_LB_l+1
AMOM_LB_amom=100*(((AMOM_LB_sm?sma(AMOM_LB_src,AMOM_LB_smp):AMOM_LB_src)/(sma(AMOM_LB_src,AMOM_LB_p)) - 1))
AMOM_LB_amoms=sma(AMOM_LB_amom, AMOM_LB_sl)
//
Anchored_Long = crossover(AMOM_LB_amom, AMOM_LB_amoms)
Anchored_Short = crossunder(AMOM_LB_amom, AMOM_LB_amoms)
//}
//==============================================================================
// C1 Wave Trend Oscillator
//==============================================================================
//{
wt_n1 = input(10, "Channel Length", group = "C1 - Wave Trend Oscillator")
wt_n2 = input(21, "Average Length", group = "C1 - Wave Trend Oscillator")
wt_s  = input(4, "Signal Length", group = "C1 - Wave Trend Oscillator")
// 
wt_ap = hlc3 
wt_esa = ema(wt_ap, wt_n1)
wt_d = ema(abs(wt_ap - wt_esa), wt_n1)
wt_ci = (wt_ap - wt_esa) / (0.015 * wt_d)
wt_tci = ema(wt_ci, wt_n2)
// 
wt1 = wt_tci
wt2 = sma(wt1, wt_s)
//
Wave_Trend_Long = crossover(wt1, 0)
Wave_Trend_Short = crossunder(wt1, 0)
//}
//==============================================================================
// C1 ATR+Kijun-Sen
//==============================================================================
//{
n_AKS = input(26,"Length", group = "C1 - ATR+Kijun-Sen")
h_AKS = highest(high,n_AKS)
l_AKS = lowest(low,n_AKS)
a_AKS = (h_AKS+l_AKS)/2
//
Atr_AKS=input(defval=5,title="Atr Period",minval=1,maxval=500, group = "C1 - ATR+Kijun-Sen")
Hhv_AKS=input(defval=10,title="HHV Period",minval=1,maxval=500, group = "C1 - ATR+Kijun-Sen")
Mult_AKS=input(defval=2.5,title="Multiplier",minval=0.1, group = "C1 - ATR+Kijun-Sen")
//
Prev_AKS = highest(high-Mult_AKS*atr(Atr_AKS),Hhv_AKS),barssince(close>highest(high-Mult_AKS*atr(Atr_AKS),Hhv_AKS) and close>close[1])
TS_AKS = iff(cum(1)<16 ,close,iff( close > highest(high-Mult_AKS*atr(Atr_AKS),Hhv_AKS) and close>close[1],highest(high-Mult_AKS*atr(Atr_AKS),Hhv_AKS),Prev_AKS))
//
Long_AKS = crossover(close,TS_AKS)
Short_AKS = crossunder(close,TS_AKS)
//}
//==============================================================================
// C2 Absolute Strength Histogram v2
//==============================================================================
//{
//
Length = input(9,title="Period of Evaluation", type=input.integer, group = "C2 - Abs Strength Histo")
Smooth = input(3,title="Period of Smoothing", type=input.integer, group = "C2 - Abs Strength Histo")
//
src_asi =  input(close,title="Source", group = "C2 - Abs Strength Histo")
Mode = input(title="Indicator Method", type=input.string, defval="RSI", options=["RSI", "STOCHASTIC","ADX"], group = "C2 - Abs Strength Histo")
ma_type = input(title="MA", type=input.string, defval="WMA", options=["ALMA", "EMA", "WMA", "SMA", "SMMA", "HMA"], group = "C2 - Abs Strength Histo")
alma_offset  = input(defval=0.85, title="* Arnaud Legoux (ALMA) Only - Offset Value", minval=0, step=0.01, group = "C2 - Abs Strength Histo")
alma_sigma   = input(defval=6, title="* Arnaud Legoux (ALMA) Only - Sigma Value", minval=0, group = "C2 - Abs Strength Histo")
//
ma_asi(type, src_asi, len) =>
    float result = 0
    if type=="SMA" // Simple
        result := sma(src_asi, len)
    if type=="EMA" // Exponential
        result := ema(src_asi, len)
    if type=="WMA" // Weighted
        result := wma(src_asi, len)
    if type=="SMMA" // Smoothed
        w = wma(src_asi, len)
        result := na(w[1]) ? sma(src_asi, len) : (w[1] * (len - 1) + src_asi) / len
    if type=="HMA" // Hull
        result := wma(2 * wma(src_asi, len / 2) - wma(src_asi, len), round(sqrt(len)))
    if type=="ALMA" // Arnaud Legoux
        result := alma(src_asi, len, alma_offset, alma_sigma)
    result
//
Price = src_asi
//
Price1 = ma_asi("SMA",Price,1)
Price2 = ma_asi("SMA",Price[1],1)
//
//RSI
Bulls0 = 0.5*(abs(Price1-Price2)+(Price1-Price2))
Bears0 = 0.5*(abs(Price1-Price2)-(Price1-Price2))
//
//STOCHASTIC
Bulls1 = Price1 - lowest(Price1,Length)
Bears1 = highest(Price1,Length) - Price1
//
//ADX
Bulls2 = 0.5*(abs(high-high[1])+(high-high[1]))
Bears2 = 0.5*(abs(low[1]-low)+(low[1]-low))
//
Bulls = Mode == "RSI" ? Bulls0 : Mode == "STOCHASTIC" ? Bulls1 : Bulls2
Bears = Mode == "RSI" ? Bears0 : Mode == "STOCHASTIC" ? Bears1 : Bears2
AvgBulls=ma_asi(ma_type,Bulls,Length)     
AvgBears=ma_asi(ma_type,Bears,Length)
//
SmthBulls=ma_asi(ma_type,AvgBulls,Smooth)  
SmthBears=ma_asi(ma_type,AvgBears,Smooth)
//
ASI_Long = (SmthBulls<SmthBulls[1])
ASI_Short = (SmthBears<SmthBears[1])
//}
//==============================================================================
// C2 3MA Trend
//==============================================================================
//{
MAT_len1 = input(50, title="MA1 Length", group = "C2 3MA Trend Variables")
MAT_len2 = input(title="MA2 Length", defval=100, group = "C2 3MA Trend Variables")
MAT_len3 = input(title="MA3 Length", defval=200, group = "C2 3MA Trend Variables")

MAT_ma1 = sma(close, MAT_len1)
MAT_ma2 = sma(close, MAT_len2)
MAT_ma3 = sma(close, MAT_len3)




long_3MA = (MAT_ma1 > MAT_ma2) and (MAT_ma2 > MAT_ma3)
short_3MA = (MAT_ma1 < MAT_ma2) and (MAT_ma2 < MAT_ma3)

//}
//==============================================================================
// C2 Super Trend
//==============================================================================
//{
ST_mult   = input(1.5,   title = 'SuperTrend Multiplier', minval = 0, maxval = 100, step = 0.1, group = "C2 - Super Trend")
ST_length = input(15, title = 'SuperTrend Period', minval = 1, group = "C2 - Super Trend")
//
src_ST = input(title="Source", type=input.source, defval=close, group = "C2 - Super Trend")
//
// super trend current state
st_state = bool(na)
//
get_st_state() =>
    
    return = int(0)
    trend = int(0)

    up_level = float(0.0)
    dn_level = float(0.0)
    up_trend   = float(0.0)
    down_trend = float(0.0)
    
    super_trend_line = float(0.0)

    
    up_level := hl2 - (ST_mult * atr(ST_length))
    dn_level := hl2 + (ST_mult * atr(ST_length))

    up_trend   := close[1] > up_trend[1]   ? max(up_level, up_trend[1])   : up_level
    down_trend := close[1] < down_trend[1] ? min(dn_level, down_trend[1]) : dn_level
    
    trend := close > down_trend[1] ? 1: close < up_trend[1] ? -1 : nz(trend[1], 1)
    
    if (trend == 1)
        super_trend_line := up_trend 
    else 
        super_trend_line := down_trend
            
    long_state = close - super_trend_line > 0        
    
    return := 0
    if long_state
        return := 1
    else
        return := -1

    return
//
st_state := get_st_state()    
long_ST = st_state[1] == 1 ? true : false
short_ST = st_state[1] == -1 ? true : false
//}
//==============================================================================
// C2 QQE Historian
//==============================================================================
//{
RSI_Period2 = input(6, title='RSI Length', group = "C2 - QQE")
SF2 = input(5, title='RSI Smoothing', group = "C2 - QQE")
QQE2 = input(1.61, title='Fast QQE2 Factor', group = "C2 - QQE")
ThreshHold2 = input(3, title="Thresh-hold", group = "C2 - QQE")
//
src3 = input(close, title="RSI Source", group = "C2 - QQE")
//
Wilders_Period2 = RSI_Period2 * 2 - 1
//
Rsi2 = rsi(src3, RSI_Period2)
RsiMa2 = ema(Rsi2, SF2)
AtrRsi2 = abs(RsiMa2[1] - RsiMa2)
MaAtrRsi2 = ema(AtrRsi2, Wilders_Period2)
dar2 = ema(MaAtrRsi2, Wilders_Period2) * QQE2
longband2 = 0.0
shortband2 = 0.0
trend2 = 0
//
DeltaFastAtrRsi2 = dar2
RSIndex2 = RsiMa2
newshortband2 = RSIndex2 + DeltaFastAtrRsi2
newlongband2 = RSIndex2 - DeltaFastAtrRsi2
longband2 := RSIndex2[1] > longband2[1] and RSIndex2 > longband2[1] ? 
   max(longband2[1], newlongband2) : newlongband2
shortband2 := RSIndex2[1] < shortband2[1] and RSIndex2 < shortband2[1] ? 
   min(shortband2[1], newshortband2) : newshortband2
cross_2 = cross(longband2[1], RSIndex2)
trend2 := cross(RSIndex2, shortband2[1]) ? 1 : cross_2 ? -1 : nz(trend2[1], 1)
FastAtrRsi2TL = trend2 == 1 ? longband2 : shortband2
//
// Zero cross
QQE2zlong = 0
QQE2zlong := nz(QQE2zlong[1])
QQE2zshort = 0
QQE2zshort := nz(QQE2zshort[1])
QQE2zlong := RSIndex2 >= 50 ? QQE2zlong + 1 : 0
QQE2zshort := RSIndex2 < 50 ? QQE2zshort + 1 : 0
//  
QQE_Histo_Long = RsiMa2 - 50 > ThreshHold2
QQE_Histo_Short = RsiMa2 - 50 < 0 - ThreshHold2
//}
//==============================================================================
// C2 KDJ
//==============================================================================
//{
length_KDJ = input(9, title="period", group = "C2 - KDJ")
signal_KDJ = input(3, title="signal", group = "C2 - KDJ")
hi = highest(high, length_KDJ)
lo = lowest(low , length_KDJ)
k = 100*((close-lo)/(hi-lo))
pK = rma(k, signal_KDJ)
pD = rma(pK, signal_KDJ)
pJ = 3*pK-2*pD
//
long_KDJ = pJ > (avg(pK, pD))
short_KDJ = not long_KDJ
//}
//==============================================================================
// C2 SSL
//==============================================================================
//{
period_SSL_c2=input(title="Period", defval=10, group = "C2 - SSL")
len_SSL_c2=input(title="Period", defval=10, group = "C2 - SSL")
smaHigh_SSL_c2=sma(high, len_SSL_c2)
smaLow_SSL_c2=sma(low, len_SSL_c2)
Hlv_SSL_c2 = 0
Hlv_SSL_c2 := close > smaHigh_SSL_c2 ? 1 : close < smaLow_SSL_c2 ? -1 : Hlv_SSL_c2[1]
sslDown_SSL_c2 = Hlv_SSL_c2 < 0 ? smaHigh_SSL_c2: smaLow_SSL_c2
sslUp_SSL_c2   = Hlv_SSL_c2 < 0 ? smaLow_SSL_c2 : smaHigh_SSL_c2
//
long_SSL_c2 = sslUp_SSL_c2 > sslDown_SSL_c2
short_SSL_c2 = sslUp_SSL_c2 < sslDown_SSL_c2 
//}
//==============================================================================
// C2 Kuskus_Starlight
//==============================================================================
//{
kuskus_range = input(30, title="Range Periods", group = "C2 - Kuskus Starlight")
pricesmoothing = input(0.3, title="Price Smoothing", group = "C2 - Kuskus Starlight")
indexsmoothing = input(0.3, title="Index Smoothing", group = "C2 - Kuskus Starlight")
highesthigh = highest( high, kuskus_range)
lowestlow = lowest(low, kuskus_range)
greatestrange = 0.0
greatestrange := (highesthigh - lowestlow) != 0 ? (highesthigh - lowestlow) : greatestrange[1]
midprice = (high + low) / 2
pricelocation = 2 * ((midprice - lowestlow) / greatestrange) - 1
extmapbuffer = 0.0
extmapbuffer := pricesmoothing *nz(extmapbuffer[1]) + (1 - pricesmoothing) * pricelocation
smoothedlocation = 0.0
smoothedlocation := (extmapbuffer > 0.99 ? 0.99 : (extmapbuffer < -0.99 ? -0.99 : extmapbuffer)) != 1 ? (extmapbuffer >0.99 ? 0.99 : (extmapbuffer < -0.99 ? -0.99 : extmapbuffer)) : smoothedlocation[1]
fishindex = log(( 1 + smoothedlocation) / (1 - smoothedlocation))
extmapbuffer1 = 0.0
extmapbuffer1 := indexsmoothing * nz(extmapbuffer1[1]) + ( 1 - indexsmoothing) * fishindex
kuskus = extmapbuffer1
//
Kuskus_Long = kuskus > 0
Kuskus_Short = kuskus < 0
//}
//==============================================================================
// C2 FX Sniper Ergodic CCI
//==============================================================================
//{
period_q      = input(title="Q smoothing period", defval=2, group = "C2 - FX Sniper Ergodic CCI")
period_r      = input(title="R smoothing period", defval=10, group = "C2 - FX Sniper Ergodic CCI")
period_s      = input(title="S smoothing period", defval=5, group = "C2 - FX Sniper Ergodic CCI")
signal_period = input(title="Signal Period", defval=3, group = "C2 - FX Sniper Ergodic CCI")
//
ecci_mom     = close - close[1]
ecci_abs_mom = abs(ecci_mom)
ecci_var1    = ema(ecci_mom, period_q)
ecci_var2    = ema(ecci_var1, period_r)
ecci_var2a   = ema(ecci_abs_mom, period_q)
ecci_var2b   = ema(ecci_var2a, period_r)
ecci_var2c   = ema(ecci_var2, period_s)
ecci_var3    = ema(ecci_var2b, period_s)
//
ergodic_cci = (500 * ecci_var2c) / ecci_var3
signal_line = ema(ergodic_cci, signal_period)
//
Sniper_Long = crossover(ergodic_cci, signal_line)
Sniper_Short = crossunder(ergodic_cci, signal_line)
//}
//==============================================================================
// C2 Coppock curve
//==============================================================================
//{
//
coppock_curve_wma_length = input(title="WMA Length", type=input.integer, defval=10, group = "C2 - Coppock curve")
coppock_curve_longRoCLength = input(title="Long RoC Length", type=input.integer, defval=14, group = "C2 - Coppock curve")
coppock_curve_shortRoCLength = input(title="Short RoC Length", type=input.integer, defval=11, group = "C2 - Coppock curve")
curve = wma(roc(close, coppock_curve_longRoCLength) + roc(close, coppock_curve_shortRoCLength), coppock_curve_wma_length)
//
Coppock_Long = curve > 0
Coppock_Short = curve < 0
//}
//==============================================================================
// C2 Trend Magic
//==============================================================================
//{
tm_period = input(20,"CCI period", group = "C2 - Trend Magic")
tm_coeff = input(1,"ATR Multiplier", group = "C2 - Trend Magic")
tm_AP = input(5,"ATR Period", group = "C2 - Trend Magic")
tm_ATR = sma(tr, tm_AP)
tm_src = input(close, group = "C2 - Trend Magic")
upT = low - tm_ATR * tm_coeff
downT = high + tm_ATR * tm_coeff
MagicTrend = 0.0
MagicTrend := cci(tm_src, tm_period) >= 0 ? (upT < nz(MagicTrend[1]) ? nz(MagicTrend[1]) : upT) : (downT > nz(MagicTrend[1]) ? nz(MagicTrend[1]) : downT)
color1 = cci(tm_src,tm_period) >= 0 ? #0022FC : #FC0400
//
Trend_Magic_Long = close > MagicTrend
Trend_Magic_Short = close < MagicTrend
//}
//==============================================================================
// C2 Willians %R
//==============================================================================
//{
wr_length = input(title="Length", type=input.integer, defval=14, group = "C2 - Willians %R")
wr_src    = input(close, "Source", type = input.source, group = "C2 - Willians %R")
//
_pr(length) =>
	max = highest(length)
	min = lowest(length)
	100 * (wr_src - max) / (max - min)
//
percentR = _pr(wr_length)
//
Willians_Long = percentR < -50
Willians_Short = percentR > -50
//}
//==============================================================================
// Use C1/C2 and Type
//==============================================================================
//{
C1_L = (QQE_Long and (C1_Type == "QQE")) or (Ind_1_L_Trigger and (C1_Type == "Aroon")) or (VI_Long and (C1_Type == "Vortex_Indicator")) or (Acc_Long and (C1_Type == "Accel_Oscillator")) or (long_SSL_c1 and (C1_Type == "SSL_C1")) or (Demarker_Long and (C1_Type == "Cronex_T_Demarker_Z_Cross")) or (Squeeze_Long and (C1_Type == "Squeeze_Momentum_Indicator")) or (Momentum_Long and (C1_Type == "Price_Momentum_Oscillator")) or (Anchored_Long and (C1_Type == "Anchored_Momentum")) or (Wave_Trend_Long and (C1_Type == "Wave_Trend_Oscillator")) or (Long_AKS and (C1_Type == "ATR+Kijun-Sen")) 
C1_S = (QQE_Short and (C1_Type == "QQE")) or (Ind_1_S_Trigger and (C1_Type == "Aroon")) or (VI_Short and (C1_Type == "Vortex_Indicator")) or (Acc_Short and (C1_Type == "Accel_Oscillator")) or (short_SSL_c1 and (C1_Type == "SSL_C1")) or (Demarker_Short and (C1_Type == "Cronex_T_Demarker_Z_Cross")) or (Squeeze_Short and (C1_Type == "Squeeze_Momentum_Indicator")) or (Momentum_Short and (C1_Type == "Price_Momentum_Oscillator")) or (Anchored_Short and (C1_Type == "Anchored_Momentum")) or (Wave_Trend_Short and (C1_Type == "Wave_Trend_Oscillator")) or (Short_AKS and (C1_Type == "ATR+Kijun-Sen")) 
//
C2_L = (QQE_Histo_Long and (C2_Type == "QQE_Histo")) or (long_3MA and (C2_Type == "3MA_Trend")) or (ASI_Long and (C2_Type == "Abs_Str_Histo")) or (long_ST and (C2_Type == "Super_Trend")) or (long_KDJ and (C2_Type == "KDJ")) or (long_SSL_c2 and (C2_Type == "SSL_C2")) or (Kuskus_Long and (C2_Type == "Kuskus_Starlight")) or (Sniper_Long and (C2_Type == "FX_Sniper_Ergodic")) or (Coppock_Long and (C2_Type == "Coppock_curve")) or (Trend_Magic_Long and (C2_Type == "Trend_Magic")) or (Willians_Long and (C2_Type == "Willians_%R")) 
C2_S = (QQE_Histo_Short and (C2_Type == "QQE_Histo")) or (short_3MA and (C2_Type == "3MA_Trend")) or (ASI_Short and (C2_Type == "Abs_Str_Histo")) or (short_ST and (C2_Type == "Super_Trend")) or (short_KDJ and (C2_Type == "KDJ")) or (short_SSL_c2 and (C2_Type == "SSL_C2")) or (Kuskus_Short and (C2_Type == "Kuskus_Starlight")) or (Sniper_Short and (C2_Type == "FX_Sniper_Ergodic")) or (Coppock_Short and (C2_Type == "Coppock_curve")) or (Trend_Magic_Short and (C2_Type == "Trend_Magic")) or (Willians_Short and (C2_Type == "Willians_%R"))
//
C1_Long =  C1_L or (Use_C1 == false)
C1_Short = C1_S or (Use_C1 == false)
C2_Long = C2_L or (Use_C2 == false)
C2_Short = C2_S or (Use_C2 == false)
//
Long_Confirm = C1_Long and C2_Long
Short_Confirm = C1_Short and C2_Short
//
Count_confirm_long := Long_Confirm ? Count_confirm_long[1] + 1 : 0
Count_confirm_short := Short_Confirm ? Count_confirm_short[1] + 1 : 0
//
No_Confirm = Long_Confirm or Short_Confirm
//}
//==============================================================================
// ATR- Selection
//==============================================================================
//{
show_atr = input(title="Show ATR bands", type=input.bool, defval=true, group = "ATR Variables")
show_atr2 = show_atr and not Hide_Overlay
//ATR
atrlen = input(10, "ATR Period", group = "ATR Variables")
smoothing = input(title="ATR Smoothing", defval="WMA", options=["RMA", "SMA", "EMA", "WMA"], group = "ATR Variables")
//
ma_function(source, atrlen) => 
    if smoothing == "RMA"
        rma(source, atrlen)
    else
        if smoothing == "SMA"
            sma(source, atrlen)
        else
            if smoothing == "EMA"
                ema(source, atrlen)
            else
                wma(source, atrlen)
atr_slen = ma_function(tr(true), atrlen)
//}
//==============================================================================
////Baseline / Continuation / Exit - Moving Averages
//==============================================================================
//{
// Baseline Inputs
//
show_Baseline = input(title="Show Baseline", type=input.bool, defval=true, group = "Baseline Variables")
//
show_Baseline2 = show_Baseline and not Hide_Overlay

maType = input(title="Baseline Type", type=input.string, defval="EMA", options=["SMA","EMA","DEMA","TEMA","LSMA","WMA","MF","VAMA","TMA","HMA", "JMA", "Kijun v2", "EDSMA","McGinley"], group = "Baseline Variables")
len = input(title="Baseline Length", defval=14, group = "Baseline Variables")
//
SSL2Type = input(title="Continuation Type", type=input.string, defval="JMA", options=["SMA","EMA","DEMA","TEMA","WMA","MF","VAMA","TMA","HMA", "JMA","McGinley"], group = "Continuation Variables")
len2 = input(title="Continuation Length", defval=5, group = "Continuation Variables")
//
SSL3Type = input(title="EXIT Type", type=input.string, defval="HMA", options=["DEMA","TEMA","LSMA","VAMA","TMA","HMA","JMA", "Kijun v2", "McGinley", "MF"], group = "Exit SSL Variables")
len3 = input(title="EXIT Length", defval=15, group = "Exit Variables")
src = input(title="Source", type=input.source, defval=close, group = "Exit Variables")
//
tema(src, len) =>
    ema1 = ema(src, len)
    ema2 = ema(ema1, len)
    ema3 = ema(ema2, len)
    (3 * ema1) - (3 * ema2) + ema3
kidiv = input(defval=1,maxval=4,  title="Kijun MOD Divider", group = "Kijun Baseline Variables")
//
jurik_phase = input(title="* Jurik (JMA) Only - Phase", type=input.integer, defval=3, group = "JMA Baseline Variables")
jurik_power = input(title="* Jurik (JMA) Only - Power", type=input.integer, defval=1, group = "JMA Baseline Variables")
volatility_lookback = input(10, title="* Volatility Adjusted (VAMA) Only - Volatility lookback length", group = "VAMA Baseline Variables")
// MF
beta = input(0.8,minval=0,maxval=1,step=0.1,  title="Modular Filter, General Filter Only - Beta" , group = "MF Baseline Variables")
feedback = input(false, title="Modular Filter Only - Feedback", group = "MF Baseline Variables")
z = input(0.5,title="Modular Filter Only - Feedback Weighting",step=0.1, minval=0, maxval=1, group = "MF Baseline Variables")
// EDSMA
ssfLength = input(title="EDSMA - Super Smoother Filter Length", type=input.integer, minval=1, defval=20, group = "EDSMA Baseline Variables")
ssfPoles = input(title="EDSMA - Super Smoother Filter Poles", type=input.integer, defval=2, options=[2, 3], group = "EDSMA Baseline Variables")
//
// EDSMA
get2PoleSSF(src, length) =>
    PI = 2 * asin(1)
    arg = sqrt(2) * PI / length
    a1 = exp(-arg)
    b1 = 2 * a1 * cos(arg)
    c2 = b1
    c3 = -pow(a1, 2)
    c1 = 1 - c2 - c3
    ssf = 0.0
    ssf := c1 * src + c2 * nz(ssf[1]) + c3 * nz(ssf[2])
//
get3PoleSSF(src, length) =>
    PI = 2 * asin(1)
    arg = PI / length
    a1 = exp(-arg)
    b1 = 2 * a1 * cos(1.738 * arg)
    c1 = pow(a1, 2)
    coef2 = b1 + c1
    coef3 = -(c1 + b1 * c1)
    coef4 = pow(c1, 2)
    coef1 = 1 - coef2 - coef3 - coef4
    ssf = 0.0
    ssf := coef1 * src + coef2 * nz(ssf[1]) + coef3 * nz(ssf[2]) + coef4 * nz(ssf[3])
//
ma(type, src, len) =>
    float result = 0
    if type=="TMA"
        result := sma(sma(src, ceil(len / 2)), floor(len / 2) + 1)
    if type=="MF"
        ts=0.,b=0.,c=0.,os=0.
        //----
        alpha = 2/(len+1)
        a = feedback ? z*src + (1-z)*nz(ts[1],src) : src
        //----
        b := a > alpha*a+(1-alpha)*nz(b[1],a) ? a : alpha*a+(1-alpha)*nz(b[1],a)
        c := a < alpha*a+(1-alpha)*nz(c[1],a) ? a : alpha*a+(1-alpha)*nz(c[1],a)
        os := a == b ? 1 : a == c ? 0 : os[1]
        //----
        upper = beta*b+(1-beta)*c
        lower = beta*c+(1-beta)*b 
        ts := os*upper+(1-os)*lower
        result := ts
    if type=="LSMA"
        result := linreg(src, len, 0)
    if type=="SMA" // Simple
        result := sma(src, len)
    if type=="EMA" // Exponential
        result := ema(src, len)
    if type=="DEMA" // Double Exponential
        e = ema(src, len)
        result := 2 * e - ema(e, len)
    if type=="TEMA" // Triple Exponential
        e = ema(src, len)
        result := 3 * (e - ema(e, len)) + ema(ema(e, len), len)
    if type=="WMA" // Weighted
        result := wma(src, len)
    if type=="VAMA" // Volatility Adjusted
        /// Copyright © 2019 to present, Joris Duyck (JD)
        mid=ema(src,len)
        dev=src-mid
        vol_up=highest(dev,volatility_lookback)
        vol_down=lowest(dev,volatility_lookback)
        result := mid+avg(vol_up,vol_down)
    if type=="HMA" // Hull
        result := wma(2 * wma(src, len / 2) - wma(src, len), round(sqrt(len)))
    if type=="JMA" // Jurik
        /// Copyright © 2018 Alex Orekhov (everget)
        /// Copyright © 2017 Jurik Research and Consulting.
        phaseRatio = jurik_phase < -100 ? 0.5 : jurik_phase > 100 ? 2.5 : jurik_phase / 100 + 1.5
        beta = 0.45 * (len - 1) / (0.45 * (len - 1) + 2)
        alpha = pow(beta, jurik_power)
        jma = 0.0
        e0 = 0.0
        e0 := (1 - alpha) * src + alpha * nz(e0[1])
        e1 = 0.0
        e1 := (src - e0) * (1 - beta) + beta * nz(e1[1])
        e2 = 0.0
        e2 := (e0 + phaseRatio * e1 - nz(jma[1])) * pow(1 - alpha, 2) + pow(alpha, 2) * nz(e2[1])
        jma := e2 + nz(jma[1])
        result := jma
    if type=="Kijun v2"
        kijun = avg(lowest(len), highest(len))//, (open + close)/2)
        conversionLine = avg(lowest(len/kidiv), highest(len/kidiv))
        delta = (kijun + conversionLine)/2
        result :=delta
    if type=="McGinley"
        mg = 0.0
        mg := na(mg[1]) ? ema(src, len) : mg[1] + (src - mg[1]) / (len * pow(src/mg[1], 4))
        result :=mg
    if type=="EDSMA"
    
        zeros = src - nz(src[2])
        avgZeros = (zeros + zeros[1]) / 2
        
        // Ehlers Super Smoother Filter 
        ssf = ssfPoles == 2
             ? get2PoleSSF(avgZeros, ssfLength)
             : get3PoleSSF(avgZeros, ssfLength)
        
        // Rescale filter in terms of Standard Deviations
        stdev = stdev(ssf, len)
        scaledFilter = stdev != 0
             ? ssf / stdev
             : 0
        
        alpha = 5 * abs(scaledFilter) / len
        
        edsma = 0.0
        edsma := alpha * src + (1 - alpha) * nz(edsma[1])
        result :=  edsma
    result
//  
// Continuation
emaHigh = ma(maType, high, len)
emaLow = ma(maType, low, len)
//
maHigh = ma(SSL2Type, high, len2)
maLow = ma(SSL2Type, low, len2)
//
// EXIT
ExitHigh = ma(SSL3Type, high, len3)
ExitLow = ma(SSL3Type, low, len3)
//
// Keltner Baseline Channel
BBMC = ma(maType, close, len)
useTrueRange = input(true, group = "Baseline Channel Variables")
multy = input(0.0, step=0.05, title="Base Channel Multiplier", group = "Baseline Channel Variables")
Keltma = ma(maType, src, len)
range = useTrueRange ? tr : high - low
rangema = ema(range, len)
upperk =Keltma + rangema * multy
lowerk = Keltma - rangema * multy
//
// Baseline Cross
base_cross_Long = (close > BBMC) or (Use_BL == false)
base_cross_Short = (close < BBMC)  or (Use_BL == false)
//
Count_blc_long := base_cross_Long ? Count_blc_long[1] + 1 : 0
Count_blc_short := base_cross_Short ? Count_blc_short[1] + 1 : 0
//}
//==============================================================================
// ATR Upper/Lower Values/Bands
//==============================================================================
//{
////ATR Up/Low Bands
upper_band = atr_slen * TSL_ATR_Var + close
lower_band = close - atr_slen * TSL_ATR_Var
//
//ATR Upper Entry Limits
//
lower_ATR_value = atr_slen * Baseline_ATR_Cross + close
upper_ATR_value  = close - atr_slen * Baseline_ATR_Cross
//
Long_ATR_Allowed = (BBMC > upper_ATR_value) or (Use_BL == false)
Short_ATR_Allowed = (BBMC < lower_ATR_value)  or (Use_BL == false)
//}
//==============================================================================
// Baseline Violation Candle
//==============================================================================
//{
open_pos =  open*1
close_pos = close*1
difference = abs(close_pos-open_pos)
atr_violation = difference > atr_slen
InRange = (upper_band > BBMC and lower_band < BBMC) or (Use_BL == false)
candlesize_violation = atr_violation and InRange
// Hide_Overlay

plotshape(candlesize_violation and (Use_BL == true) and not Hide_Overlay, color=color.white, size=size.tiny,style=shape.diamond, location=location.top, transp=0,title="Candle Size > 1xATR")
//}
//==============================================================================
// Continuation Values
//==============================================================================
//{
//CONTINUATION VALUES
Hlv2 = int(na)
Hlv2 := close > maHigh ? 1 : close < maLow ? -1 : Hlv2[1]
sslDown2 = Hlv2 < 0 ? maHigh : maLow
//}
//==============================================================================
// Exit Values
//==============================================================================
//{
Hlv3 = int(na)
Hlv3 := close > ExitHigh ? 1 : close < ExitLow ? -1 : Hlv3[1]
sslExit = Hlv3 < 0 ? ExitHigh : ExitLow
//
Exit_SSL3_Long = crossover(sslExit, close) and ((close > BBMC)  or (Use_BL == false))
Exit_SSL3_Short = crossover(close, sslExit) and ((close < BBMC)  or (Use_BL == false))
//
Exit_Selected_Long = Exit_Type == "SSL3" ? Exit_SSL3_Long : Exit_Type == "C1" ? not C1_L : Exit_Type == "C2" ? not C2_L : false
Exit_Selected_Short = Exit_Type == "SSL3" ? Exit_SSL3_Short : Exit_Type == "C1" ? not C1_S : Exit_Type == "C2" ? not C2_S : false
//
Exit_BL_Long = crossover(BBMC, close)
Exit_BL_Short = crossover(close, BBMC)
//}
//==============================================================================
// Price Movement
//==============================================================================
//{
move_up = (close > open) or (Movement_Favour == false)
move_down = (close < open) or (Movement_Favour == false)
move_up_cont = (close > open) or (Movement_Favour_Cont == false)
move_down_cont = (close < open) or (Movement_Favour_Cont == false)
//}
//==============================================================================
// Colour Bars
//==============================================================================
//{
show_color_bar = input(title="Color Bars", type=input.bool, defval=true, group = "Bar Colours Variables")
show_color_bar2 = show_color_bar and not Hide_Overlay

color_bar = close > upperk ? #28CB12 : close < lowerk ? #CB1512 : color.gray
color_bar2 = No_Confirm == false ? #979797 : na
//}
//==============================================================================
// Baseline - Plots
//==============================================================================
//{
p1 = plot(show_Baseline2 and Use_BL == true ? BBMC : na, color=color_bar, linewidth=4,transp=0, title='MA Baseline')
barcolor(show_color_bar2 ? color_bar2 : na)
up_channel = plot(show_Baseline2  and Use_BL == true ? upperk : na, color=color_bar, title="Baseline Upper Channel")
low_channel = plot(show_Baseline2 and Use_BL == true ? lowerk : na, color=color_bar, title="Basiline Lower Channel")
fill(up_channel, low_channel,color=color_bar, transp=100)
//}
//==============================================================================
// Continiuations
//==============================================================================
//{
atr_crit = input(0.9, step=0.1, title="Continuation ATR Criteria", group = "Continuation Variables")
upper_half = atr_slen * atr_crit + close
lower_half = close - atr_slen * atr_crit
buy_inatr =  lower_half < sslDown2
sell_inatr = upper_half > sslDown2
sell_cont = ((close < BBMC) and (close < sslDown2) and (No_Continue == false)) and Use_BL == true
buy_cont = ((close > BBMC) and (close > sslDown2)  and (No_Continue == false)) and Use_BL == true
sell_atr = sell_inatr and sell_cont
buy_atr = buy_inatr
atr_fill = buy_atr ? color.black : sell_atr ? color.black: color.white
LongPlot = plot(Hide_Overlay or Use_BL == false ? na : sslDown2, title="SSL2", linewidth=2, color=atr_fill, style=plot.style_circles, transp=0)
//}
//==============================================================================
// ATR - Bands 
//==============================================================================
//{
calc_atr = atr_slen * 1000
round_atr = round (calc_atr)
current_atr = round_atr /1000
current_atr_TP = current_atr * TP_ATR_Var
multi_atr = current_atr * TSL_ATR_Var
label_loc = close
Long_Price = ((close > BBMC) and (Use_BL == true)) or (Long_Confirm and (Use_BL == false))
Short_Price = ((close < BBMC) and (Use_BL == true)) or (Short_Confirm and (Use_BL == false))
TSL_Price = Long_Price == true ? (close - multi_atr): Short_Price == true ? (close + multi_atr): na
TP_Price = Long_Price == true ? (close + current_atr_TP): Short_Price == true ? (close - current_atr_TP): na
//
upper_band1 = Long_Price == true ? (atr_slen * TP_ATR_Var + close): Short_Price == true ? (atr_slen * TSL_ATR_Var + close): na
lower_band1 = Long_Price == true ? (close - atr_slen * TSL_ATR_Var): Short_Price == true ? (close - atr_slen * TP_ATR_Var): na
//
upper_band_colour = Long_Price == true ? color.blue : Short_Price == true ? color.red : na
lower_band_colour = Long_Price == true ? color.red : Short_Price == true ? color.blue : na
//
u = plot(show_atr2 and Use_BL == true ? upper_band1 : na, "+ATR", color=upper_band_colour, transp=0)
l = plot(show_atr2 and Use_BL == true ? lower_band1 : na, "-ATR", color=lower_band_colour, transp=0)
//}
//==============================================================================
// Volume - Damiani Volameter
//==============================================================================
//{
//mtf library
useCurrentRes = input(true, title="useCurrentRes", group = "Volume - Damiani Volatmeter")
res = input(title="Different Timeframe", type=input.resolution, defval="240", group = "Volume - Damiani Volatmeter")
uptimeflame = input(false, title="use upper up timeflame", type=input.bool, group = "Volume - Damiani Volatmeter")
upRes(res)=> res == "1"  ? "5" : res == "3"  ? "15" : res == "5"  ? "15" : res == "15"  ? "60" : res == "30"  ? "120" : res == "60"  ? "240" : res == "120"  ? "1D" : res == "180"  ? "1D" : res == "240"  ? "1D" : res == "1D"  ? "1W" : res == "1W"  ? "1M" : res == "D"  ? "1W" : res == "W"  ? "1M" : res
restf = useCurrentRes ? (uptimeflame ? upRes(timeframe.period) : timeframe.period) : (uptimeflame ? upRes(res) : res)
cvttf2n(a)=>a == '1' ?  1 : a == '3' ?  3 : a == '5' ?  5 : a == '15' ? 15 : a == '30' ?  30 : a == '60' ?  60 : a == '120' ?  120 : a == '180' ?  180 : a == '240' ?  240 : a == '1D' ?  1440 : a == '1W' ?  10080 : a == '1M' ?  43200 : a == 'D' ?  1440 : a == 'W' ?  10080 : a == 'M' ?  43200 : na
current_tf_mn = timeframe.ismonthly ? timeframe.multiplier * 43200 : timeframe.isweekly ? timeframe.multiplier * 10080 : timeframe.isdaily ? timeframe.multiplier * 1440 : timeframe.multiplier
cvttf2mult(rest) =>cvttf2n(rest)  / current_tf_mn
tf_mult = cvttf2mult(restf)
//
//source = input(close, title="Source ")
//
// original trend color
DVColorMode = input ("MACD(close)", title = "DV Color mode",options=["MACD(DV)", "trend", "MACD(close)","MACD os(close)","donchian"], group = "Volume - Damiani Volatmeter")
donchian(len) => avg(lowest(len), highest(len))
//MACD
dummyMACD = input(false, title = "MACD setting, MACD", group = "Volume - Damiani Volatmeter")
MACDfast = input(9, title = "MACD fast length", group = "Volume - Damiani Volatmeter")
MACDslow = input(17, title = "MACD slow length", group = "Volume - Damiani Volatmeter")
MACDsignal = input(7, title = "MACD signal length", group = "Volume - Damiani Volatmeter")
//trend
dummytrend = input(false, title = "trend setting, trend", group = "Volume - Damiani Volatmeter")
vwmalen = input(3, title = "trend color length", group = "Volume - Damiani Volatmeter")
vwmasig = input(3, title = "trend color smooth", group = "Volume - Damiani Volatmeter")
//donchian
dummydonchian = input(false, title = "donchian setting, donchian", group = "Volume - Damiani Volatmeter")
donchianfast = input(13, title = "(donchian)fast length", group = "Volume - Damiani Volatmeter")
donchianslow = input(20, title = "(donchian)slow length", group = "Volume - Damiani Volatmeter")
//
//ColorOsi(src, 9 ,17, 7, color.green, color.red)
ColorOsi(src, upc, dnc) => 
	ret = upc
	if DVColorMode == "MACD(DV)"
		macd = ema(src, MACDfast) - ema(src, MACDslow)
        sig = ema(macd, MACDsignal)
        hist = macd - sig
		ret := hist >= 0 ? upc : dnc
	if DVColorMode == "trend"
		vwmaval = vwma(close, vwmalen)
		vwmasigval = sma(vwmaval, vwmasig)
		ret := vwmaval >= vwmasigval ? upc : dnc
	if DVColorMode == "MACD(close)"
		macd = ema(close, MACDfast) - ema(close, MACDslow)
		sig = sma(macd, MACDsignal)
		hist = macd - sig
		ret := hist >= 0 ? upc : dnc
	if DVColorMode == "MACD os(close)"
		macd = ema(close, MACDfast) - ema(close, MACDslow)
		sig = sma(macd, MACDsignal)
		hist = macd - sig
		ret := hist >= hist[1] ? upc : dnc
	if DVColorMode == "donchian"
		donchianfastval = donchian(donchianfast)
		donchianval = donchianfastval - donchian(donchianslow)
		donchiandir = donchianval == 0 ? (close > donchianfastval ? 1 : -1) : donchianval
		ret := donchiandir >= 0 ? upc : dnc
	ret
//
dummydv = input(false, title = "Damiani Volatmeter setting DV", group = "Volume - Damiani Volatmeter")
usevolmode = true //input(true, title = "use volume Mode")
vis_atr = input(13, group = "Volume - Damiani Volatmeter")
vis_std = input(20, group = "Volume - Damiani Volatmeter")
sed_atr = input(40, group = "Volume - Damiani Volatmeter")
sed_std = input(100, group = "Volume - Damiani Volatmeter")
threshold_level = input(1.4, group = "Volume - Damiani Volatmeter")
lag_supressor = input(true, group = "Volume - Damiani Volatmeter")
//
atrv(len)=>rma(volume, len)
//DV(13,20,40,100,1.4,true)
DV(vis_atr,vis_std,sed_atr,sed_std,threshold_level,lag_supressor)=>
	vol = 0.0
	lag_s_K = 0.5
	s1=nz(vol[1], 0)
	s3=nz(vol[3], 0)
    vol := lag_supressor ? atr(vis_atr) / atr(sed_atr) + lag_s_K*(s1-s3) : atr(vis_atr) / atr(sed_atr)
	anti_thres = stdev(close, vis_std) / stdev(close, sed_std)
	t = threshold_level - anti_thres
	t- vol
//Standard Deviation Function
st_dev(y, t)=>sqrt(sma(pow(y - sma(y, t), 2), t))
//
//Correlation Coefficient
corr(x, y, t)=>
    x_dev = x - sma(x, t)
    y_dev = y - sma(y, t)
    xy_sum = 0.0
    x2_sum = 0.0
    y2_sum = 0.0
    for i = 0 to (t - 1)
        xy_sum := xy_sum + x_dev[i]*y_dev[i]
        x2_sum := x2_sum + pow(x_dev[i], 2)
        y2_sum := y2_sum + pow(y_dev[i], 2)
    xy_sum/sqrt(x2_sum*y2_sum)
//
DVval = -DV(vis_atr,vis_std,sed_atr,sed_std,threshold_level,lag_supressor)
mtfDV = security(syminfo.tickerid, restf, DVval)
//
bgcolor((mtfDV < 0 and Use_Vol and (Vol_Type == "Damiani_Volameter")) == true ? color.new(color.red, 80) : color.new(color.red, 100))
//
Volume_Entry_Block_Dam = (mtfDV < 0) and (Use_Vol == true) and (Vol_Type == "Damiani_Volameter") ? true : false
//}
//==============================================================================
// Volume -  Waddah Attar Explosion
//==============================================================================
//{
sensitivity = input(150, title="Sensitivity", group = "Volume - Waddah Attar Explosion")
fastLength=input(20, title="FastEMA Length", group = "Volume - Waddah Attar Explosion")
slowLength=input(40, title="SlowEMA Length", group = "Volume - Waddah Attar Explosion")
channelLength=input(20, title="BB Channel Length", group = "Volume - Waddah Attar Explosion")
mult=input(2.0, title="BB Stdev Multiplier", group = "Volume - Waddah Attar Explosion")
//
DEAD_ZONE = nz(rma(tr(true),100)) * 3.7
//
calc_macd(source, fastLength, slowLength) =>
	fastMA = ema(source, fastLength)
	slowMA = ema(source, slowLength)
	fastMA - slowMA
//
calc_BBUpper(source, length, mult) => 
	basis = sma(source, length)
	dev = mult * stdev(source, length)
	basis + dev
//
calc_BBLower(source, length, mult) => 
	basis = sma(source, length)
	dev = mult * stdev(source, length)
	basis - dev
//
t1 = (calc_macd(close, fastLength, slowLength) - calc_macd(close[1], fastLength, slowLength))*sensitivity
t2 = (calc_macd(close[2], fastLength, slowLength) - calc_macd(close[3], fastLength, slowLength))*sensitivity
//
e1V = (calc_BBUpper(close, channelLength, mult) - calc_BBLower(close, channelLength, mult))
//
trendUp = (t1 >= 0) ? t1 : 0
trendDown = (t1 < 0) ? (-1*t1) : 0

trendNone = (trendUp == 0) and (trendDown == 0)

//
WAE_Low = e1V <= DEAD_ZONE ? true : false
//
bgcolor((WAE_Low and (Use_Vol == true) and (Vol_Type == "Waddah_Attar_Explosion")) == true ? color.new(color.red, 80) : color.new(color.red, 100))
//
Volume_Entry_Block_WAE = ((WAE_Low == true) or (trendNone == true)) and ((Use_Vol == true) and (Vol_Type == "Waddah_Attar_Explosion")) ? true : false 
//}
//==============================================================================
// Volume - Block
//==============================================================================
//{
Volume_Entry_Block = Volume_Entry_Block_Dam or Volume_Entry_Block_WAE
//}
//==============================================================================
// Money Management - Dynamic Risk
//==============================================================================
//{
//
profit_percent = (strategy.netprofit + (strategy.initial_capital) / (strategy.initial_capital) * 100 ) - 100
display_profit = round(profit_percent)
//
krp = (strategy.wintrades - strategy.wintrades[30]) / (strategy.closedtrades - strategy.closedtrades[30])
krw =  (strategy.grossprofit - strategy.grossprofit[30]) / (strategy.wintrades - strategy.wintrades[30])
krl = (strategy.grossloss - strategy.grossloss[30]) / (strategy.losstrades - strategy.losstrades[30])
kr = ((krp - (1-krp) / (krw/krl)) * 100) / 100
dynamic_ratio = (kr/Kelly_Factor) + 1

cal_dynamic_ratio = dynamic_ratio >= Kelly_Min ? dynamic_ratio : Kelly_Min
//  
final_dynamic_ratio = Use_Risk_Management == true  ? cal_dynamic_ratio : 1
//}
//==============================================================================
// Money Management - Proft Warning
//==============================================================================
//{
overma4        = float(0.0)
overma5        = float(0.0)
ma_total2       = float(0.0)
//
profitma4 = sma(profit_percent, risk_ma_2)
profitma5 = sma(profit_percent, risk_ma_3)
//
profit_over_ma4 = profit_percent > profitma4
profit_over_ma5 = profit_percent > profitma5
//
overma4  := profit_over_ma4 ? 1 : 0 
overma5  := profit_over_ma5 ? 1 : 0
ma_total2 := overma4 + overma5
//
risk_text = (ma_total2 == 2) ? "Profit over MA - Take Trade" : (ma_total2 == 1) ? "Profit between Long/Short MA - Half Risk" : "Profit Below MA - DO NOT TRADE"
risk_text2 = (ma_total2 == 2) ? "Safe Trade" : (ma_total2 == 1) ? "Caution Trade" : "DO NOT TRADE"
//}
//==============================================================================
// Money Management - Position Size
//==============================================================================
//{
posSize = (((strategy.initial_capital * percentRisk) / (TSL_ATR_Var * atr_slen))/cr_multi) * final_dynamic_ratio
//}
//==============================================================================
// Entry/Exit Indication
//==============================================================================
//{
Entry_Long = if Use_BL == true
    base_cross_Long and Long_ATR_Allowed and Long_Confirm and (not Volume_Entry_Block) and move_up and ((One_Candle == false) or ((One_Candle == true) and (Count_blc_long == 2))) and ((A_Bridge == false) or ((A_Bridge == true) and (Count_confirm_long <= 7))) and ((Use_EVZ == false) or ((Block_EVZ == false) and (Use_EVZ == true)))
else
    Long_Confirm and (not Volume_Entry_Block) and move_up and ((Use_EVZ == false) or ((Block_EVZ == false) and (Use_EVZ == true)))
//
Count_open_long := Entry_Long ? Count_open_long[1] + 1 : 0
//
Entry_Short = if Use_BL == true
    base_cross_Short and Short_ATR_Allowed and Short_Confirm and (not Volume_Entry_Block) and move_down and ((One_Candle == false) or ((One_Candle == true) and (Count_blc_short == 2))) and ((A_Bridge == false) or ((A_Bridge == true) and (Count_confirm_short <= 7))) and ((Use_EVZ == false) or ((Block_EVZ == false) and (Use_EVZ == true)))
else
    Short_Confirm and (not Volume_Entry_Block) and move_down and ((Use_EVZ == false) or ((Block_EVZ == false) and (Use_EVZ == true)))
    //
Count_open_short := Entry_Short ? Count_open_short[1] + 1 : 0
//
Exit_Long = (Exit_Selected_Long or ((Use_BL == true) and Exit_BL_Long)) and (Use_Exit == true)
Count_close_long := Exit_Long ? 0 : base_cross_Short ? 0  : Count_close_long[1] + 1
//
Exit_Short = (Exit_Selected_Short or ((Use_BL == true) and Exit_BL_Short)) and (Use_Exit == true)
Count_close_short := Exit_Short ? 0 : base_cross_Long ? 0 : Count_close_short[1] + 1
//
Entry_Long_Cont = (Use_BL == true) and buy_cont and base_cross_Long and Long_Confirm and move_up_cont and (Count_blc_long > Count_close_long)  and ((Use_EVZ == false) or ((Block_EVZ == false) and (Use_EVZ == true)))
Count_open_long_cont := Entry_Long_Cont ? Count_open_long_cont[1] + 1 : 0
//
Entry_Short_Cont = (Use_BL == true) and sell_cont and base_cross_Short and Short_Confirm and move_down_cont and (Count_blc_short > Count_close_short)  and ((Use_EVZ == false) or ((Block_EVZ == false) and (Use_EVZ == true)))
Count_open_short_cont := Entry_Short_Cont ? Count_open_short_cont[1] + 1 : 0
//
// Plot Entry/Exit
//
Entry_Long_No_Repeat = Entry_Long and (Count_open_long <=1)
Entry_Long_Cont_No_Repeat = Entry_Long_Cont and (Count_open_long_cont <=2)
Exit_Long_No_Repeat = Exit_Long and (Count_close_long <=1) and (Count_blc_short < 1)
//
Entry_Short_No_Repeat = Entry_Short and (Count_open_short <=1)
Entry_Short_Cont_No_Repeat = Entry_Short_Cont and (Count_open_short_cont <=2) 
Exit_Short_No_Repeat = Exit_Short and (Count_close_short <=1) and (Count_blc_long < 1)
//
plotshape((Entry_Long_No_Repeat or Entry_Long_Cont_No_Repeat) and not Hide_Overlay, color=color.blue, size=size.small,style=shape.arrowup, location=location.belowbar, transp=0,title="Long Entry")
plotshape((Entry_Short_No_Repeat or Entry_Short_Cont_No_Repeat) and not Hide_Overlay, color=color.blue, size=size.small,style=shape.arrowdown, location=location.abovebar, transp=0,title="Short Entry")
plotshape((Exit_Long_No_Repeat and not Hide_Overlay), color=color.yellow, size=size.small,style=shape.arrowdown, location=location.abovebar, transp=0,title="Long Exit")
plotshape((Exit_Short_No_Repeat and not Hide_Overlay),  color=color.yellow, size=size.small,style=shape.arrowup, location=location.belowbar, transp=0,title="Short Exit")
//}
//==============================================================================
// Strategy Positions
//==============================================================================
//{
//
entry_atr    = float(0.0) //set float
entry_price  = float(0.0) //set float
entry_atr   := strategy.position_size == 0  ? atr_slen  : entry_atr[1]
entry_price := strategy.position_size == 0  ? close  : entry_price[1]
//
// Submit entry orders, but only on/after start date
//
if (afterStartDate and beforeFinishDate and strategy.position_size == 0 and (Entry_Long_No_Repeat or Entry_Long_Cont_No_Repeat) and (single_position == false))
    strategy.entry(id="Long Entry 1",  long=true,  qty=posSize*0.5)
    strategy.entry(id="Long Entry 2",  long=true,  qty=posSize*0.5)
//
if (afterStartDate and beforeFinishDate and strategy.position_size == 0 and (Entry_Long_No_Repeat or Entry_Long_Cont_No_Repeat) and (single_position == true))
    strategy.entry(id="Long Entry 1",  long=true,  qty=posSize*1.0)
//
if (afterStartDate and beforeFinishDate and strategy.position_size == 0 and (Entry_Short_No_Repeat or Entry_Short_Cont_No_Repeat) and (single_position == false))
    strategy.entry(id="Short Entry 1",  long=false,  qty=posSize*0.5)
    strategy.entry(id="Short Entry 2",  long=false,  qty=posSize*0.5)
//
if (afterStartDate and beforeFinishDate and strategy.position_size == 0 and (Entry_Short_No_Repeat or Entry_Short_Cont_No_Repeat) and (single_position == true))
    strategy.entry(id="Short Entry 1",  long=false,  qty=posSize*1.0)
//
// Rules Exits
//  
if (Exit_Long)
    strategy.close(id="Long Entry 1")
    strategy.close(id="Long Entry 2")
    strategy.cancel(id="Long Entry 1")
    strategy.cancel(id="Long Entry 2")
//    
if (Exit_Short)
    strategy.close(id="Short Entry 1")
    strategy.close(id="Short Entry 2")
    strategy.cancel(id="Short Entry 1")
    strategy.cancel(id="Short Entry 2")
//
// TP/SL Exits
//
nLoss   = entry_atr * TSL_ATR_Var
nProfit = entry_atr * TP_ATR_Var
//
long_stop_level     = float(0.0)
long_profit_level   = float(0.0)
short_stop_level    = float(0.0)
short_profit_level  = float(0.0)

long_stop_level    := entry_price - nLoss
short_stop_level   := entry_price + nLoss

long_profit_level  := entry_price + nProfit
short_profit_level := entry_price - nProfit
//
plot(strategy.position_size <= 0  ? na : long_stop_level,    color=color.red,  style = plot.style_linebr, linewidth = 2)
plot(strategy.position_size <= 0  ? na : long_profit_level,  color=color.lime, style = plot.style_linebr, linewidth = 2)
plot(strategy.position_size >= 0  ? na : short_stop_level,   color=color.red,  style = plot.style_linebr, linewidth = 2)
plot(strategy.position_size >= 0  ? na : short_profit_level, color=color.lime, style = plot.style_linebr, linewidth = 2)

strategy.exit("TP/SL 1", "Long Entry 1",  limit = long_profit_level,  stop = long_stop_level)
strategy.exit("TP/SL 1", "Short Entry 1", limit = short_profit_level, stop = short_stop_level)
strategy.exit("SL 2", "Long Entry 2",  stop = long_stop_level)
strategy.exit("SL 2", "Short Entry 2", stop = short_stop_level)
//    
//}
//==============================================================================
// ATR/$EVZ?RISK Label
//==============================================================================
//{
textspacing = input(title="Text Label Spacing", defval=10, minval=1, group = "ATR Label")
//
datetime = time - time[1]
//
if (Hide_Overlay == false)

    l2 = label.new(time+datetime * textspacing,label_loc, 'SL ATR is '+tostring(multi_atr)+ '\  Price '+tostring(TSL_Price)+ '\nTP ATR is '+tostring(current_atr_TP)+ '\  Price '+tostring(TP_Price) + '\n$EVZ Rate '+tostring(EVZrate) + '\nPosition Size ' +tostring(final_dynamic_ratio) + "%"  + '\nProfit/Loss ' +tostring(display_profit) + "\n " + risk_text,
      color=color.gray, 
      textcolor= Entry_Long == true ? color.blue : Entry_Long_Cont == true ? color.blue : Entry_Short == true ? color.red : Entry_Short_Cont == true ? color.red : color.yellow,
      style=label.style_none,
      xloc = xloc.bar_time,
      yloc = yloc.price,
      size = size.large)
    label.delete(l2[1])
//}
//==============================================================================
// Profit Warning Lables
//==============================================================================
//{
if Hide_Overlay == true and ma_total2 == 2
    stratLabel = label.new(x=bar_index, y=na, text=risk_text2, yloc = yloc.abovebar, color=color.black, textcolor = color.green, style = label.style_labeldown)
    label.delete(stratLabel[1]) // Delete previous candle
//
if Hide_Overlay == true and ma_total2 == 1
    stratLabel = label.new(x=bar_index, y=na, text=risk_text2, yloc = yloc.abovebar, color=color.black, textcolor = color.orange, style = label.style_labeldown)
    label.delete(stratLabel[1]) // Delete previous candle
//
if Hide_Overlay == true and ma_total2 == 0
    stratLabel = label.new(x=bar_index, y=na, text=risk_text2, yloc = yloc.abovebar, color=color.black, textcolor = color.red, style = label.style_labeldown)
    label.delete(stratLabel[1]) // Delete previous candle
//}
//==============================================================================
// Plots for Debugging
//==============================================================================
//
//labelText =  "count close long" + tostring(Count_close_long )
//stratLabel = label.new(x=bar_index, y=na, text=labelText, yloc = yloc.abovebar, color=color.black, textcolor = color.white, style = label.style_labeldown)
//label.delete(stratLabel[1]) // Delete previous candle
//
//==============================================================================
//       "The goal of a successful trader is to make the best trades"
//                          "Money is Secondary"
//                         Quote - Alexander Elder
//==============================================================================