//@version=5
//study(title="Strength of Movement [andCROW] v4", shorttitle="SoMandCROW_4", overlay=false, resolution="", precision = 0)
strategy(title="Strength of Movement [andCROW] v4", shorttitle="SoMandCROW_4", overlay=false, commission_type=strategy.commission.percent, commission_value=0.1, default_qty_type=strategy.cash, default_qty_value=100, initial_capital=100, calc_on_order_fills=false, currency=currency.USD, pyramiding=1, precision = 0)

// === SoM INPUTS === {
var string group1 = "Strength of Movement (SoM)"
somSrc      = input.source (close, title = "SoM Source", group = group1)
somRange    = input.int    (4, title = "SoM Avg Range",  minval = 2, maxval = 5, group = group1)
inpHighLow  = "High / Low" , 
     inpOpenClose = "Open / Close"
somCalc     = input.string (inpOpenClose, title = "SoM Calculation", options = [inpOpenClose, inpHighLow], group = group1)
somLength   = input.int    (32, title = "SoM WMA Length",  minval = 1, group = group1)
somSmooth   = input.int    (1, title = "SoM SMA Smoothing",  minval = 1, group = group1)
somUpX      = input.int    (25, title = "SoM Upper X Line", minval = 1, maxval = 100, group = group1)
somLoX      = input.int    (-25, title = "SoM Lower X Line", minval = -100, maxval = -1, group = group1)
h_SoMUpX    = input.bool   (true, title="Hilite K_SoM x UpX", group = group1)
h_SoMLwX    = input.bool   (true, title="Hilite K_SoM x LoX", group = group1)
// }

// === SoM CALCULATIONS === {
moveOpenClose = somSrc - somSrc[somRange-1]
     // somCalculate average "directional" change per period
moveHighLow = (ta.highest(somSrc, somRange) - ta.lowest(somSrc, somRange)) * math.sign(moveOpenClose)
avgmove = somCalc == inpOpenClose ? moveOpenClose / (somRange - 1) : moveHighLow / (somRange - 1)
aa = nz(avgmove / somSrc[somRange-1])
     // for technical accuracy, convert somSrc change from absolute value to a ratio
b  = ta.wma(aa, somLength)
     // take the (weighted) average of the change ratio for a somLength of bars 
s  = ta.stoch(b, math.max(b,0), math.min(b,0), somLength) *2 -100     
     // scale the result as a +100/-100 oscillator
ss = ta.wma(s, somSmooth)
     // final smoothing
maxup = s == 100 ? 100 : na
maxdn = s == -100 ? -100 : na
     // apply circles at maxup/maxdn
ssCrossDown = ta.crossunder(ss, somUpX)
ssCrossUp = ta.crossover(ss, somLoX)
     // color bg when ssCrossDown/ssCrossUp
ssMaxUp = (s[1] == 100 or s[2] == 100 or s[3] == 100 or s[4] == 100 or s[5] == 100) ? true : false
ssMaxDn = (s[1] == -100 or s[2] == -100 or s[3] == -100 or s[4] == -100 or s[5] == -100) ? true : false
     // was anp at max in previous 4 candles?
// }

// === SoM PLOTS === {
// === COLORS
col_somraw = color.new(color.silver, 20)
col_trendup = color.new(color.blue, 0)
col_trenddn = color.new(color.purple, 0)
col_zeroline = color.new(color.silver, 20)
col_ssCrossHi = color.new(color.purple, 60)
col_ssCrossLo = color.new(color.blue, 60)
col_buyLong = color.new(color.green, 20)
col_sellLong = color.new(color.red, 20)
     //yellow with some transparency, which can't be set in hline()

// === HLINES
hline(  0,  "Zero Line", color = col_zeroline, linestyle = hline.style_solid)
hline(100,  "Upper Border", color = color.green, linestyle = hline.style_dotted)
hline(-100, "Lower Border", color = color.red, linestyle = hline.style_dotted)
hline(somUpX,  "Upper X Line", color = color.green, linestyle = hline.style_dotted)
hline(somLoX, "Lower X Line", color = color.red, linestyle = hline.style_dotted)

// === PLOTS
plot(s, title = "K_SoM Raw", color = col_somraw, linewidth = 1)
plot(ss, title = "K_SoM", color = ss >= 0 ? col_trendup : col_trenddn, linewidth = 3)
plot(maxup, "Max Strength", style = plot.style_circles, color = col_zeroline, linewidth = 3)
plot(maxdn, "Max Weakness", style = plot.style_circles, color = col_zeroline, linewidth = 3)

// === SIGNAL INDICATORS
bgcolor(color = ssCrossDown and h_SoMUpX? col_ssCrossLo : ssCrossUp and h_SoMLwX ? col_ssCrossHi : na)
    // highlight K_SoM (ss) crossing Hi/Lo Line
bgcolor(color = ssCrossDown and ssMaxUp ? col_sellLong : ssCrossUp and ssMaxDn ? col_buyLong : na)
    // highlight buy/sell conditions
// === }

// === ALERTS
//alertcondition(condition = ssCrossDown, message="Quick SoM dropped below slow Upper X Line")
//alertcondition(condition = ssCrossUp, message="Quick SoM crossed above slow Lower X Line")
// === }

// === STRATEGY ENTRY/EXIT === {
// Strategy calls to create single short and long trades
if ssCrossUp and ssMaxDn
    strategy.entry("Long Entry",  strategy.long)
else if ssCrossDown and ssMaxUp
    strategy.entry("Short Entry", strategy.short)
    
// When a new open trade is detected then we create the exit strategy corresponding with the matching entry id
// We detect the correct entry id by determining if a position is long or short based on the position quantity
if ta.change(strategy.opentrades)
    posSign = strategy.opentrades.size(strategy.opentrades - 1)
    strategy.exit(posSign > 0 ? "SL Long Exit" : "SL Short Exit", strategy.opentrades.entry_id(strategy.opentrades - 1), loss = 1.25, trail_points = 2.5, trail_offset = .5)

// When a new closed trade is detected then we place a label above the bar with the exit info
if ta.change(strategy.closedtrades)
    msg = "Trade closed by: " + strategy.closedtrades.exit_id(strategy.closedtrades - 1)
    label.new(bar_index, high + (3 * ta.tr), msg)



//
//entryCount = strategy.opentrades.size
//
//// LONGS
//strategy.entry(id = "Long1", qty = 75, direction = strategy.long, when = (entryCount == 0) and ssCrossUp, alert_message = "")
//strategy.entry(id = "Long2", qty = 75, direction = strategy.long, when = (entryCount == 1) and ssMaxDn, alert_message = "")
//strategy.entry(id = "Long3", qty = 75, direction = strategy.long, when = (entryCount == 2) and ssCrossUp and ssMaxDn, alert_message = "")
//strategy.entry(id = "Long4", qty = 75, direction = strategy.long, when = (entryCount == 3) and ssCrossUp and ssMaxDn, alert_message = "")
//
//strategy.exit(id = "Exit Long", from_entry = "Long1", loss = .8, trail_points = 1.6, trail_offset = .6, when = ssCrossDown, alert_message = "")
//strategy.exit(id = "Exit Long", from_entry = "Long2", loss = 1.25, trail_points = 2.5, trail_offset = .5,  when = ssMaxUp, alert_message = "")
//strategy.exit(id = "Exit Long", from_entry = "Long3", loss = 2.5, trail_points = 5, trail_offset = .1,  when = ssCrossDown and ssMaxUp, alert_message = "")
//strategy.exit(id = "Exit Long", from_entry = "Long4", loss = 15, trail_points = 30, trail_offset = 5,  when = ssCrossDown and ssMaxUp, alert_message = "")
//
//// SHORTS
//strategy.entry(id = "Short", direction = strategy.short, when = ssCrossDown and ssMaxUp, alert_message = "")
//
//strategy.exit(id = "Exit Short", from_entry = "Short", loss = 1.0, when = ssCrossUp and ssMaxDn, alert_message = "")
//
//strategy.entry("Long",  strategy.long,  when = goLong  and longPyramiding  <= pyramiding)
//strategy.entry("Short", strategy.short, when = goShort and shortPyramiding <= pyramiding)
//
//strategy.exit("Exit Long",  "Long",  loss=slPips * 10, trail_points=ttPips * 10, trail_offset=trailOffset * 10)
//strategy.exit("Exit Short", "Short", loss=slPips * 10, trail_points=ttPips * 10, trail_offset=trailOffset * 10)
// === }
