// This source code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/
// Â© RedKTrader

//@version=4
study(title="Strength of Movement [andCROW] v2", shorttitle="SoM_andCROW_v2", overlay=true, resolution="", precision = 0)
price   = input(title = "Source",       defval=close)
n       = input(title = "Range",        defval=3,   minval=2, maxval=5)
calc_hl = "High / Low" , calc_se = "Start / End"
calc    = input(title = "SoM Calculation", options = [calc_se, calc_hl], defval = calc_se)
length  = input(title = "Avg Length",   defval=32,  minval=1)
smooth  = input(title = "Smoothing",    defval=1,   minval=1)
upperX  = input(title = "Upper X Line",    defval=50,   minval=1, maxval=100)
lowerX  = input(title = "Lower X Line",    defval=-50,   minval=-100, maxval=-1)

h_SoMUpX  = input(true, title="Highlight when K_SoM x Upper_X_Line")
h_SoMLwX  = input(true, title="Highlight when K_SoM x Lower_X_Line")



// --************************--*************************-- //
           // -- Plot Bolinger Bands Example -- // 
// --************************--*************************-- //


maLengthInput = input.int(10,           "MA length", inline = "01", minval = 1)
maColorInput  = input.color(color.aqua, "",          inline = "01")
bbFactorInput = input.float(1.5,        "BB factor", inline = "02", minval = 0, step = 0.5)
bbColorInput  = input.color(color.gray, "",          inline = "02")
showBBInput   = input.bool(true,        "Show BB",   inline = "02")
ma      = ta.sma(close, maLengthInput)
bbWidth = ta.stdev(ma, maLengthInput) * bbFactorInput
bbHi    = ma + bbWidth
bbLo    = ma - bbWidth
bbHiColor = color.new(bbColorInput, high > bbHi ? 60 : 0)
bbLoColor = color.new(bbColorInput, low  < bbLo ? 60 : 0)
plot(ma, "MA", maColorInput)
plot(showBBInput ? bbHi : na, "BB Hi", bbHiColor, 2)
plot(showBBInput ? bbLo : na, "BB Lo", bbLoColor, 2)


// --************************--*************************-- //
          // -- Strength of Movement [SoM] -- // 
// --************************--*************************-- //

// a is the n-bar average change of price 
//   - used as a proxy for the "strength of movement"
//
// note that in an "n" number of bars, 
// there's actually (n-1) number of "change ranges" 
//
// v4.0 optional algos for calculation 
//   - start/end = takes start price 
//   - end price  -- this is simpler
//
// high/low  = takes highest - lowest of range 
//   - this exposes "breakout attempts"

// calculate average "directional" change per period
move_se = price - price[n-1]
//need to make this "directional" 
move_hl = (highest(price, n) - lowest(price, n)) * sign(move_se)  

avgmove = calc == calc_se ? 
  move_se / (n - 1) :
  move_hl / (n - 1)
  

// v2: for technical accuracy, convert price change from absolute value to a ratio
// take the (weighted) average of the change ratio for a length of bars 
aa      = nz(avgmove / price[n-1]) 
b       = wma(aa, length) 

// scale the result as a +100/-100 oscillator 
// v2: updated with adjustment of highest/lowest values to avoid the "confusing visual" 
s       = stoch(b, max(b,0), min(b,0), length) *2 -100     

// final smoothing
ss = wma(s, smooth)

//col_somraw      = color.new(color.silver, 80)
//col_trendup     = #2962ff
//col_trenddn     = #e91e63
//col_zeroline    = #ffee0044    //yellow with some transparency, which can't be set in hline()

//plots
//hline(  0,  "Zero Line",    color = col_zeroline,   linestyle = hline.style_solid)
//hline(120,  "Upper Border", color = color.green,    linestyle = hline.style_dotted)
//hline(-120, "Lower Border", color = color.red,      linestyle = hline.style_dotted)
//hline(upperX,  "Upper X Line", color = color.green,    linestyle = hline.style_dotted)
//hline(lowerX, "Lower X Line", color = color.red,      linestyle = hline.style_dotted)
//
//
//maxup = s == 100 ? 100 : na
//maxdn = s == -100 ? -100 : na
//plot(maxup, "Max Strength", style = plot.style_circles, color = col_trendup, linewidth = 3)
//plot(maxdn, "Max Weakness", style = plot.style_circles, color = col_trenddn, linewidth = 3)

x_SoMUpX = (s[1] == 100 or s[2] == 100 or s[3] == 100 or s[4] == 100) ? true : false
x_SoMLwX = (s[1] == -100 or s[2] == -100 or s[3] == -100 or s[4] == -100) ? true : false


//if ((x_SoMUpX) and (h_SoMUpX)) or ((x_SoMLwX) and (h_SoMLwX))
//plot(s,  title = "K_SoM Raw",   color = col_somraw,  linewidth = 1)
//plot(ss, title = "K_SoM",       color= ss >=0 ? col_trendup : col_trenddn, linewidth = 3)

//plot(bar_index, close, title = "K_SoM",      color= ss >=0 ? col_trendup : col_trenddn, linewidth = 3)


ssCrossDown = crossunder(ss, upperX) and h_SoMUpX and x_SoMUpX
ssCrossUp   = crossover(ss, lowerX) and h_SoMLwX and x_SoMLwX


plotarrow(series=ssCrossDown ? -1 :
     ssCrossUp ? 1 :
     na)

alertcondition(condition=ssCrossDown,
     message="Quick SoM dropped below slow Upper X Line")

alertcondition(condition=ssCrossUp,
     message="Quick SoM crossed above slow Lower X Line")


//rsiCrossDown = crossunder(rsi(close, 7), rsi(close, 21))
//rsiCrossUp   = crossover(rsi(close, 7), rsi(close, 21))
//
//
//plotarrow(series=rsiCrossDown ? -1 :
//     rsiCrossUp ? 1 :
//     na)
//
//alertcondition(condition=rsiCrossDown,
//     message="Quick RSI dropped below slow RSI")
//
//alertcondition(condition=rsiCrossUp,
//     message="Quick RSI crossed above slow RSI")


//plotshape(x_SoMUpX, "K_SoM crossed Upper X Line", shape.arrowdown, color=color.green, size.large)
//plotshape(x_SoMLwX, "K_SoM crossed Lower X Line", shape.arrowup, color=color.blue, location.belowbar, size.large)

//if (x_SoMUpX) and (h_SoMUpX)
//    line.new(bar_index, close, bar_index, close * 1.01, color = color.green, extend = extend.both)
//    plotarrow

//if (x_SoMLwX) and (h_SoMLwX)
//    line.new(bar_index, close, bar_index, close * 1.01, color = color.red, extend = extend.both)