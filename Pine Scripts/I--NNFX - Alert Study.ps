// Written by Christopher Fraser
//
// Adapted from Various Credited open sources, see below
//
// Using NNFX Principles
//
// Above/Below Baseline represents Long/Short area
// C1 & C2 combine to show areas of trend
// Grey Candles are areas when trend not established
// Low Volume shows as Red Background 
// ATR Bands for Visual Indication Only
// ATR based TP and SL/TSL prices/values to assist Risk Managed position sizing
// Tunable Exit Indicators
// Restrict Entry based on how far price has moved from Baseline (Default 1.5x ATR, Tunable)
// Tunable Continuation Criteria (SSL & ATR Based)
// 
// Entry Indicated by a Blue Arrow Above/Below Candle in Direction of Price Movement
// Exit Indicated by a Yellow Arrow Above/Below Candle in Direction of Price Movement
//
//
// Coders/Modifiers, Code Sections made collapsable. Hide/Unhide indicatior by line number
// 
// Credits
//
// Strategy - causecelebre - https://www.tradingview.com/u/causecelebre/
// SSL Channel - ErwinBeckers - https://www.tradingview.com/u/ErwinBeckers/
// Moving Averages - jiehonglim - https://www.tradingview.com/u/jiehonglim/
// Moving Averages - everget - https://www.tradingview.com/u/everget/
// Damian Volameter - xinolia - https://www.tradingview.com/v/MhBm66Wh/
// QQE Mod - Mihkel00 - https://www.tradingview.com/v/TpUW4muw/
// SSL Hybrid - Mihkel00 - https://www.tradingview.com/v/C3MlAWCw/
// Absolute Strength Histrogram - jiehonglim - https://uk.tradingview.com/script/PORR7A3k-Absolute-Strength-Histogram-v2-jh/
// Dillon Grech - https://www.youtube.com/watch?v=_uS8L64QsyI&list=PLlrbkHtbSFWL00pUwbYiYgHpUgso1j47u
// Super Trend - Sickojacko - https://uk.tradingview.com/script/qzo1iOfs-Super-SSL/
// Accelerator Oscillator - Hpotter - https://uk.tradingview.com/script/6bta0VWS-Accelerator-Oscillator-AC/
// KDJ - x4random - https://uk.tradingview.com/v/VLaO5HdZ/
// Waddah Attar Explosion - LazyBear - https://www.tradingview.com/script/iu3kKWDI-Waddah-Attar-Explosion-LazyBear/
// Cronex T Demarker - romulodl - Github
// Kuskus Starlight - https://www.tradingview.com/script/nZuBWW9j-Jurik-Moving-Average/
// Squeeze Momentum Indicator - Lazybear - https://www.tradingview.com/script/nqQ1DT5a-Squeeze-Momentum-Indicator-LazyBear/
// Anchored Momentum - Lazybear - https://uk.tradingview.com/script/TBTFDWDq-Anchored-Momentum-LazyBear/ 
// Wave Trend Occilator - Lazybear - https://www.tradingview.com/script/2KE8wTuF-Indicator-WaveTrend-Oscillator-WT/
// Trend Magic - KivancOzbilgic - https://www.tradingview.com/script/kRIjThLZ-Trend-Magic/
// Currency Strength - Boitoki - https://www.tradingview.com/v/kKZROEeM/
// ATR+Kijun-Sen - racer8 - https://www.tradingview.com/script/tVS7ATGw-ATR-Kijun-Sen/
//
// Script Revision 14 - Match Version 30 of Tester
// 20th April 2021
//
// @version=4
//
study("NNFX - Alert Study ", overlay=true)
//
//==============================================================================
// Rules Inputs
//==============================================================================
//{
A_Bridge = input(false, title='A Bridge Too Far', group = "Entry Rules")
One_Candle = input(false, title='One Candle Rule', group = "Entry Rules")
Movement_Favour = input(false, title='Only Enter after/on Candle Moving in Direction of Trade - initial', group = "Entry Rules")
Movement_Favour_Cont = input(false, title='Only Enter after/on Candle Moving in Direction of Trade - continuation', group = "Entry Rules")
Use_C1 = input(false, title='Use Confirmation 1 Indicator', group = "Entry Rules")
Use_C2 = input(false, title='Use Confirmation 2 Indicator', group = "Entry Rules")
Use_Vol = input(false, title='Use Volume', group = "Entry Rules")
//
Baseline_ATR_Cross = input(1.0, title='Baseline ATR Cross Rule * ATR Value', group = "Entry Rules")
TP_ATR_Var = input(1.0, title='Take Profit ATR Value - * ATR Value', group = "Exit Rules")
TSL_ATR_Var= input(1.5, title='Trailing/Stoploss ATR Rule - * ATR Value', group = "Exit Rules")
SL_Type= input(title='Stoploss Type - Fixed/Trailing is Fixed until TP1 is hit, remaining part moves to trailing', type=input.string, defval="Trailing", options=["Trailing","Fixed","Fixed/Trailing"], group = "Exit Rules")
TL_Break_Even= input(false, title='TP to Break Even once TP1 hit - Fixed Stops only', group = "Exit Rules")
FT_ATR_Var= input(1.5, title='Fixed/Trailing second part trailing ATR Rule - * ATR Value', group = "Exit Rules")
//
Use_EVZ= input(false, title='Use $EVZ Filter', group = "$EVZ Rules")
Lower_EVZ= input(1.0, title='Do not Trade when $EVZ is BELOW this value', group = "$EVZ Rules")
Upper_EVZ= input(20.0, title='Double Risk when $EVZ is ABOVE this value', group = "$EVZ Rules")
//
Use_Strength = input(false, title='Use Currency Strength Filter - Innitial Trade', group = "Currency Strength Rules")
Use_Strength_Cont = input(false, title='Use Currency Strength Filter - Continuation Trade', group = "Currency Strength Rules")
Strength_Value = input(3.0, title='No Trade when currency strength below (0 weak - 10 Strong)', group = "Currency Strength Rules")
//}
//
//==============================================================================
// $EVZ
//==============================================================================
//{
EVZrate = security("EVZ", "D", close[1])
//
Block_EVZ = EVZrate < Lower_EVZ ? true : false
//
Up_Risk_EVZ_cal = EVZrate > Upper_EVZ ? true : false
Up_Risk_EVZ = Up_Risk_EVZ_cal and Use_EVZ
//}
//
//==============================================================================
// Set Counters
//==============================================================================
//{
Count_open_long = float(0.0)
Count_open_short = float(0.0)
Count_open_long_cont = float(0.0)
Count_open_short_cont = float(0.0)
Count_close_long = float(0.0)
Count_close_short = float(0.0)
Count_blc_long = float(0.0)
Count_blc_short = float(0.0)
Count_confirm_long = float(0.0)
Count_confirm_short = float(0.0)
//}
//
//==============================================================================
// Select C1 & C2
//==============================================================================
//{
C1_Type= input(title="C1 Indicator Type", type=input.string, defval="Accel_Oscillator", options=["Accel_Oscillator","Vortex_Indicator","QQE","Aroon","SSL_C1","Cronex_T_Demarker_Z_Cross","Squeeze_Momentum_Indicator","Price_Momentum_Oscillator","Anchored_Momentum","Wave_Trend_Oscillator","ATR+Kijun-Sen"], group = "Confirmation Indicators")
//
C2_Type = input(title="C2 Indicator Type", type=input.string, defval="Abs_Str_Histo", options=["Abs_Str_Histo","Super_Trend","QQE_Histo","KDJ","SSL_C2","Kuskus_Starlight","FX_Sniper_Ergodic","Coppock_curve","Trend_Magic","Willians_%R"], group = "Confirmation Indicators")
//}
//
//==============================================================================
// Select Volume Indicator
//==============================================================================
//{
Vol_Type= input(title="Volume Indicator Type", type=input.string, defval="Damiani_Volameter", options=["Damiani_Volameter","Waddah_Attar_Explosion"], group = "Volume Indicators")
//}
//
//==============================================================================
// C1 Accelerator Oscillator
//==============================================================================
//{
nLengthSlow = input(34, minval=1, title="Length Slow", group = "C1 Accelerator Oscillator")
nLengthFast = input(5, minval=1, title="Length Fast", group = "C1 Accelerator Oscillator")
xSMA1_hl2 = sma(hl2, nLengthFast)
xSMA2_hl2 = sma(hl2, nLengthSlow)
xSMA1_SMA2 = xSMA1_hl2 - xSMA2_hl2
xSMA_hl2 = sma(xSMA1_SMA2, nLengthFast)
nRes =  xSMA1_SMA2 - xSMA_hl2
Acc_Long = nRes > nRes[1]
Acc_Short = not Acc_Long
//}
//
//==============================================================================
// C1 Vortex Indicator
//==============================================================================
//{
period_ = input(14, title="Length", minval=2, group = "C1 Vortex Indicator")
deadband = input(1.10, title="Value - Min 1.0 - Recommended 1.05 to 1.1 ", minval=1, group = "C1 Vortex Indicator")
VMP = sum( abs( high - low[1]), period_ )
VMM = sum( abs( low - high[1]), period_ )
STR = sum( atr(1), period_ )
VIP = VMP / STR
VIM = VMM / STR
//
VI_Long = ((VIP > VIM) and (VIP > deadband))
VI_Short = ((not (VIP > VIM)) and (VIM > deadband))
//}
//
//==============================================================================
// C1 QQE
//==============================================================================
//{
RSI_Period = input(6, title='RSI Length', group = "C1 QQE")
SF = input(5, title='RSI Smoothing', group = "C1 QQE")
QQE = input(3, title='Fast QQE Factor', group = "C1 QQE")
ThreshHold = input(3, title="Thresh-hold", group = "C1 QQE")
//
src2 = input(close, title="RSI Source", group = "C1 QQE")
//
Wilders_Period = RSI_Period * 2 - 1
//
Rsi = rsi(src2, RSI_Period)
RsiMa = ema(Rsi, SF)
AtrRsi = abs(RsiMa[1] - RsiMa)
MaAtrRsi = ema(AtrRsi, Wilders_Period)
dar = ema(MaAtrRsi, Wilders_Period) * QQE
//
longband = 0.0
shortband = 0.0
trend = 0
//
DeltaFastAtrRsi = dar
RSIndex = RsiMa
newshortband = RSIndex + DeltaFastAtrRsi
newlongband = RSIndex - DeltaFastAtrRsi
longband := RSIndex[1] > longband[1] and RSIndex > longband[1] ? 
   max(longband[1], newlongband) : newlongband
shortband := RSIndex[1] < shortband[1] and RSIndex < shortband[1] ? 
   min(shortband[1], newshortband) : newshortband
cross_1 = cross(longband[1], RSIndex)
trend := cross(RSIndex, shortband[1]) ? 1 : cross_1 ? -1 : nz(trend[1], 1)
FastAtrRsiTL = trend == 1 ? longband : shortband
//
length = input(50, minval=1, title="Bollinger Length", group = "C1 QQE")
mult2 = input(0.35, minval=0.001, maxval=5, step=0.1, title="BB Multiplier", group = "C1 QQE")
basis = sma(FastAtrRsiTL - 50, length)
dev = mult2 * stdev(FastAtrRsiTL - 50, length)
upper = basis + dev
lower = basis - dev
//
// Zero cross
QQEzlong = 0
QQEzlong := nz(QQEzlong[1])
QQEzshort = 0
QQEzshort := nz(QQEzshort[1])
QQEzlong := RSIndex >= 50 ? QQEzlong + 1 : 0
QQEzshort := RSIndex < 50 ? QQEzshort + 1 : 0
//  
QQE_Long = RsiMa - 50 > upper
QQE_Short = RsiMa - 50 < lower
//}
//
//==============================================================================
// C1 Aroon
//==============================================================================
//{
Aroonlength = input(12, minval=1, group = "C1 Aroon")
Aroonupper = 100 * (highestbars(high, Aroonlength+1) + Aroonlength)/Aroonlength
Aroonlower = 100 * (lowestbars(low, Aroonlength+1) + Aroonlength)/Aroonlength
//
Ind_1_L_Trigger = (C1_Type == "Aroon") ? (Aroonupper > Aroonlower)  ? true : false : false
Ind_1_S_Trigger = (C1_Type == "Aroon") ? (Aroonupper < Aroonlower) ? true : false : false
//}
//
//==============================================================================
// C1 SSL
//==============================================================================
//{
period_SSL_c1=input(title="Period", defval=10, group = "C1 SSL")
len_SSL_c1=input(title="Period", defval=10, group = "C1 SSL")
smaHigh_SSL_c1=sma(high, len_SSL_c1)
smaLow_SSL_c1=sma(low, len_SSL_c1)
Hlv_SSL_c1 = 0
Hlv_SSL_c1 := close > smaHigh_SSL_c1 ? 1 : close < smaLow_SSL_c1 ? -1 : Hlv_SSL_c1[1]
sslDown_SSL_c1 = Hlv_SSL_c1 < 0 ? smaHigh_SSL_c1: smaLow_SSL_c1
sslUp_SSL_c1   = Hlv_SSL_c1 < 0 ? smaLow_SSL_c1 : smaHigh_SSL_c1
//
long_SSL_c1 = sslUp_SSL_c1 > sslDown_SSL_c1 
short_SSL_c1 = sslUp_SSL_c1 < sslDown_SSL_c1 
//}
//
//==============================================================================
// C1 Cronex T Demarker Zero Cross 
//==============================================================================
//{
demarker_length = input(24, group = "C1 - Cronex T Demarker")
dem_step = input(4, group = "C1 - Cronex T Demarker")
curvature = input(0.618, group = "C1 - Cronex T Demarker")
//
e1 = 0.0
e2 = 0.0
e3 = 0.0
e4 = 0.0
e5 = 0.0
e6 = 0.0
//
deMax = high - high[1] > 0 ? high - high[1] : 0
deMin = low[1] - low > 0 ? low[1] - low : 0
//
demarker(dem_length) =>
    sma_deMax = sma(deMax, dem_length)
    sma_deMin = sma(deMin, dem_length)
    sma_deMax / (sma_deMax + sma_deMin)
//
n  = 1 + 0.5 * (demarker_length - 1)
w1 = 2 / (demarker_length + 1)
w2 = 1 - w1
b2 = curvature * curvature
b3 = b2 * curvature
c1 = -b3
c2 = (3 * (b2 + b3))
c3 = -3 * (2 * b2 + curvature + b3)
c4 = (1 + 3 * curvature + b3 + 3 * b2)
//
demarker_v = (demarker(demarker_length) + demarker(demarker_length + dem_step) + demarker(demarker_length + dem_step * 2) + demarker(demarker_length + dem_step * 3)) * 100 / 4 - 50
e1 := not na(demarker_v) ? w1 * demarker_v + w2 * e1[1] : 0
e2 := not na(demarker_v) ? w1 * e1 + w2 * e2[1] : 0
e3 := not na(demarker_v) ? w1 * e2 + w2 * e3[1] : 0
e4 := not na(demarker_v) ? w1 * e3 + w2 * e4[1] : 0
e5 := not na(demarker_v) ? w1 * e4 + w2 * e5[1] : 0
e6 := not na(demarker_v) ? w1 * e5 + w2 * e6[1] : 0
//
demarker_t = c1*e6 + c2*e5 + c3*e4 + c4*e3
//
Demarker_Long = crossover(demarker_v, 0)
Demarker_Short = crossunder(demarker_v, 0)
//
//remove comments to use as C1 triggers - AS A SIGNAL LINE CROSS
//Ind_1_Check_Trig = input(true, title = "Indicator 1 - C1 - Trigger")
//Ind_1_L_Trigger = Ind_1_Check_Trig ? crossover(demarker_v, demarker_t) : false
//Ind_1_S_Trigger = Ind_1_Check_Trig ? crossunder(demarker_v, demarker_t) : false
//
//remove comments to use as C2 confirmation
//Ind_2_Check_Conf = input(true, title = "Indicator 2 - C2 - Confirmation")
//Ind_2_L_Conf = Ind_2_Check_Conf ? demarker_v > 0 : true
//Ind_2_S_Conf = Ind_2_Check_Conf ? demarker_v < 0 : true
//}
//
//==============================================================================
// C1 Squeeze Momentum Indicator
//==============================================================================
//{
bb_squeeze_length       = input(20, title="BB Length", group = "C1 - Squeeze Momentum Indicator")
bb_squeeze_mult         = input(2.0,title="BB MultFactor", group = "C1 - Squeeze Momentum Indicator")
bb_squeeze_lengthKC     = input(20, title="KC Length", group = "C1 - Squeeze Momentum Indicator")
bb_squeeze_multKC       = input(1.5, title="KC MultFactor", group = "C1 - Squeeze Momentum Indicator")
bb_squeeze_useTrueRange = input(true, title="Use TrueRange (KC)", type=input.bool, group = "C1 - Squeeze Momentum Indicator")
//
// Calculate BB
source2 = close
basis2 = sma(source2, bb_squeeze_length)
dev2 = bb_squeeze_mult * stdev(source2, bb_squeeze_length)
upperBB = basis2 + dev2
lowerBB = basis2 - dev2
//
// Calculate KC
ma2 = sma(source2, bb_squeeze_lengthKC)
range2 = bb_squeeze_useTrueRange ? tr : (high - low)
rangema2 = sma(range2, bb_squeeze_lengthKC)
upperKC = ma2 + rangema2 * bb_squeeze_multKC
lowerKC = ma2 - rangema2 * bb_squeeze_multKC
//
sqzOn  = (lowerBB > lowerKC) and (upperBB < upperKC)
sqzOff = (lowerBB < lowerKC) and (upperBB > upperKC)
noSqz  = (sqzOn == false) and (sqzOff == false)
//
bb_squeeze_val = linreg(source2  -  avg(avg(highest(high, bb_squeeze_lengthKC), lowest(low, bb_squeeze_lengthKC)),sma(close,bb_squeeze_lengthKC)), bb_squeeze_lengthKC,0)
//
Squeeze_Long = crossover(bb_squeeze_val, 0)
Squeeze_Short = crossunder(bb_squeeze_val, 0)
//}
//
//==============================================================================
// C1 Price Momentum Oscillator
//==============================================================================
//{
PMOfirstLength = input(title="1st Smoothing Length", type=input.integer, defval=35, group = "C1 - Price Momentum Oscillator")
PMOsecondLength = input(title="2nd Smoothing Length", type=input.integer, defval=20, group = "C1 - Price Momentum Oscillator")
PMOsignalLength = input(title="Signal Length", type=input.integer, defval=10, group = "C1 - Price Momentum Oscillator")
PMOsrc = input(title="Source", type=input.source, defval=close, group = "C1 - Price Momentum Oscillator")
PMOpmo = ema(10 * ema(nz(roc(PMOsrc, 1)), PMOfirstLength), PMOsecondLength)
PMOsignal = ema(PMOpmo, PMOsignalLength)
//
Momentum_Long = crossover(PMOpmo, PMOsignal) 
Momentum_Short = crossunder(PMOpmo, PMOsignal)
//}
//==============================================================================
// C1 Anchored Momentum
//==============================================================================
//{
AMOM_LB_src=close
AMOM_LB_l=input(8, title="Momentum Period", group = "C1 - Anchored Momentum")
AMOM_LB_sl=input(10, title="Signal Period", group = "C1 - Anchored Momentum")
AMOM_LB_sm=input(true, title="Smooth Momentum", group = "C1 - Anchored Momentum")
AMOM_LB_smp=input(5, title="Smoothing Period", group = "C1 - Anchored Momentum")
AMOM_LB_p=2*AMOM_LB_l+1
AMOM_LB_amom=100*(((AMOM_LB_sm?sma(AMOM_LB_src,AMOM_LB_smp):AMOM_LB_src)/(sma(AMOM_LB_src,AMOM_LB_p)) - 1))
AMOM_LB_amoms=sma(AMOM_LB_amom, AMOM_LB_sl)
//
Anchored_Long = crossover(AMOM_LB_amom, AMOM_LB_amoms)
Anchored_Short = crossunder(AMOM_LB_amom, AMOM_LB_amoms)
//}
//==============================================================================
// C1 Wave Trend Oscillator
//==============================================================================
//{
wt_n1 = input(10, "Channel Length", group = "C1 - Wave Trend Oscillator")
wt_n2 = input(21, "Average Length", group = "C1 - Wave Trend Oscillator")
wt_s  = input(4, "Signal Length", group = "C1 - Wave Trend Oscillator")
// 
wt_ap = hlc3 
wt_esa = ema(wt_ap, wt_n1)
wt_d = ema(abs(wt_ap - wt_esa), wt_n1)
wt_ci = (wt_ap - wt_esa) / (0.015 * wt_d)
wt_tci = ema(wt_ci, wt_n2)
// 
wt1 = wt_tci
wt2 = sma(wt1, wt_s)
//
Wave_Trend_Long = crossover(wt1, 0)
Wave_Trend_Short = crossunder(wt1, 0)
//}
//
//==============================================================================
// C1 ATR+Kijun-Sen
//==============================================================================
//{
n_AKS = input(26,"Length", group = "C1 - ATR+Kijun-Sen")
h_AKS = highest(high,n_AKS)
l_AKS = lowest(low,n_AKS)
a_AKS = (h_AKS+l_AKS)/2
//
Atr_AKS=input(defval=5,title="Atr Period",minval=1,maxval=500, group = "C1 - ATR+Kijun-Sen")
Hhv_AKS=input(defval=10,title="HHV Period",minval=1,maxval=500, group = "C1 - ATR+Kijun-Sen")
Mult_AKS=input(defval=2.5,title="Multiplier",minval=0.1, group = "C1 - ATR+Kijun-Sen")
//
Prev_AKS = highest(high-Mult_AKS*atr(Atr_AKS),Hhv_AKS),barssince(close>highest(high-Mult_AKS*atr(Atr_AKS),Hhv_AKS) and close>close[1])
TS_AKS = iff(cum(1)<16 ,close,iff( close > highest(high-Mult_AKS*atr(Atr_AKS),Hhv_AKS) and close>close[1],highest(high-Mult_AKS*atr(Atr_AKS),Hhv_AKS),Prev_AKS))
//
Long_AKS = crossover(close,TS_AKS)
Short_AKS = crossunder(close,TS_AKS)
//}

//==============================================================================
// C2 Absolute Strength Histogram v2
//==============================================================================
//{
//
Length = input(9,title="Period of Evaluation", type=input.integer, group = "C2 Abs Strength Histo")
Smooth = input(3,title="Period of Smoothing", type=input.integer, group = "C2 Abs Strength Histo")
//
src_asi =  input(close,title="Source", group = "C2 Abs Strength Histo")
Mode = input(title="Indicator Method", type=input.string, defval="RSI", options=["RSI", "STOCHASTIC","ADX"], group = "C2 Abs Strength Histo")
ma_type = input(title="MA", type=input.string, defval="WMA", options=["ALMA", "EMA", "WMA", "SMA", "SMMA", "HMA"], group = "C2 Abs Strength Histo")
alma_offset  = input(defval=0.85, title="* Arnaud Legoux (ALMA) Only - Offset Value", minval=0, step=0.01, group = "C2 Abs Strength Histo")
alma_sigma   = input(defval=6, title="* Arnaud Legoux (ALMA) Only - Sigma Value", minval=0, group = "C2 Abs Strength Histo")
//
ma_asi(type, src_asi, len) =>
    float result = 0
    if type=="SMA" // Simple
        result := sma(src_asi, len)
    if type=="EMA" // Exponential
        result := ema(src_asi, len)
    if type=="WMA" // Weighted
        result := wma(src_asi, len)
    if type=="SMMA" // Smoothed
        w = wma(src_asi, len)
        result := na(w[1]) ? sma(src_asi, len) : (w[1] * (len - 1) + src_asi) / len
    if type=="HMA" // Hull
        result := wma(2 * wma(src_asi, len / 2) - wma(src_asi, len), round(sqrt(len)))
    if type=="ALMA" // Arnaud Legoux
        result := alma(src_asi, len, alma_offset, alma_sigma)
    result
//
Price = src_asi
//
Price1 = ma_asi("SMA",Price,1)
Price2 = ma_asi("SMA",Price[1],1)
//
//RSI
Bulls0 = 0.5*(abs(Price1-Price2)+(Price1-Price2))
Bears0 = 0.5*(abs(Price1-Price2)-(Price1-Price2))
//
//STOCHASTIC
Bulls1 = Price1 - lowest(Price1,Length)
Bears1 = highest(Price1,Length) - Price1
//
//ADX
Bulls2 = 0.5*(abs(high-high[1])+(high-high[1]))
Bears2 = 0.5*(abs(low[1]-low)+(low[1]-low))
//
Bulls = Mode == "RSI" ? Bulls0 : Mode == "STOCHASTIC" ? Bulls1 : Bulls2
Bears = Mode == "RSI" ? Bears0 : Mode == "STOCHASTIC" ? Bears1 : Bears2
AvgBulls=ma_asi(ma_type,Bulls,Length)     
AvgBears=ma_asi(ma_type,Bears,Length)
//
SmthBulls=ma_asi(ma_type,AvgBulls,Smooth)  
SmthBears=ma_asi(ma_type,AvgBears,Smooth)
//
ASI_Long = (SmthBulls<SmthBulls[1])
ASI_Short = (SmthBears<SmthBears[1])
//}
//
//==============================================================================
// C2 Super Trend
//==============================================================================
//{
ST_mult   = input(1.5,   title = 'SuperTrend Multiplier', minval = 0, maxval = 100, step = 0.1, group = "C2 Super Trend")
ST_length = input(15, title = 'SuperTrend Period', minval = 1, group = "C2 Super Trend")
//
src_ST = input(title="Source", type=input.source, defval=close, group = "C2 Super Trend")
//
// super trend current state
st_state = bool(na)
//
get_st_state() =>
    
    return = int(0)
    trend = int(0)

    up_level = float(0.0)
    dn_level = float(0.0)
    up_trend   = float(0.0)
    down_trend = float(0.0)
    
    super_trend_line = float(0.0)

    
    up_level := hl2 - (ST_mult * atr(ST_length))
    dn_level := hl2 + (ST_mult * atr(ST_length))

    up_trend   := close[1] > up_trend[1]   ? max(up_level, up_trend[1])   : up_level
    down_trend := close[1] < down_trend[1] ? min(dn_level, down_trend[1]) : dn_level
    
    trend := close > down_trend[1] ? 1: close < up_trend[1] ? -1 : nz(trend[1], 1)
    
    if (trend == 1)
        super_trend_line := up_trend 
    else 
        super_trend_line := down_trend
            
    long_state = close - super_trend_line > 0        
    
    return := 0
    if long_state
        return := 1
    else
        return := -1

    return
//
st_state := get_st_state()    
long_ST = st_state[1] == 1 ? true : false
short_ST = st_state[1] == -1 ? true : false
//}
//
//==============================================================================
// C2 QQE Historian
//==============================================================================
//{
RSI_Period2 = input(6, title='RSI Length', group = "C2 QQE")
SF2 = input(5, title='RSI Smoothing', group = "C2 QQE")
QQE2 = input(1.61, title='Fast QQE2 Factor', group = "C2 QQE")
ThreshHold2 = input(3, title="Thresh-hold", group = "C2 QQE")
//
src3 = input(close, title="RSI Source", group = "C2 QQE")
//
Wilders_Period2 = RSI_Period2 * 2 - 1
//
Rsi2 = rsi(src3, RSI_Period2)
RsiMa2 = ema(Rsi2, SF2)
AtrRsi2 = abs(RsiMa2[1] - RsiMa2)
MaAtrRsi2 = ema(AtrRsi2, Wilders_Period2)
dar2 = ema(MaAtrRsi2, Wilders_Period2) * QQE2
longband2 = 0.0
shortband2 = 0.0
trend2 = 0
//
DeltaFastAtrRsi2 = dar2
RSIndex2 = RsiMa2
newshortband2 = RSIndex2 + DeltaFastAtrRsi2
newlongband2 = RSIndex2 - DeltaFastAtrRsi2
longband2 := RSIndex2[1] > longband2[1] and RSIndex2 > longband2[1] ? 
   max(longband2[1], newlongband2) : newlongband2
shortband2 := RSIndex2[1] < shortband2[1] and RSIndex2 < shortband2[1] ? 
   min(shortband2[1], newshortband2) : newshortband2
cross_2 = cross(longband2[1], RSIndex2)
trend2 := cross(RSIndex2, shortband2[1]) ? 1 : cross_2 ? -1 : nz(trend2[1], 1)
FastAtrRsi2TL = trend2 == 1 ? longband2 : shortband2
//
// Zero cross
QQE2zlong = 0
QQE2zlong := nz(QQE2zlong[1])
QQE2zshort = 0
QQE2zshort := nz(QQE2zshort[1])
QQE2zlong := RSIndex2 >= 50 ? QQE2zlong + 1 : 0
QQE2zshort := RSIndex2 < 50 ? QQE2zshort + 1 : 0
//  
QQE_Histo_Long = RsiMa2 - 50 > ThreshHold2
QQE_Histo_Short = RsiMa2 - 50 < 0 - ThreshHold2
//}
//
//==============================================================================
// C2 KDJ
//==============================================================================
//{
length_KDJ = input(9, title="period", group = "C2 KDJ")
signal_KDJ = input(3, title="signal", group = "C2 KDJ")
hi = highest(high, length_KDJ)
lo = lowest(low , length_KDJ)
k = 100*((close-lo)/(hi-lo))
pK = rma(k, signal_KDJ)
pD = rma(pK, signal_KDJ)
pJ = 3*pK-2*pD
//
long_KDJ = pJ > (avg(pK, pD))
short_KDJ = not long_KDJ
//}
//
//==============================================================================
// C2 SSL
//==============================================================================
//{
period_SSL_c2=input(title="Period", defval=10, group = "C2 SSL")
len_SSL_c2=input(title="Period", defval=10, group = "C2 SSL")
smaHigh_SSL_c2=sma(high, len_SSL_c2)
smaLow_SSL_c2=sma(low, len_SSL_c2)
Hlv_SSL_c2 = 0
Hlv_SSL_c2 := close > smaHigh_SSL_c2 ? 1 : close < smaLow_SSL_c2 ? -1 : Hlv_SSL_c2[1]
sslDown_SSL_c2 = Hlv_SSL_c2 < 0 ? smaHigh_SSL_c2: smaLow_SSL_c2
sslUp_SSL_c2   = Hlv_SSL_c2 < 0 ? smaLow_SSL_c2 : smaHigh_SSL_c2
//
long_SSL_c2 = sslUp_SSL_c2 > sslDown_SSL_c2
short_SSL_c2 = sslUp_SSL_c2 < sslDown_SSL_c2 
//}
//
//
//==============================================================================
// C2 Kuskus_Starlight
//==============================================================================
//{
kuskus_range = input(30, title="Range Periods", group = "C2 - Kuskus Starlight")
pricesmoothing = input(0.3, title="Price Smoothing", group = "C2 - Kuskus Starlight")
indexsmoothing = input(0.3, title="Index Smoothing", group = "C2 - Kuskus Starlight")
highesthigh = highest( high, kuskus_range)
lowestlow = lowest(low, kuskus_range)
greatestrange = 0.0
greatestrange := (highesthigh - lowestlow) != 0 ? (highesthigh - lowestlow) : greatestrange[1]
midprice = (high + low) / 2
pricelocation = 2 * ((midprice - lowestlow) / greatestrange) - 1
extmapbuffer = 0.0
extmapbuffer := pricesmoothing *nz(extmapbuffer[1]) + (1 - pricesmoothing) * pricelocation
smoothedlocation = 0.0
smoothedlocation := (extmapbuffer > 0.99 ? 0.99 : (extmapbuffer < -0.99 ? -0.99 : extmapbuffer)) != 1 ? (extmapbuffer >0.99 ? 0.99 : (extmapbuffer < -0.99 ? -0.99 : extmapbuffer)) : smoothedlocation[1]
fishindex = log(( 1 + smoothedlocation) / (1 - smoothedlocation))
extmapbuffer1 = 0.0
extmapbuffer1 := indexsmoothing * nz(extmapbuffer1[1]) + ( 1 - indexsmoothing) * fishindex
kuskus = extmapbuffer1
//
Kuskus_Long = kuskus > 0
Kuskus_Short = kuskus < 0
//}
//
//==============================================================================
// C2 FX Sniper Ergodic CCI
//==============================================================================
//{
period_q      = input(title="Q smoothing period", defval=2, group = "C2 - FX Sniper Ergodic CCI")
period_r      = input(title="R smoothing period", defval=10, group = "C2 - FX Sniper Ergodic CCI")
period_s      = input(title="S smoothing period", defval=5, group = "C2 - FX Sniper Ergodic CCI")
signal_period = input(title="Signal Period", defval=3, group = "C2 - FX Sniper Ergodic CCI")
//
ecci_mom     = close - close[1]
ecci_abs_mom = abs(ecci_mom)
ecci_var1    = ema(ecci_mom, period_q)
ecci_var2    = ema(ecci_var1, period_r)
ecci_var2a   = ema(ecci_abs_mom, period_q)
ecci_var2b   = ema(ecci_var2a, period_r)
ecci_var2c   = ema(ecci_var2, period_s)
ecci_var3    = ema(ecci_var2b, period_s)
//
ergodic_cci = (500 * ecci_var2c) / ecci_var3
signal_line = ema(ergodic_cci, signal_period)
//
Sniper_Long = crossover(ergodic_cci, signal_line)
Sniper_Short = crossunder(ergodic_cci, signal_line)
//}
//
//==============================================================================
// C2 Coppock curve
//==============================================================================
//{
//
coppock_curve_wma_length = input(title="WMA Length", type=input.integer, defval=10, group = "C2 - Coppock curve")
coppock_curve_longRoCLength = input(title="Long RoC Length", type=input.integer, defval=14, group = "C2 - Coppock curve")
coppock_curve_shortRoCLength = input(title="Short RoC Length", type=input.integer, defval=11, group = "C2 - Coppock curve")
curve = wma(roc(close, coppock_curve_longRoCLength) + roc(close, coppock_curve_shortRoCLength), coppock_curve_wma_length)
//
Coppock_Long = curve > 0
Coppock_Short = curve < 0
//}
//==============================================================================
// C2 Trend Magic
//==============================================================================
//{
tm_period = input(20,"CCI period", group = "C2 - Trend Magic")
tm_coeff = input(1,"ATR Multiplier", group = "C2 - Trend Magic")
tm_AP = input(5,"ATR Period", group = "C2 - Trend Magic")
tm_ATR = sma(tr, tm_AP)
tm_src = input(close, group = "C2 - Trend Magic")
upT = low - tm_ATR * tm_coeff
downT = high + tm_ATR * tm_coeff
MagicTrend = 0.0
MagicTrend := cci(tm_src, tm_period) >= 0 ? (upT < nz(MagicTrend[1]) ? nz(MagicTrend[1]) : upT) : (downT > nz(MagicTrend[1]) ? nz(MagicTrend[1]) : downT)
color1 = cci(tm_src,tm_period) >= 0 ? #0022FC : #FC0400
//
Trend_Magic_Long = close > MagicTrend
Trend_Magic_Short = close < MagicTrend
//}
//==============================================================================
// C2 Willians %R
//==============================================================================
//{
wr_length = input(title="Length", type=input.integer, defval=14, group = "C2 - Willians %R")
wr_src    = input(close, "Source", type = input.source, group = "C2 - Willians %R")
//
_pr(length) =>
	max = highest(length)
	min = lowest(length)
	100 * (wr_src - max) / (max - min)
//
percentR = _pr(wr_length)
//
Willians_Long = percentR < -50
Willians_Short = percentR > -50
//}
//
//==============================================================================
// Use C1/C2 and Type
//==============================================================================
//{
C1_L = (QQE_Long and (C1_Type == "QQE")) or (Ind_1_L_Trigger and (C1_Type == "Aroon")) or (VI_Long and (C1_Type == "Vortex_Indicator")) or (Acc_Long and (C1_Type == "Accel_Oscillator")) or (long_SSL_c1 and (C1_Type == "SSL_C1")) or (Demarker_Long and (C1_Type == "Cronex_T_Demarker_Z_Cross")) or (Squeeze_Long and (C1_Type == "Squeeze_Momentum_Indicator")) or (Momentum_Long and (C1_Type == "Price_Momentum_Oscillator")) or (Anchored_Long and (C1_Type == "Anchored_Momentum")) or (Wave_Trend_Long and (C1_Type == "Wave_Trend_Oscillator")) or (Long_AKS and (C1_Type == "ATR+Kijun-Sen")) 
C1_S = (QQE_Short and (C1_Type == "QQE")) or (Ind_1_S_Trigger and (C1_Type == "Aroon")) or (VI_Short and (C1_Type == "Vortex_Indicator")) or (Acc_Short and (C1_Type == "Accel_Oscillator")) or (short_SSL_c1 and (C1_Type == "SSL_C1")) or (Demarker_Short and (C1_Type == "Cronex_T_Demarker_Z_Cross")) or (Squeeze_Short and (C1_Type == "Squeeze_Momentum_Indicator")) or (Momentum_Short and (C1_Type == "Price_Momentum_Oscillator")) or (Anchored_Short and (C1_Type == "Anchored_Momentum")) or (Wave_Trend_Short and (C1_Type == "Wave_Trend_Oscillator")) or (Short_AKS and (C1_Type == "ATR+Kijun-Sen")) 
//
C2_L = (QQE_Histo_Long and (C2_Type == "QQE_Histo")) or (ASI_Long and (C2_Type == "Abs_Str_Histo")) or (long_ST and (C2_Type == "Super_Trend")) or (long_KDJ and (C2_Type == "KDJ")) or (long_SSL_c2 and (C2_Type == "SSL_C2")) or (Kuskus_Long and (C2_Type == "Kuskus_Starlight")) or (Sniper_Long and (C2_Type == "FX_Sniper_Ergodic")) or (Coppock_Long and (C2_Type == "Coppock_curve")) or (Trend_Magic_Long and (C2_Type == "Trend_Magic")) or (Willians_Long and (C2_Type == "Willians_%R")) 
C2_S = (QQE_Histo_Short and (C2_Type == "QQE_Histo")) or (ASI_Short and (C2_Type == "Abs_Str_Histo")) or (short_ST and (C2_Type == "Super_Trend")) or (short_KDJ and (C2_Type == "KDJ")) or (short_SSL_c2 and (C2_Type == "SSL_C2")) or (Kuskus_Short and (C2_Type == "Kuskus_Starlight")) or (Sniper_Short and (C2_Type == "FX_Sniper_Ergodic")) or (Coppock_Short and (C2_Type == "Coppock_curve")) or (Trend_Magic_Short and (C2_Type == "Trend_Magic")) or (Willians_Short and (C2_Type == "Willians_%R"))
//
C1_Long =  C1_L or (Use_C1 == false)
C1_Short = C1_S or (Use_C1 == false)
C2_Long = C2_L or (Use_C2 == false)
C2_Short = C2_S or (Use_C2 == false)
//
Long_Confirm = C1_Long and C2_Long
Short_Confirm = C1_Short and C2_Short
//
Count_confirm_long := Long_Confirm ? Count_confirm_long[1] + 1 : 0
Count_confirm_short := Short_Confirm ? Count_confirm_short[1] + 1 : 0
//
No_Confirm = Long_Confirm or Short_Confirm
//}
//
//==============================================================================
// ATR Selection
//==============================================================================
//{
show_atr = input(title="Show ATR bands", type=input.bool, defval=true, group = "ATR Variables")
//ATR
atrlen = input(10, "ATR Period", group = "ATR Variables")
smoothing = input(title="ATR Smoothing", defval="WMA", options=["RMA", "SMA", "EMA", "WMA"], group = "ATR Variables")
//
ma_function(source, atrlen) => 
    if smoothing == "RMA"
        rma(source, atrlen)
    else
        if smoothing == "SMA"
            sma(source, atrlen)
        else
            if smoothing == "EMA"
                ema(source, atrlen)
            else
                wma(source, atrlen)
atr_slen = ma_function(tr(true), atrlen)
//}
//
//==============================================================================
////Baseline / Continuation / Exit - Moving Averages
//==============================================================================
//{
// Baseline Inputs
//
show_Baseline = input(title="Show Baseline", type=input.bool, defval=true, group = "Baseline Variables")
//
maType = input(title="Baseline Type", type=input.string, defval="EMA", options=["SMA","EMA","DEMA","TEMA","LSMA","WMA","MF","VAMA","TMA","HMA", "JMA", "Kijun v2", "EDSMA","McGinley"], group = "Baseline Variables")
len = input(title="Baseline Length", defval=14, group = "Baseline Variables")
//
SSL2Type = input(title="Continuation Type", type=input.string, defval="JMA", options=["SMA","EMA","DEMA","TEMA","WMA","MF","VAMA","TMA","HMA", "JMA","McGinley"], group = "Continuation Variables")
len2 = input(title="Continuation Length", defval=5, group = "Continuation Variables")
//
SSL3Type = input(title="EXIT Type", type=input.string, defval="HMA", options=["DEMA","TEMA","LSMA","VAMA","TMA","HMA","JMA", "Kijun v2", "McGinley", "MF"], group = "Exit Variables")
len3 = input(title="EXIT Length", defval=15, group = "Exit Variables")
src = input(title="Source", type=input.source, defval=close, group = "Exit Variables")
//
tema(src, len) =>
    ema1 = ema(src, len)
    ema2 = ema(ema1, len)
    ema3 = ema(ema2, len)
    (3 * ema1) - (3 * ema2) + ema3
kidiv = input(defval=1,maxval=4,  title="Kijun MOD Divider", group = "Kijun Baseline Variables")
//
jurik_phase = input(title="* Jurik (JMA) Only - Phase", type=input.integer, defval=3, group = "JMA Baseline Variables")
jurik_power = input(title="* Jurik (JMA) Only - Power", type=input.integer, defval=1, group = "JMA Baseline Variables")
volatility_lookback = input(10, title="* Volatility Adjusted (VAMA) Only - Volatility lookback length", group = "VAMA Baseline Variables")
// MF
beta = input(0.8,minval=0,maxval=1,step=0.1,  title="Modular Filter, General Filter Only - Beta" , group = "MF Baseline Variables")
feedback = input(false, title="Modular Filter Only - Feedback", group = "MF Baseline Variables")
z = input(0.5,title="Modular Filter Only - Feedback Weighting",step=0.1, minval=0, maxval=1, group = "MF Baseline Variables")
// EDSMA
ssfLength = input(title="EDSMA - Super Smoother Filter Length", type=input.integer, minval=1, defval=20, group = "EDSMA Baseline Variables")
ssfPoles = input(title="EDSMA - Super Smoother Filter Poles", type=input.integer, defval=2, options=[2, 3], group = "EDSMA Baseline Variables")
//
// EDSMA
get2PoleSSF(src, length) =>
    PI = 2 * asin(1)
    arg = sqrt(2) * PI / length
    a1 = exp(-arg)
    b1 = 2 * a1 * cos(arg)
    c2 = b1
    c3 = -pow(a1, 2)
    c1 = 1 - c2 - c3
    ssf = 0.0
    ssf := c1 * src + c2 * nz(ssf[1]) + c3 * nz(ssf[2])
//
get3PoleSSF(src, length) =>
    PI = 2 * asin(1)
    arg = PI / length
    a1 = exp(-arg)
    b1 = 2 * a1 * cos(1.738 * arg)
    c1 = pow(a1, 2)
    coef2 = b1 + c1
    coef3 = -(c1 + b1 * c1)
    coef4 = pow(c1, 2)
    coef1 = 1 - coef2 - coef3 - coef4
    ssf = 0.0
    ssf := coef1 * src + coef2 * nz(ssf[1]) + coef3 * nz(ssf[2]) + coef4 * nz(ssf[3])
//
ma(type, src, len) =>
    float result = 0
    if type=="TMA"
        result := sma(sma(src, ceil(len / 2)), floor(len / 2) + 1)
    if type=="MF"
        ts=0.,b=0.,c=0.,os=0.
        //----
        alpha = 2/(len+1)
        a = feedback ? z*src + (1-z)*nz(ts[1],src) : src
        //----
        b := a > alpha*a+(1-alpha)*nz(b[1],a) ? a : alpha*a+(1-alpha)*nz(b[1],a)
        c := a < alpha*a+(1-alpha)*nz(c[1],a) ? a : alpha*a+(1-alpha)*nz(c[1],a)
        os := a == b ? 1 : a == c ? 0 : os[1]
        //----
        upper = beta*b+(1-beta)*c
        lower = beta*c+(1-beta)*b 
        ts := os*upper+(1-os)*lower
        result := ts
    if type=="LSMA"
        result := linreg(src, len, 0)
    if type=="SMA" // Simple
        result := sma(src, len)
    if type=="EMA" // Exponential
        result := ema(src, len)
    if type=="DEMA" // Double Exponential
        e = ema(src, len)
        result := 2 * e - ema(e, len)
    if type=="TEMA" // Triple Exponential
        e = ema(src, len)
        result := 3 * (e - ema(e, len)) + ema(ema(e, len), len)
    if type=="WMA" // Weighted
        result := wma(src, len)
    if type=="VAMA" // Volatility Adjusted
        /// Copyright © 2019 to present, Joris Duyck (JD)
        mid=ema(src,len)
        dev=src-mid
        vol_up=highest(dev,volatility_lookback)
        vol_down=lowest(dev,volatility_lookback)
        result := mid+avg(vol_up,vol_down)
    if type=="HMA" // Hull
        result := wma(2 * wma(src, len / 2) - wma(src, len), round(sqrt(len)))
    if type=="JMA" // Jurik
        /// Copyright © 2018 Alex Orekhov (everget)
        /// Copyright © 2017 Jurik Research and Consulting.
        phaseRatio = jurik_phase < -100 ? 0.5 : jurik_phase > 100 ? 2.5 : jurik_phase / 100 + 1.5
        beta = 0.45 * (len - 1) / (0.45 * (len - 1) + 2)
        alpha = pow(beta, jurik_power)
        jma = 0.0
        e0 = 0.0
        e0 := (1 - alpha) * src + alpha * nz(e0[1])
        e1 = 0.0
        e1 := (src - e0) * (1 - beta) + beta * nz(e1[1])
        e2 = 0.0
        e2 := (e0 + phaseRatio * e1 - nz(jma[1])) * pow(1 - alpha, 2) + pow(alpha, 2) * nz(e2[1])
        jma := e2 + nz(jma[1])
        result := jma
    if type=="Kijun v2"
        kijun = avg(lowest(len), highest(len))//, (open + close)/2)
        conversionLine = avg(lowest(len/kidiv), highest(len/kidiv))
        delta = (kijun + conversionLine)/2
        result :=delta
    if type=="McGinley"
        mg = 0.0
        mg := na(mg[1]) ? ema(src, len) : mg[1] + (src - mg[1]) / (len * pow(src/mg[1], 4))
        result :=mg
    if type=="EDSMA"
    
        zeros = src - nz(src[2])
        avgZeros = (zeros + zeros[1]) / 2
        
        // Ehlers Super Smoother Filter 
        ssf = ssfPoles == 2
             ? get2PoleSSF(avgZeros, ssfLength)
             : get3PoleSSF(avgZeros, ssfLength)
        
        // Rescale filter in terms of Standard Deviations
        stdev = stdev(ssf, len)
        scaledFilter = stdev != 0
             ? ssf / stdev
             : 0
        
        alpha = 5 * abs(scaledFilter) / len
        
        edsma = 0.0
        edsma := alpha * src + (1 - alpha) * nz(edsma[1])
        result :=  edsma
    result
//  
// Continuation
emaHigh = ma(maType, high, len)
emaLow = ma(maType, low, len)
//
maHigh = ma(SSL2Type, high, len2)
maLow = ma(SSL2Type, low, len2)
//
// EXIT
ExitHigh = ma(SSL3Type, high, len3)
ExitLow = ma(SSL3Type, low, len3)
//
// Keltner Baseline Channel
BBMC = ma(maType, close, len)
useTrueRange = input(true, group = "Baseline Channel Variables")
multy = input(0.0, step=0.05, title="Base Channel Multiplier", group = "Baseline Channel Variables")
Keltma = ma(maType, src, len)
range = useTrueRange ? tr : high - low
rangema = ema(range, len)
upperk =Keltma + rangema * multy
lowerk = Keltma - rangema * multy
//
// Baseline Cross
base_cross_Long = (close > BBMC)
base_cross_Short = (close < BBMC)
//
Count_blc_long := base_cross_Long ? Count_blc_long[1] + 1 : 0
Count_blc_short := base_cross_Short ? Count_blc_short[1] + 1 : 0
//}
//
//==============================================================================
// ATR Upper/Lower Values/Bands
//==============================================================================
//{
////ATR Up/Low Bands
upper_band = atr_slen * TSL_ATR_Var + close
lower_band = close - atr_slen * TSL_ATR_Var
//
//ATR Upper Entry Limits
//
lower_ATR_value = atr_slen * Baseline_ATR_Cross + close
upper_ATR_value  = close - atr_slen * Baseline_ATR_Cross
//
Long_ATR_Allowed = BBMC > upper_ATR_value
Short_ATR_Allowed = BBMC < lower_ATR_value
//}
//
//==============================================================================
// Baseline Violation Candle
//==============================================================================
//{
open_pos =  open*1
close_pos = close*1
difference = abs(close_pos-open_pos)
atr_violation = difference > atr_slen
InRange = upper_band > BBMC and lower_band < BBMC
candlesize_violation = atr_violation and InRange
plotshape(candlesize_violation, color=color.white, size=size.tiny,style=shape.diamond, location=location.top, transp=0,title="Candle Size > 1xATR")
//}
//
//==============================================================================
// Continuation Values
//==============================================================================
//{
//CONTINUATION VALUES
Hlv2 = int(na)
Hlv2 := close > maHigh ? 1 : close < maLow ? -1 : Hlv2[1]
sslDown2 = Hlv2 < 0 ? maHigh : maLow
//}
//
//==============================================================================
// Exit Values
//==============================================================================
//{
Hlv3 = int(na)
Hlv3 := close > ExitHigh ? 1 : close < ExitLow ? -1 : Hlv3[1]
sslExit = Hlv3 < 0 ? ExitHigh : ExitLow
//
Exit_SSL3_Long = crossover(sslExit, close) and (close > BBMC)
Exit_SSL3_Short = crossover(close, sslExit) and (close < BBMC)
//
Exit_BL_Long = crossover(BBMC, close)
Exit_BL_Short = crossover(close, BBMC)
//}
//
//==============================================================================
// Price Movement
//==============================================================================
//{
//{
move_up = (close > open) or (Movement_Favour == false)
move_down = (close < open) or (Movement_Favour == false)
move_up_cont = (close > open) or (Movement_Favour_Cont == false)
move_down_cont = (close < open) or (Movement_Favour_Cont == false)
//}
//}
//
//==============================================================================
// Colour Bars
//==============================================================================
//{
show_color_bar = input(title="Color Bars", type=input.bool, defval=true, group = "Bar Colours Variables")
color_bar = close > upperk ? #28CB12 : close < lowerk ? #CB1512 : color.gray
color_bar2 = No_Confirm == false ? #979797 : na
//}
//
//==============================================================================
// Baseline Plots
//==============================================================================
//{
p1 = plot(show_Baseline ? BBMC : na, color=color_bar, linewidth=4,transp=0, title='MA Baseline')
barcolor(show_color_bar ? color_bar2 : na)
up_channel = plot(show_Baseline ? upperk : na, color=color_bar, title="Baseline Upper Channel")
low_channel = plot(show_Baseline ? lowerk : na, color=color_bar, title="Basiline Lower Channel")
fill(up_channel, low_channel,color=color_bar, transp=100)
//}
//
//==============================================================================
// Continiuation from ATR
//==============================================================================
//{
atr_crit = input(0.9, step=0.1, title="Continuation ATR Criteria", group = "Continuation Variables")
upper_half = atr_slen * atr_crit + close
lower_half = close - atr_slen * atr_crit
buy_inatr =  lower_half < sslDown2
sell_inatr = upper_half > sslDown2
sell_cont = (close < BBMC) and (close < sslDown2)
buy_cont = (close > BBMC) and (close > sslDown2)
sell_atr = sell_inatr and sell_cont
buy_atr = buy_inatr
atr_fill = buy_atr ? color.black : sell_atr ? color.black: color.white
LongPlot = plot(sslDown2, title="SSL2", linewidth=2, color=atr_fill, style=plot.style_circles, transp=0)
//}
//
//==============================================================================
// ATR Bands 
//==============================================================================
//{
calc_atr = atr_slen * 1000
round_atr = round (calc_atr)
current_atr = round_atr /1000
current_atr_TP = current_atr * TP_ATR_Var
multi_atr = current_atr * TSL_ATR_Var
label_loc = BBMC 
Long_Price = close > BBMC
Short_Price = close < BBMC
TSL_Price = Long_Price == true ? (close - multi_atr): Short_Price == true ? (close + multi_atr): na
TP_Price = Long_Price == true ? (close + current_atr_TP): Short_Price == true ? (close - current_atr_TP): na
//
upper_band1 = Long_Price == true ? (atr_slen * TP_ATR_Var + close): Short_Price == true ? (atr_slen * TSL_ATR_Var + close): na
lower_band1 = Long_Price == true ? (close - atr_slen * TSL_ATR_Var): Short_Price == true ? (close - atr_slen * TP_ATR_Var): na
//
upper_band_colour = Long_Price == true ? color.blue : Short_Price == true ? color.red : na
lower_band_colour = Long_Price == true ? color.red : Short_Price == true ? color.blue : na
//
u = plot(show_atr ? upper_band1 : na, "+ATR", color=upper_band_colour, transp=0)
l = plot(show_atr ? lower_band1 : na, "-ATR", color=lower_band_colour, transp=0)
//}
//
//==============================================================================
// Volume - Damiani Volameter
//==============================================================================
//{
//mtf library
useCurrentRes = input(true, title="useCurrentRes", group = "Volume - Damiani Volatmeter")
res = input(title="Different Timeframe", type=input.resolution, defval="240", group = "Volume - Damiani Volatmeter")
uptimeflame = input(false, title="use upper up timeflame", type=input.bool, group = "Volume - Damiani Volatmeter")
upRes(res)=> res == "1"  ? "5" : res == "3"  ? "15" : res == "5"  ? "15" : res == "15"  ? "60" : res == "30"  ? "120" : res == "60"  ? "240" : res == "120"  ? "1D" : res == "180"  ? "1D" : res == "240"  ? "1D" : res == "1D"  ? "1W" : res == "1W"  ? "1M" : res == "D"  ? "1W" : res == "W"  ? "1M" : res
restf = useCurrentRes ? (uptimeflame ? upRes(timeframe.period) : timeframe.period) : (uptimeflame ? upRes(res) : res)
cvttf2n(a)=>a == '1' ?  1 : a == '3' ?  3 : a == '5' ?  5 : a == '15' ? 15 : a == '30' ?  30 : a == '60' ?  60 : a == '120' ?  120 : a == '180' ?  180 : a == '240' ?  240 : a == '1D' ?  1440 : a == '1W' ?  10080 : a == '1M' ?  43200 : a == 'D' ?  1440 : a == 'W' ?  10080 : a == 'M' ?  43200 : na
current_tf_mn = timeframe.ismonthly ? timeframe.multiplier * 43200 : timeframe.isweekly ? timeframe.multiplier * 10080 : timeframe.isdaily ? timeframe.multiplier * 1440 : timeframe.multiplier
cvttf2mult(rest) =>cvttf2n(rest)  / current_tf_mn
tf_mult = cvttf2mult(restf)
//
//source = input(close, title="Source ")
//
// original trend color
DVColorMode = input ("MACD(close)", title = "DV Color mode",options=["MACD(DV)", "trend", "MACD(close)","MACD os(close)","donchian"], group = "Volume - Damiani Volatmeter")
donchian(len) => avg(lowest(len), highest(len))
//MACD
dummyMACD = input(false, title = "MACD setting, MACD", group = "Volume - Damiani Volatmeter")
MACDfast = input(9, title = "MACD fast length", group = "Volume - Damiani Volatmeter")
MACDslow = input(17, title = "MACD slow length", group = "Volume - Damiani Volatmeter")
MACDsignal = input(7, title = "MACD signal length", group = "Volume - Damiani Volatmeter")
//trend
dummytrend = input(false, title = "trend setting, trend", group = "Volume - Damiani Volatmeter")
vwmalen = input(3, title = "trend color length", group = "Volume - Damiani Volatmeter")
vwmasig = input(3, title = "trend color smooth", group = "Volume - Damiani Volatmeter")
//donchian
dummydonchian = input(false, title = "donchian setting, donchian", group = "Volume - Damiani Volatmeter")
donchianfast = input(13, title = "(donchian)fast length", group = "Volume - Damiani Volatmeter")
donchianslow = input(20, title = "(donchian)slow length", group = "Volume - Damiani Volatmeter")
//
//ColorOsi(src, 9 ,17, 7, color.green, color.red)
ColorOsi(src, upc, dnc) => 
	ret = upc
	if DVColorMode == "MACD(DV)"
		macd = ema(src, MACDfast) - ema(src, MACDslow)
        sig = ema(macd, MACDsignal)
        hist = macd - sig
		ret := hist >= 0 ? upc : dnc
	if DVColorMode == "trend"
		vwmaval = vwma(close, vwmalen)
		vwmasigval = sma(vwmaval, vwmasig)
		ret := vwmaval >= vwmasigval ? upc : dnc
	if DVColorMode == "MACD(close)"
		macd = ema(close, MACDfast) - ema(close, MACDslow)
		sig = sma(macd, MACDsignal)
		hist = macd - sig
		ret := hist >= 0 ? upc : dnc
	if DVColorMode == "MACD os(close)"
		macd = ema(close, MACDfast) - ema(close, MACDslow)
		sig = sma(macd, MACDsignal)
		hist = macd - sig
		ret := hist >= hist[1] ? upc : dnc
	if DVColorMode == "donchian"
		donchianfastval = donchian(donchianfast)
		donchianval = donchianfastval - donchian(donchianslow)
		donchiandir = donchianval == 0 ? (close > donchianfastval ? 1 : -1) : donchianval
		ret := donchiandir >= 0 ? upc : dnc
	ret
//
dummydv = input(false, title = "Damiani Volatmeter setting DV", group = "Volume - Damiani Volatmeter")
usevolmode = true //input(true, title = "use volume Mode")
vis_atr = input(13, group = "Volume - Damiani Volatmeter")
vis_std = input(20, group = "Volume - Damiani Volatmeter")
sed_atr = input(40, group = "Volume - Damiani Volatmeter")
sed_std = input(100, group = "Volume - Damiani Volatmeter")
threshold_level = input(1.4, group = "Volume - Damiani Volatmeter")
lag_supressor = input(true, group = "Volume - Damiani Volatmeter")
//
atrv(len)=>rma(volume, len)
//DV(13,20,40,100,1.4,true)
DV(vis_atr,vis_std,sed_atr,sed_std,threshold_level,lag_supressor)=>
	vol = 0.0
	lag_s_K = 0.5
	s1=nz(vol[1], 0)
	s3=nz(vol[3], 0)
    vol := lag_supressor ? atr(vis_atr) / atr(sed_atr) + lag_s_K*(s1-s3) : atr(vis_atr) / atr(sed_atr)
	anti_thres = stdev(close, vis_std) / stdev(close, sed_std)
	t = threshold_level - anti_thres
	t- vol
//Standard Deviation Function
st_dev(y, t)=>sqrt(sma(pow(y - sma(y, t), 2), t))
//
//Correlation Coefficient
corr(x, y, t)=>
    x_dev = x - sma(x, t)
    y_dev = y - sma(y, t)
    xy_sum = 0.0
    x2_sum = 0.0
    y2_sum = 0.0
    for i = 0 to (t - 1)
        xy_sum := xy_sum + x_dev[i]*y_dev[i]
        x2_sum := x2_sum + pow(x_dev[i], 2)
        y2_sum := y2_sum + pow(y_dev[i], 2)
    xy_sum/sqrt(x2_sum*y2_sum)
//
DVval = -DV(vis_atr,vis_std,sed_atr,sed_std,threshold_level,lag_supressor)
mtfDV = security(syminfo.tickerid, restf, DVval)
//
bgcolor((mtfDV < 0 and Use_Vol and (Vol_Type == "Damiani_Volameter")) == true ? color.new(color.red, 80) : color.new(color.red, 100))
//
Volume_Entry_Block_Dam = (mtfDV < 0) and (Use_Vol == true) and (Vol_Type == "Damiani_Volameter") ? true : false
//}
//
//==============================================================================
// Volume -  Waddah Attar Explosion
//==============================================================================
//{
sensitivity = input(150, title="Sensitivity", group = "Volume - Waddah Attar Explosion")
fastLength=input(20, title="FastEMA Length", group = "Volume - Waddah Attar Explosion")
slowLength=input(40, title="SlowEMA Length", group = "Volume - Waddah Attar Explosion")
channelLength=input(20, title="BB Channel Length", group = "Volume - Waddah Attar Explosion")
mult=input(2.0, title="BB Stdev Multiplier", group = "Volume - Waddah Attar Explosion")
//
DEAD_ZONE = nz(rma(tr(true),100)) * 3.7
//
calc_macd(source, fastLength, slowLength) =>
	fastMA = ema(source, fastLength)
	slowMA = ema(source, slowLength)
	fastMA - slowMA
//
calc_BBUpper(source, length, mult) => 
	basis = sma(source, length)
	dev = mult * stdev(source, length)
	basis + dev
//
calc_BBLower(source, length, mult) => 
	basis = sma(source, length)
	dev = mult * stdev(source, length)
	basis - dev
//
t1 = (calc_macd(close, fastLength, slowLength) - calc_macd(close[1], fastLength, slowLength))*sensitivity
t2 = (calc_macd(close[2], fastLength, slowLength) - calc_macd(close[3], fastLength, slowLength))*sensitivity
//
e1V = (calc_BBUpper(close, channelLength, mult) - calc_BBLower(close, channelLength, mult))
//
trendUp = (t1 >= 0) ? t1 : 0
trendDown = (t1 < 0) ? (-1*t1) : 0
//
WAE_Low = e1V <= DEAD_ZONE ? true : false
//
bgcolor((WAE_Low and (Use_Vol == true) and (Vol_Type == "Waddah_Attar_Explosion")) == true ? color.new(color.red, 80) : color.new(color.red, 100))
//
Volume_Entry_Block_WAE = WAE_Low and (Use_Vol == true) and (Vol_Type == "Waddah_Attar_Explosion") ? true : false
//}
//
//==============================================================================
// Volume - Block
//==============================================================================
//{
Volume_Entry_Block = Volume_Entry_Block_Dam or Volume_Entry_Block_WAE
//}
//
//==============================================================================
// Currency Strength
//==============================================================================
//{
// Inputs
string resotype_autovalue = (not timeframe.isintraday) ? "12M" : (timeframe.multiplier >= 60) ? "W" : (timeframe.multiplier >= 240) ? "M" : "D"
string resotype_lookback = 'Use Lookback Number'
string resotype = input("auto", "Resolution", options=["D", "W", "M", "12M", "auto", resotype_lookback], group = "Currency Strength")
string reso = (resotype == resotype_lookback) ? timeframe.period : (resotype == "auto") ? resotype_autovalue: resotype
int resotype_lookbackperiod = (resotype == resotype_lookback) ? input(100, "└ Lookback Number", minval=1) : 1
string BROKER = input(title="Brokers", options=["OANDA", "FOREXCOM", "SAXO", "FX_IDC", "FX"], defval="OANDA", group = "Currency Strength")
float v1_EURUSD = security(BROKER + ":EURUSD", timeframe.period, close)
float v1_USDJPY = security(BROKER + ":USDJPY", timeframe.period, close)
float v1_USDCHF = security(BROKER + ":USDCHF", timeframe.period, close)
float v1_GBPUSD = security(BROKER + ":GBPUSD", timeframe.period, close)
float v1_AUDUSD = security(BROKER + ":AUDUSD", timeframe.period, close)
float v1_USDCAD = security(BROKER + ":USDCAD", timeframe.period, close)
float v1_NZDUSD = security(BROKER + ":NZDUSD", timeframe.period, close)
float v1_USDSGD = security(BROKER + ":USDSGD", timeframe.period, close)
float v1_USDHKD = security(BROKER + ":USDHKD", timeframe.period, close)
float v1_USDPLN = security(BROKER + ":USDPLN", timeframe.period, close)
float v1_USDZAR = security(BROKER + ":USDZAR", timeframe.period, close)
float v2_EURUSD = security(BROKER + ":EURUSD", reso, close[resotype_lookbackperiod], barmerge.gaps_off, barmerge.lookahead_on)
float v2_USDJPY = security(BROKER + ":USDJPY", reso, close[resotype_lookbackperiod], barmerge.gaps_off, barmerge.lookahead_on)
float v2_USDCHF = security(BROKER + ":USDCHF", reso, close[resotype_lookbackperiod], barmerge.gaps_off, barmerge.lookahead_on)
float v2_GBPUSD = security(BROKER + ":GBPUSD", reso, close[resotype_lookbackperiod], barmerge.gaps_off, barmerge.lookahead_on)
float v2_AUDUSD = security(BROKER + ":AUDUSD", reso, close[resotype_lookbackperiod], barmerge.gaps_off, barmerge.lookahead_on)
float v2_USDCAD = security(BROKER + ":USDCAD", reso, close[resotype_lookbackperiod], barmerge.gaps_off, barmerge.lookahead_on)
float v2_NZDUSD = security(BROKER + ":NZDUSD", reso, close[resotype_lookbackperiod], barmerge.gaps_off, barmerge.lookahead_on)
float v2_USDSGD = security(BROKER + ":USDSGD", reso, close[resotype_lookbackperiod], barmerge.gaps_off, barmerge.lookahead_on)
float v2_USDHKD = security(BROKER + ":USDHKD", reso, close[resotype_lookbackperiod], barmerge.gaps_off, barmerge.lookahead_on)
float v2_USDPLN = security(BROKER + ":USDPLN", reso, close[resotype_lookbackperiod], barmerge.gaps_off, barmerge.lookahead_on)
float v2_USDZAR = security(BROKER + ":USDZAR", reso, close[resotype_lookbackperiod], barmerge.gaps_off, barmerge.lookahead_on)
//
current = syminfo.currency
base = syminfo.basecurrency
//
string diff_currency1 = current
string diff_currency2 = base
//
// Functions
get_name_by_value (v, _EUR, _USD, _JPY, _CHF, _GBP, _AUD, _CAD, _NZD, _SGD, _PLN, _ZAR) =>
  v==_EUR ? "EUR" : v==_USD ? "USD" : v==_JPY ? "JPY" : v==_CHF ? "CHF" : v==_GBP ? "GBP" : v==_AUD ? "AUD" : v==_CAD ? "CAD" : v==_NZD ? "NZD" : v==_SGD ? "SGD" : v==_PLN ? "PLN" : v==_ZAR ? "ZAR" : na
//
get_val (_v1, _v2) =>
    float res = 0
//
    if (_v2 == 0)
        res := 0
    else
        res := log(_v1 / _v2) * 10000
//
    res
//
get_val_m (_v1, _v2, _v3, _v4) =>
    float res = 0
    float v1 = _v1 * _v3
    float v2 = _v2 * _v4
//
    if (_v2 == 0)
        res := 0
    else
        res := log(v1 / v2) * 10000
//
    res
//
get_val_d (_v1, _v2, _v3, _v4) =>
    float res = 0
//
    if (_v3 == 0 or _v4 == 0)
        res := 0
    else
        float v1 = _v1 / _v3
        float v2 = _v2 / _v4
    
        if (v2 == 0)
            res := 0
        else
            res := log(v1 / v2) * 10000
//
    res
//
// Calculating
float EURUSD = get_val(v1_EURUSD, v2_EURUSD)
float USDJPY = get_val(v1_USDJPY, v2_USDJPY)
float USDCHF = get_val(v1_USDCHF, v2_USDCHF)
float GBPUSD = get_val(v1_GBPUSD, v2_GBPUSD)
float AUDUSD = get_val(v1_AUDUSD, v2_AUDUSD)
float USDCAD = get_val(v1_USDCAD, v2_USDCAD)
float NZDUSD = get_val(v1_NZDUSD, v2_NZDUSD)
float USDSGD = get_val(v1_USDSGD, v2_USDSGD)
float USDHKD = get_val(v1_USDHKD, v2_USDHKD)
float USDPLN = get_val(v1_USDPLN, v2_USDPLN)
float USDZAR = get_val(v1_USDZAR, v2_USDZAR)
float EURJPY = get_val_m(v1_EURUSD, v2_EURUSD, v1_USDJPY, v2_USDJPY)
float EURCHF = get_val_m(v1_EURUSD, v2_EURUSD, v1_USDCHF, v2_USDCHF)
float EURGBP = get_val_d(v1_EURUSD, v2_EURUSD, v1_GBPUSD, v2_GBPUSD)
float EURCAD = get_val_m(v1_EURUSD, v2_EURUSD, v1_USDCAD, v2_USDCAD)
float EURAUD = get_val_d(v1_EURUSD, v2_EURUSD, v1_AUDUSD, v2_AUDUSD)
float EURNZD = get_val_d(v1_EURUSD, v2_EURUSD, v1_NZDUSD, v2_NZDUSD)
float GBPCHF = get_val_m(v1_GBPUSD, v2_GBPUSD, v1_USDCHF, v2_USDCHF)
float GBPJPY = get_val_m(v1_GBPUSD, v2_GBPUSD, v1_USDJPY, v2_USDJPY)
float GBPCAD = get_val_m(v1_GBPUSD, v2_GBPUSD, v1_USDCAD, v2_USDCAD)
float GBPAUD = get_val_d(v1_GBPUSD, v2_GBPUSD, v1_AUDUSD, v2_AUDUSD)
float GBPNZD = get_val_d(v1_GBPUSD, v2_GBPUSD, v1_NZDUSD, v2_NZDUSD)
float AUDCHF = get_val_m(v1_AUDUSD, v2_AUDUSD, v1_USDCHF, v2_USDCHF)
float AUDJPY = get_val_m(v1_AUDUSD, v2_AUDUSD, v1_USDJPY, v2_USDJPY)
float AUDCAD = get_val_m(v1_AUDUSD, v2_AUDUSD, v1_USDCAD, v2_USDCAD)
float AUDNZD = get_val_d(v1_AUDUSD, v2_AUDUSD, v1_NZDUSD, v2_NZDUSD)
float NZDCAD = get_val_m(v1_NZDUSD, v2_NZDUSD, v1_USDCAD, v2_USDCAD)
float NZDCHF = get_val_m(v1_NZDUSD, v2_NZDUSD, v1_USDCHF, v2_USDCHF)
float NZDJPY = get_val_m(v1_NZDUSD, v2_NZDUSD, v1_USDJPY, v2_USDJPY)
float CADJPY = get_val_d(v1_USDJPY, v2_USDJPY, v1_USDCAD, v2_USDCAD)
float CADCHF = get_val_d(v1_USDCHF, v2_USDCHF, v1_USDCAD, v2_USDCAD)
float CHFJPY = get_val_d(v1_USDJPY, v2_USDJPY, v1_USDCHF, v2_USDCHF)
//
float CADSGD = get_val_d(v1_USDSGD, v2_USDSGD, v1_USDCAD, v2_USDCAD)
float SGDJPY = get_val_d(v1_USDJPY, v2_USDJPY, v1_USDSGD, v2_USDSGD)
float CHFSGD = get_val_d(v1_USDSGD, v2_USDSGD, v1_USDCHF, v2_USDCHF)
float AUDSGD = get_val_m(v1_AUDUSD, v2_AUDUSD, v1_USDSGD, v2_USDSGD)
float NZDSGD = get_val_m(v1_NZDUSD, v2_NZDUSD, v1_USDSGD, v2_USDSGD)
float GBPSGD = get_val_m(v1_GBPUSD, v2_GBPUSD, v1_USDSGD, v2_USDSGD)
//
float CADHKD = get_val_d(v1_USDHKD, v2_USDHKD, v1_USDCAD, v2_USDCAD)
float HKDJPY = get_val_d(v1_USDJPY, v2_USDJPY, v1_USDHKD, v2_USDHKD)
float CHFHKD = get_val_d(v1_USDHKD, v2_USDHKD, v1_USDCHF, v2_USDCHF)
float AUDHKD = get_val_m(v1_AUDUSD, v2_AUDUSD, v1_USDHKD, v2_USDHKD)
float NZDHKD = get_val_m(v1_NZDUSD, v2_NZDUSD, v1_USDHKD, v2_USDHKD)
float GBPHKD = get_val_m(v1_GBPUSD, v2_GBPUSD, v1_USDHKD, v2_USDHKD)
//
float CADPLN = get_val_d(v1_USDPLN, v2_USDPLN, v1_USDCAD, v2_USDCAD)
float PLNJPY = get_val_d(v1_USDJPY, v2_USDJPY, v1_USDPLN, v2_USDPLN)
float CHFPLN = get_val_d(v1_USDPLN, v2_USDPLN, v1_USDCHF, v2_USDCHF)
float AUDPLN = get_val_m(v1_AUDUSD, v2_AUDUSD, v1_USDPLN, v2_USDPLN)
float NZDPLN = get_val_m(v1_NZDUSD, v2_NZDUSD, v1_USDPLN, v2_USDPLN)
float GBPPLN = get_val_m(v1_GBPUSD, v2_GBPUSD, v1_USDPLN, v2_USDPLN)
//
float CADZAR = get_val_d(v1_USDZAR, v2_USDZAR, v1_USDCAD, v2_USDCAD)
float ZARJPY = get_val_d(v1_USDJPY, v2_USDJPY, v1_USDZAR, v2_USDZAR)
float CHFZAR = get_val_d(v1_USDZAR, v2_USDZAR, v1_USDCHF, v2_USDCHF)
float AUDZAR = get_val_m(v1_AUDUSD, v2_AUDUSD, v1_USDZAR, v2_USDZAR)
float NZDZAR = get_val_m(v1_NZDUSD, v2_NZDUSD, v1_USDZAR, v2_USDZAR)
float GBPZAR = get_val_m(v1_GBPUSD, v2_GBPUSD, v1_USDZAR, v2_USDZAR)
//
int pairs = 7
int pairs_Lres = 2
int pairs_Mres = 4
float EUR = (( EURUSD + EURJPY + EURCHF + EURGBP + EURAUD + EURCAD + EURNZD) / pairs)
float USD = ((-EURUSD + USDJPY + USDCHF - GBPUSD - AUDUSD + USDCAD - NZDUSD) / pairs)
float JPY = ((-EURJPY - USDJPY - CHFJPY - GBPJPY - AUDJPY - CADJPY - NZDJPY) / pairs)
float CHF = ((-EURCHF - USDCHF + CHFJPY - GBPCHF - AUDCHF - CADCHF - NZDCHF) / pairs)
float GBP = ((-EURGBP + GBPUSD + GBPCHF + GBPJPY + GBPAUD + GBPCAD + GBPNZD) / pairs)
float AUD = ((-EURAUD + AUDUSD + AUDJPY + AUDCHF - GBPAUD + AUDCAD + AUDNZD) / pairs)
float CAD = ((-EURCAD - USDCAD + CADJPY + CADCHF - GBPCAD - AUDCAD - NZDCAD) / pairs)
float NZD = ((-EURNZD + NZDUSD + NZDJPY + NZDCHF - GBPNZD + NZDCAD - AUDNZD) / pairs)
float SGD = ((-CADSGD - USDSGD + SGDJPY - CHFSGD - AUDSGD - NZDSGD - GBPSGD) / pairs)
float HKD = ((-CADHKD - USDHKD + HKDJPY - CHFHKD - AUDHKD - NZDHKD - GBPHKD) / pairs)
float PLN = ((-CADPLN - USDPLN + PLNJPY - CHFPLN - AUDPLN - NZDPLN - GBPPLN) / pairs)
float ZAR = ((-CADZAR - USDZAR + ZARJPY - CHFZAR - AUDZAR - NZDZAR - GBPZAR) / pairs)
//
// Diff
get_diff (_name) =>
    float _res = na
    
    if (_name == "USD")
        _res := USD
    else if (_name == "EUR")
        _res := EUR
    else if (_name == "JPY")
        _res := JPY
    else if (_name == "CHF")
        _res := CHF
    else if (_name == "GBP")
        _res := GBP
    else if (_name == "AUD")
        _res := AUD
    else if (_name == "CAD")
        _res := CAD
    else if (_name == "NZD")
        _res := NZD
    else if (_name == "SGD")
        _res := SGD
    else if (_name == "PLN")
        _res := PLN
    else if (_name == "ZAR")
        _res := ZAR
    [_res]
//
[DIFF1] = get_diff(diff_currency1)
[DIFF2] = get_diff(diff_currency2)
float DIFF = (DIFF1 - DIFF2)
//
// Analysis
values = array.new_float(0)
array.push(values, EUR), array.push(values, USD), array.push(values, JPY), array.push(values, CHF), 
array.push(values, GBP), array.push(values, AUD), array.push(values, CAD), array.push(values, NZD),
array.push(values, SGD), array.push(values, PLN), array.push(values, ZAR)
array.sort(values, order.descending)
//
names = array.new_string(0)
for i = 0 to array.size(values) - 1
    v = array.get(values, i)
    n = get_name_by_value(v, EUR, USD, JPY, CHF, GBP, AUD, CAD, NZD, SGD, PLN, ZAR)
    array.push(names, n)
//
float max_value = array.max(values)
float min_value = array.min(values)
string max_value_name = get_name_by_value(max_value, EUR, USD, JPY, CHF, GBP, AUD, CAD, NZD, SGD, PLN, ZAR)
string min_value_name  = get_name_by_value(min_value, EUR, USD, JPY, CHF, GBP, AUD, CAD, NZD, SGD, PLN, ZAR)
bool max_value_changed = max_value_name != max_value_name[1]
bool min_value_changed = min_value_name != min_value_name[1]
string note_ranking = array.join(names, ' > ')
//
ABS_Diff = abs(DIFF)
Calc_DIFF = (ABS_Diff* 0.7)/80
Strength_Rank = Calc_DIFF > 0 ? Calc_DIFF : 10 
//
Strength_Block = (Strength_Rank > 0) and Use_Strength and (Strength_Value > Strength_Rank) ? true : false
Strength_Block_Cont = (Strength_Rank > 0) and Use_Strength_Cont and (Strength_Value > Strength_Rank) ? true : false
Round_Strength_Rank = round(Strength_Rank)
//}
//==============================================================================
// Entry/Exit Indication
//==============================================================================
//==============================================================================
// Entry/Exit Indication
//==============================================================================
//{
Entry_Long = base_cross_Long and Long_ATR_Allowed and Long_Confirm and (not Volume_Entry_Block) and move_up and ((One_Candle == false) or ((One_Candle == true) and (Count_blc_long == 2))) and ((A_Bridge == false) or ((A_Bridge == true) and (Count_confirm_long <= 7))) and ((Use_EVZ == false) or ((Block_EVZ == false) and (Use_EVZ == true))) and not Strength_Block
Count_open_long := Entry_Long ? Count_open_long[1] + 1 : 0
//
Entry_Short = base_cross_Short and Short_ATR_Allowed and Short_Confirm and (not Volume_Entry_Block) and move_down and ((One_Candle == false) or ((One_Candle == true) and (Count_blc_short == 2))) and ((A_Bridge == false) or ((A_Bridge == true) and (Count_confirm_short <= 7))) and ((Use_EVZ == false) or ((Block_EVZ == false) and (Use_EVZ == true))) and not Strength_Block
Count_open_short := Entry_Short ? Count_open_short[1] + 1 : 0
//
Exit_Long = Exit_SSL3_Long or Exit_BL_Long
Count_close_long := Exit_Long ? 0 : base_cross_Short ? 0  : Count_close_long[1] + 1
//
Exit_Short = Exit_SSL3_Short or Exit_BL_Short
Count_close_short := Exit_Short ? 0 : base_cross_Long ? 0 : Count_close_short[1] + 1
//
Entry_Long_Cont = buy_cont and base_cross_Long and Long_Confirm and move_up_cont and (Count_blc_long > Count_close_long)  and ((Use_EVZ == false) or ((Block_EVZ == false) and (Use_EVZ == true))) and not Strength_Block_Cont
Count_open_long_cont := Entry_Long_Cont ? Count_open_long_cont[1] + 1 : 0
//
Entry_Short_Cont = sell_cont and base_cross_Short and Short_Confirm and move_down_cont and (Count_blc_short > Count_close_short)  and ((Use_EVZ == false) or ((Block_EVZ == false) and (Use_EVZ == true))) and not Strength_Block_Cont
Count_open_short_cont := Entry_Short_Cont ? Count_open_short_cont[1] + 1 : 0
//
// Plot Entry/Exit
//
Entry_Long_No_Repeat = Entry_Long and (Count_open_long <=1)
Entry_Long_Cont_No_Repeat = Entry_Long_Cont and (Count_open_long_cont <=2)
//
Entry_Short_No_Repeat = Entry_Short and (Count_open_short <=1)
Entry_Short_Cont_No_Repeat = Entry_Short_Cont and (Count_open_short_cont <=2)
//
plotshape(Entry_Long_No_Repeat or Entry_Long_Cont_No_Repeat, color=color.blue, size=size.small,style=shape.arrowup, location=location.belowbar, transp=0,title="Long Entry")
plotshape(Entry_Short_No_Repeat or Entry_Short_Cont_No_Repeat, color=color.blue, size=size.small,style=shape.arrowdown, location=location.abovebar, transp=0,title="Short Entry")
plotshape(Exit_Long, color=color.yellow, size=size.small,style=shape.arrowdown, location=location.abovebar, transp=0,title="Long Exit")
plotshape(Exit_Short,  color=color.yellow, size=size.small,style=shape.arrowup, location=location.belowbar, transp=0,title="Short Exit")
//}
//
//==============================================================================
// Alerts
//==============================================================================
//{
alertcondition((Entry_Long or Entry_Long_Cont), title='Entry Long', message='Entry Long Conditions Reached')
alertcondition((Entry_Short or Entry_Short_Cont), title='Entry Short', message='Entry Short Conditions Reached')
alertcondition(Exit_Long, title='Exit Long', message='Exit Long Conditions Reached')
alertcondition(Exit_Short, title='Exit Short', message='Exit Short Conditions Reached')
//}
//
//==============================================================================
// ATR Label
//==============================================================================
//{
textspacing = input(title="Text Label Spacing", defval=10, minval=1, group = "ATR Label Variables")
//
datetime = time - time[1]
//
l2 = label.new(time+datetime * textspacing,label_loc, 'SL/TSL ATR is '+tostring(multi_atr)+ '\  Price '+tostring(TSL_Price)+ '\nTP ATR is '+tostring(current_atr_TP)+ '\  Price '+tostring(TP_Price) + '\n$EVZ Rate '+tostring(EVZrate) + '\nStrength Rank '+tostring(Round_Strength_Rank), 
  color=color.gray, 
  textcolor= Entry_Long == true ? color.blue : Entry_Long_Cont == true ? color.blue : Entry_Short == true ? color.red : Entry_Short_Cont == true ? color.red : (Exit_Long == true or Exit_Short == true) ? color.yellow : color.gray,
  style=label.style_none,
  xloc = xloc.bar_time,
  yloc = yloc.price,
  size = size.large)
//
label.delete(l2[1])
//}
//
//==============================================================================
// Plots for Debugging
//==============================================================================
//{
// labelText =  "\nCounter open long " + tostring(Count_open_long) + "\nCounter open short " + tostring(Count_open_short)+ "\nCounter cross long " + tostring(Count_blc_long)+ "\nCounter cross short " + tostring(Count_blc_short)+ "\nCounter confirm long " + tostring(Count_confirm_long)+ "\nCounter confirm short " + tostring(Count_confirm_short)+ "\nCounter close long " + tostring(Count_close_long)+ "\nCounter close short " + tostring(Count_close_short)
// labelText =  "\nVIP " + tostring(VIP) + "\nVIM " + tostring(VIM)
// stratLabel = label.new(x=bar_index, y=na, text=labelText, yloc=yloc.belowbar, color=color.black, textcolor=color.white, style=label.style_labelup)
// label.delete(stratLabel[1])
//}
//
//==============================================================================
//       "The goal of a successful trader is to make the best trades"
//                          "Money is Secondary"
//                         Quote - Alexander Elder
//==============================================================================